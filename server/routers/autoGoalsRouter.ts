import { z } from "zod";
import { router, protectedProcedure, adminProcedure } from "../_core/trpc";
import { getDb } from "../db";
import { eq, and, desc, sql, inArray, gte, lte } from "drizzle-orm";
import { TRPCError } from "@trpc/server";
import {
  gapAnalysis,
  autoGeneratedGoals,
  goalTemplates,
  goalGenerationHistory,
  avdCompetencyAssessments,
  avdCompetencyAssessmentItems,
  competencies,
  employees,
  pdiPlans,
  pdiItems,
} from "../../drizzle/schema";

/**
 * Router para sistema de geração automática de metas PDI baseado em gaps
 */
export const autoGoalsRouter = router({
  // ============ ANÁLISE DE GAPS ============
  
  /**
   * Analisar gaps de um colaborador baseado em avaliações
   */
  analyzeGaps: protectedProcedure
    .input(z.object({
      employeeId: z.number(),
      sourceType: z.enum(["avaliacao_competencias", "avaliacao_desempenho", "pir", "feedback_360"]),
      sourceId: z.number(),
    }))
    .mutation(async ({ input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Database not available' });

      const { employeeId, sourceType, sourceId } = input;

      // Buscar avaliação de competências
      if (sourceType === "avaliacao_competencias") {
        const assessment = await db
          .select()
          .from(avdCompetencyAssessments)
          .where(eq(avdCompetencyAssessments.id, sourceId))
          .limit(1);

        if (assessment.length === 0) {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Avaliação não encontrada' });
        }

        // Buscar itens da avaliação
        const items = await db
          .select({
            competencyId: avdCompetencyAssessmentItems.competencyId,
            score: avdCompetencyAssessmentItems.score,
            competencyName: competencies.name,
            competencyCategory: competencies.category,
          })
          .from(avdCompetencyAssessmentItems)
          .leftJoin(competencies, eq(avdCompetencyAssessmentItems.competencyId, competencies.id))
          .where(eq(avdCompetencyAssessmentItems.assessmentId, sourceId));

        // Identificar gaps (score < 70)
        const gaps = [];
        for (const item of items) {
          const currentScore = item.score || 0;
          const targetScore = 80; // Meta padrão
          const gapSize = targetScore - currentScore;

          if (gapSize > 0) {
            // Determinar nível do gap
            let gapLevel: "critico" | "alto" | "medio" | "baixo";
            let priority: "critica" | "alta" | "media" | "baixa";

            if (currentScore < 40) {
              gapLevel = "critico";
              priority = "critica";
            } else if (currentScore < 60) {
              gapLevel = "alto";
              priority = "alta";
            } else if (currentScore < 70) {
              gapLevel = "medio";
              priority = "media";
            } else {
              gapLevel = "baixo";
              priority = "baixa";
            }

            // Inserir análise de gap
            const result = await db.insert(gapAnalysis).values({
              employeeId,
              competencyId: item.competencyId!,
              sourceType,
              sourceId,
              currentScore,
              targetScore,
              gapSize,
              gapLevel,
              priority,
              impactOnPerformance: Math.min(100, gapSize * 2), // Impacto proporcional ao gap
              developmentDifficulty: currentScore < 50 ? "dificil" : currentScore < 70 ? "medio" : "facil",
              context: `Gap identificado em ${item.competencyName} (${item.competencyCategory})`,
              status: "identificado",
            });

            gaps.push({
              id: result[0].insertId,
              competencyId: item.competencyId,
              competencyName: item.competencyName,
              currentScore,
              targetScore,
              gapSize,
              gapLevel,
              priority,
            });
          }
        }

        return {
          success: true,
          gapsIdentified: gaps.length,
          gaps,
        };
      }

      throw new TRPCError({ code: 'NOT_IMPLEMENTED', message: 'Tipo de fonte não implementado ainda' });
    }),

  /**
   * Listar gaps de um colaborador
   */
  listGaps: protectedProcedure
    .input(z.object({
      employeeId: z.number(),
      status: z.enum(["identificado", "em_desenvolvimento", "resolvido", "ignorado"]).optional(),
    }))
    .query(async ({ input }) => {
      const db = await getDb();
      if (!db) return { gaps: [] };

      const conditions = [eq(gapAnalysis.employeeId, input.employeeId)];
      if (input.status) {
        conditions.push(eq(gapAnalysis.status, input.status));
      }

      const gaps = await db
        .select({
          gap: gapAnalysis,
          competency: competencies,
        })
        .from(gapAnalysis)
        .leftJoin(competencies, eq(gapAnalysis.competencyId, competencies.id))
        .where(and(...conditions))
        .orderBy(desc(gapAnalysis.priority), desc(gapAnalysis.gapSize));

      return { gaps };
    }),

  // ============ TEMPLATES DE METAS ============

  /**
   * Criar template de meta
   */
  createGoalTemplate: adminProcedure
    .input(z.object({
      competencyId: z.number(),
      gapLevel: z.enum(["critico", "alto", "medio", "baixo"]),
      titleTemplate: z.string(),
      descriptionTemplate: z.string().optional(),
      suggestedDurationDays: z.number(),
      suggestedActions: z.any().optional(),
      suggestedResources: z.any().optional(),
      successCriteria: z.any().optional(),
      targetScore: z.number(),
      category: z.string().optional(),
      priority: z.enum(["baixa", "media", "alta", "critica"]).default("media"),
    }))
    .mutation(async ({ input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Database not available' });

      const result = await db.insert(goalTemplates).values({
        ...input,
        suggestedActions: input.suggestedActions ? JSON.stringify(input.suggestedActions) : null,
        suggestedResources: input.suggestedResources ? JSON.stringify(input.suggestedResources) : null,
        successCriteria: input.successCriteria ? JSON.stringify(input.successCriteria) : null,
        active: true,
      });

      return {
        success: true,
        id: result[0].insertId,
      };
    }),

  /**
   * Listar templates de metas
   */
  listGoalTemplates: protectedProcedure
    .input(z.object({
      competencyId: z.number().optional(),
      gapLevel: z.enum(["critico", "alto", "medio", "baixo"]).optional(),
      active: z.boolean().optional(),
    }))
    .query(async ({ input }) => {
      const db = await getDb();
      if (!db) return { templates: [] };

      const conditions = [];
      if (input.competencyId) {
        conditions.push(eq(goalTemplates.competencyId, input.competencyId));
      }
      if (input.gapLevel) {
        conditions.push(eq(goalTemplates.gapLevel, input.gapLevel));
      }
      if (input.active !== undefined) {
        conditions.push(eq(goalTemplates.active, input.active));
      }

      const templates = await db
        .select({
          template: goalTemplates,
          competency: competencies,
        })
        .from(goalTemplates)
        .leftJoin(competencies, eq(goalTemplates.competencyId, competencies.id))
        .where(conditions.length > 0 ? and(...conditions) : undefined)
        .orderBy(goalTemplates.priority, goalTemplates.competencyId);

      return { templates };
    }),

  // ============ GERAÇÃO AUTOMÁTICA DE METAS ============

  /**
   * Gerar metas automaticamente baseado em gaps
   */
  generateGoals: protectedProcedure
    .input(z.object({
      employeeId: z.number(),
      gapIds: z.array(z.number()).optional(), // Se não informado, gera para todos os gaps identificados
    }))
    .mutation(async ({ input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Database not available' });

      const { employeeId, gapIds } = input;

      // Buscar gaps a processar
      const conditions = [
        eq(gapAnalysis.employeeId, employeeId),
        eq(gapAnalysis.status, "identificado"),
      ];
      if (gapIds && gapIds.length > 0) {
        conditions.push(inArray(gapAnalysis.id, gapIds));
      }

      const gaps = await db
        .select({
          gap: gapAnalysis,
          competency: competencies,
        })
        .from(gapAnalysis)
        .leftJoin(competencies, eq(gapAnalysis.competencyId, competencies.id))
        .where(and(...conditions));

      if (gaps.length === 0) {
        return {
          success: true,
          goalsGenerated: 0,
          message: 'Nenhum gap identificado para gerar metas',
        };
      }

      const generatedGoals = [];

      for (const { gap, competency } of gaps) {
        // Buscar template correspondente
        const templates = await db
          .select()
          .from(goalTemplates)
          .where(and(
            eq(goalTemplates.competencyId, gap.competencyId),
            eq(goalTemplates.gapLevel, gap.gapLevel),
            eq(goalTemplates.active, true)
          ))
          .limit(1);

        const template = templates[0];

        // Gerar meta baseada no template ou criar genérica
        const title = template
          ? template.titleTemplate
              .replace('{competency}', competency?.name || 'competência')
              .replace('{target}', gap.targetScore.toString())
          : `Desenvolver ${competency?.name || 'competência'} até nível ${gap.targetScore}`;

        const description = template?.descriptionTemplate || 
          `Meta de desenvolvimento para reduzir gap de ${gap.gapSize} pontos na competência ${competency?.name}.`;

        const suggestedDurationDays = template?.suggestedDurationDays || 90;
        const startDate = new Date();
        const endDate = new Date(startDate);
        endDate.setDate(endDate.getDate() + suggestedDurationDays);

        // Criar meta auto-gerada
        const result = await db.insert(autoGeneratedGoals).values({
          employeeId,
          gapAnalysisId: gap.id,
          templateId: template?.id || null,
          title,
          description,
          specific: `Aumentar score de ${gap.currentScore} para ${gap.targetScore} em ${competency?.name}`,
          measurable: `Score atual: ${gap.currentScore}. Meta: ${gap.targetScore}. Gap: ${gap.gapSize} pontos.`,
          achievable: `Prazo de ${suggestedDurationDays} dias com ações estruturadas`,
          relevant: `Impacto no desempenho: ${gap.impactOnPerformance}%`,
          timeBound: `Início: ${startDate.toLocaleDateString()}. Fim: ${endDate.toLocaleDateString()}`,
          suggestedStartDate: startDate,
          suggestedEndDate: endDate,
          suggestedActions: template?.suggestedActions || null,
          suggestedResources: template?.suggestedResources || null,
          successCriteria: template?.successCriteria || JSON.stringify([
            { criterion: 'Atingir score mínimo', measurement: gap.targetScore },
          ]),
          targetScore: gap.targetScore,
          suggestedOwnerId: employeeId,
          status: "pendente",
        });

        generatedGoals.push({
          id: result[0].insertId,
          title,
          gapId: gap.id,
          competency: competency?.name,
        });

        // Atualizar status do gap
        await db
          .update(gapAnalysis)
          .set({ status: "em_desenvolvimento" })
          .where(eq(gapAnalysis.id, gap.id));
      }

      // Registrar histórico
      await db.insert(goalGenerationHistory).values({
        employeeId,
        triggerType: "gap_identificado",
        gapsAnalyzed: gaps.length,
        goalsGenerated: generatedGoals.length,
        goalsApproved: 0,
        goalsRejected: 0,
        analysisData: JSON.stringify({ gaps: gaps.map(g => g.gap.id) }),
        generatedGoalIds: JSON.stringify(generatedGoals.map(g => g.id)),
      });

      return {
        success: true,
        goalsGenerated: generatedGoals.length,
        goals: generatedGoals,
      };
    }),

  /**
   * Listar metas auto-geradas
   */
  listAutoGeneratedGoals: protectedProcedure
    .input(z.object({
      employeeId: z.number(),
      status: z.enum(["pendente", "aprovada", "rejeitada", "modificada"]).optional(),
    }))
    .query(async ({ input }) => {
      const db = await getDb();
      if (!db) return { goals: [] };

      const conditions = [eq(autoGeneratedGoals.employeeId, input.employeeId)];
      if (input.status) {
        conditions.push(eq(autoGeneratedGoals.status, input.status));
      }

      const goals = await db
        .select({
          goal: autoGeneratedGoals,
          gap: gapAnalysis,
          competency: competencies,
        })
        .from(autoGeneratedGoals)
        .leftJoin(gapAnalysis, eq(autoGeneratedGoals.gapAnalysisId, gapAnalysis.id))
        .leftJoin(competencies, eq(gapAnalysis.competencyId, competencies.id))
        .where(and(...conditions))
        .orderBy(desc(autoGeneratedGoals.generatedAt));

      return { goals };
    }),

  /**
   * Aprovar meta auto-gerada e criar PDI
   */
  approveGoal: protectedProcedure
    .input(z.object({
      goalId: z.number(),
      modifications: z.object({
        title: z.string().optional(),
        description: z.string().optional(),
        suggestedStartDate: z.date().optional(),
        suggestedEndDate: z.date().optional(),
      }).optional(),
    }))
    .mutation(async ({ input, ctx }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Database not available' });

      const { goalId, modifications } = input;

      // Buscar meta
      const goals = await db
        .select()
        .from(autoGeneratedGoals)
        .where(eq(autoGeneratedGoals.id, goalId))
        .limit(1);

      if (goals.length === 0) {
        throw new TRPCError({ code: 'NOT_FOUND', message: 'Meta não encontrada' });
      }

      const goal = goals[0];

      // Aplicar modificações se houver
      const updateData: any = {
        status: modifications ? "modificada" : "aprovada",
        approvedBy: ctx.user.id,
        approvedAt: new Date(),
      };

      if (modifications) {
        if (modifications.title) updateData.title = modifications.title;
        if (modifications.description) updateData.description = modifications.description;
        if (modifications.suggestedStartDate) updateData.suggestedStartDate = modifications.suggestedStartDate;
        if (modifications.suggestedEndDate) updateData.suggestedEndDate = modifications.suggestedEndDate;
      }

      await db
        .update(autoGeneratedGoals)
        .set(updateData)
        .where(eq(autoGeneratedGoals.id, goalId));

      // Criar PDI baseado na meta aprovada
      const pdiResult = await db.insert(pdiPlans).values({
        employeeId: goal.employeeId,
        status: "ativo",
        startDate: goal.suggestedStartDate,
        endDate: goal.suggestedEndDate,
        objectives: goal.description || '',
        createdBy: ctx.user.id,
      });

      const pdiPlanId = pdiResult[0].insertId;

      // Atualizar meta com PDI vinculado
      await db
        .update(autoGeneratedGoals)
        .set({ pdiPlanId })
        .where(eq(autoGeneratedGoals.id, goalId));

      return {
        success: true,
        pdiPlanId,
        message: 'Meta aprovada e PDI criado com sucesso',
      };
    }),

  /**
   * Rejeitar meta auto-gerada
   */
  rejectGoal: protectedProcedure
    .input(z.object({
      goalId: z.number(),
      reason: z.string(),
    }))
    .mutation(async ({ input, ctx }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Database not available' });

      await db
        .update(autoGeneratedGoals)
        .set({
          status: "rejeitada",
          approvedBy: ctx.user.id,
          approvedAt: new Date(),
          rejectionReason: input.reason,
        })
        .where(eq(autoGeneratedGoals.id, input.goalId));

      return {
        success: true,
        message: 'Meta rejeitada',
      };
    }),

  /**
   * Histórico de geração de metas
   */
  getGenerationHistory: protectedProcedure
    .input(z.object({
      employeeId: z.number(),
      limit: z.number().default(10),
    }))
    .query(async ({ input }) => {
      const db = await getDb();
      if (!db) return { history: [] };

      const history = await db
        .select()
        .from(goalGenerationHistory)
        .where(eq(goalGenerationHistory.employeeId, input.employeeId))
        .orderBy(desc(goalGenerationHistory.generatedAt))
        .limit(input.limit);

      return { history };
    }),
});
