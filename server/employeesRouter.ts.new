import { z } from "zod";
import { router, protectedProcedure, adminProcedure } from "./_core/trpc";
import { getDb, upsertEmployee, deactivateEmployee, reactivateEmployee, getEmployeeFullProfile } from "./db";
import { employees, departments, positions } from "../drizzle/schema";
import { eq, like, and, or, desc, sql } from "drizzle-orm";
import { storagePut } from "./storage";
import { TRPCError } from "@trpc/server";

/**
 * Router para gestão completa de funcionários
 * Inclui CRUD, upload de arquivos, busca avançada e relatórios
 */
export const employeesRouter = router({
  /**
   * Listar todos os funcionários com filtros e paginação
   */
  list: protectedProcedure
    .input(
      z.object({
        page: z.number().min(1).default(1),
        pageSize: z.number().min(1).max(100).default(20),
        search: z.string().optional(),
        departmentId: z.number().optional(),
        positionId: z.number().optional(),
        status: z.enum(["ativo", "afastado", "desligado"]).optional(),
        active: z.boolean().optional(),
      })
    )
    .query(async ({ input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });

      const { page, pageSize, search, departmentId, positionId, status, active } = input;
      const offset = (page - 1) * pageSize;

      // Construir condições de filtro
      const conditions = [];
      
      if (search) {
        conditions.push(
          or(
            like(employees.name, `%${search}%`),
            like(employees.email, `%${search}%`),
            like(employees.employeeCode, `%${search}%`),
            like(employees.cpf, `%${search}%`)
          )
        );
      }
      
      if (departmentId) {
        conditions.push(eq(employees.departmentId, departmentId));
      }
      
      if (positionId) {
        conditions.push(eq(employees.positionId, positionId));
      }
      
      if (status) {
        conditions.push(eq(employees.status, status));
      }
      
      if (active !== undefined) {
        conditions.push(eq(employees.active, active));
      }

      // Buscar funcionários com joins
      const results = await db
        .select({
          employee: employees,
          department: departments,
          position: positions,
        })
        .from(employees)
        .leftJoin(departments, eq(employees.departmentId, departments.id))
        .leftJoin(positions, eq(employees.positionId, positions.id))
        .where(conditions.length > 0 ? and(...conditions) : undefined)
        .orderBy(desc(employees.createdAt))
        .limit(pageSize)
        .offset(offset);

      // Contar total de registros
      const countResult = await db
        .select({ count: sql<number>`count(*)` })
        .from(employees)
        .where(conditions.length > 0 ? and(...conditions) : undefined);

      const total = Number(countResult[0]?.count || 0);

      return {
        data: results.map((r) => ({
          ...r.employee,
          department: r.department,
          position: r.position,
        })),
        pagination: {
          page,
          pageSize,
          total,
          totalPages: Math.ceil(total / pageSize),
        },
      };
    }),

  /**
   * Buscar funcionário por ID com informações completas
   */
  getById: protectedProcedure
    .input(z.object({ id: z.number() }))
    .query(async ({ input }) => {
      const profile = await getEmployeeFullProfile(input.id);
      if (!profile) {
        throw new TRPCError({ code: "NOT_FOUND", message: "Funcionário não encontrado" });
      }
      return profile;
    }),

  /**
   * Criar novo funcionário
   */
  create: adminProcedure
    .input(
      z.object({
        employeeCode: z.string().min(1),
        name: z.string().min(1),
        email: z.string().email().optional(),
        personalEmail: z.string().email().optional(),
        corporateEmail: z.string().email().optional(),
        cpf: z.string().optional(),
        birthDate: z.string().optional(),
        hireDate: z.string().optional(),
        departmentId: z.number().optional(),
        positionId: z.number().optional(),
        managerId: z.number().optional(),
        
        // Contato
        phone: z.string().optional(),
        mobilePhone: z.string().optional(),
        emergencyContact: z.string().optional(),
        emergencyPhone: z.string().optional(),
        
        // Endereço
        addressStreet: z.string().optional(),
        addressNumber: z.string().optional(),
        addressComplement: z.string().optional(),
        addressNeighborhood: z.string().optional(),
        addressCity: z.string().optional(),
        addressState: z.string().optional(),
        addressZipCode: z.string().optional(),
        
        // Documentos
        rg: z.string().optional(),
        rgIssuer: z.string().optional(),
        rgIssueDate: z.string().optional(),
        ctps: z.string().optional(),
        ctpsSeries: z.string().optional(),
        ctpsState: z.string().optional(),
        pis: z.string().optional(),
        
        // Pessoal
        maritalStatus: z.enum(["solteiro", "casado", "divorciado", "viuvo", "uniao_estavel"]).optional(),
        gender: z.enum(["masculino", "feminino", "outro", "nao_informar"]).optional(),
        
        // Educação
        educationLevel: z.enum([
          "fundamental_incompleto",
          "fundamental_completo",
          "medio_incompleto",
          "medio_completo",
          "superior_incompleto",
          "superior_completo",
          "pos_graduacao",
          "mestrado",
          "doutorado"
        ]).optional(),
        educationInstitution: z.string().optional(),
        educationCourse: z.string().optional(),
        educationCompletionYear: z.number().optional(),
        
        // Contrato
        contractType: z.enum(["clt", "pj", "estagio", "temporario", "terceirizado"]).optional(),
        workSchedule: z.string().optional(),
        weeklyHours: z.number().optional(),
        salary: z.number().optional(),
        
        // Banco
        bankName: z.string().optional(),
        bankCode: z.string().optional(),
        bankBranch: z.string().optional(),
        bankAccount: z.string().optional(),
        bankAccountType: z.enum(["corrente", "poupanca", "salario"]).optional(),
        pixKey: z.string().optional(),
        
        // Benefícios
        hasHealthInsurance: z.boolean().optional(),
        hasDentalInsurance: z.boolean().optional(),
        hasLifeInsurance: z.boolean().optional(),
        hasMealVoucher: z.boolean().optional(),
        hasTransportVoucher: z.boolean().optional(),
        hasGymMembership: z.boolean().optional(),
        benefitsNotes: z.string().optional(),
        
        // Notas
        notes: z.string().optional(),
        internalNotes: z.string().optional(),
      })
    )
    .mutation(async ({ input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });

      // Verificar se código já existe
      const existing = await db
        .select()
        .from(employees)
        .where(eq(employees.employeeCode, input.employeeCode))
        .limit(1);

      if (existing.length > 0) {
        throw new TRPCError({ code: "CONFLICT", message: "Código de funcionário já existe" });
      }

      // Converter datas
      const processedData: any = { ...input };
      if (input.birthDate) processedData.birthDate = new Date(input.birthDate);
      if (input.hireDate) processedData.hireDate = new Date(input.hireDate);
      if (input.rgIssueDate) processedData.rgIssueDate = new Date(input.rgIssueDate);

      // Inserir funcionário
      const result = await db.insert(employees).values(processedData);

      return { id: Number(result.insertId), success: true };
    }),

  /**
   * Atualizar funcionário existente
   */
  update: adminProcedure
    .input(
      z.object({
        id: z.number(),
        data: z.object({
          name: z.string().optional(),
          email: z.string().email().optional(),
          personalEmail: z.string().email().optional(),
          corporateEmail: z.string().email().optional(),
          cpf: z.string().optional(),
          birthDate: z.string().optional(),
          hireDate: z.string().optional(),
          departmentId: z.number().optional(),
          positionId: z.number().optional(),
          managerId: z.number().optional(),
          
          // Contato
          phone: z.string().optional(),
          mobilePhone: z.string().optional(),
          emergencyContact: z.string().optional(),
          emergencyPhone: z.string().optional(),
          
          // Endereço
          addressStreet: z.string().optional(),
          addressNumber: z.string().optional(),
          addressComplement: z.string().optional(),
          addressNeighborhood: z.string().optional(),
          addressCity: z.string().optional(),
          addressState: z.string().optional(),
          addressZipCode: z.string().optional(),
          
          // Documentos
          rg: z.string().optional(),
          rgIssuer: z.string().optional(),
          rgIssueDate: z.string().optional(),
          ctps: z.string().optional(),
          ctpsSeries: z.string().optional(),
          ctpsState: z.string().optional(),
          pis: z.string().optional(),
          
          // Pessoal
          maritalStatus: z.enum(["solteiro", "casado", "divorciado", "viuvo", "uniao_estavel"]).optional(),
          gender: z.enum(["masculino", "feminino", "outro", "nao_informar"]).optional(),
          
          // Educação
          educationLevel: z.enum([
            "fundamental_incompleto",
            "fundamental_completo",
            "medio_incompleto",
            "medio_completo",
            "superior_incompleto",
            "superior_completo",
            "pos_graduacao",
            "mestrado",
            "doutorado"
          ]).optional(),
          educationInstitution: z.string().optional(),
          educationCourse: z.string().optional(),
          educationCompletionYear: z.number().optional(),
          
          // Contrato
          contractType: z.enum(["clt", "pj", "estagio", "temporario", "terceirizado"]).optional(),
          workSchedule: z.string().optional(),
          weeklyHours: z.number().optional(),
          salary: z.number().optional(),
          terminationDate: z.string().optional(),
          terminationReason: z.string().optional(),
          
          // Banco
          bankName: z.string().optional(),
          bankCode: z.string().optional(),
          bankBranch: z.string().optional(),
          bankAccount: z.string().optional(),
          bankAccountType: z.enum(["corrente", "poupanca", "salario"]).optional(),
          pixKey: z.string().optional(),
          
          // Benefícios
          hasHealthInsurance: z.boolean().optional(),
          hasDentalInsurance: z.boolean().optional(),
          hasLifeInsurance: z.boolean().optional(),
          hasMealVoucher: z.boolean().optional(),
          hasTransportVoucher: z.boolean().optional(),
          hasGymMembership: z.boolean().optional(),
          benefitsNotes: z.string().optional(),
          
          // Notas
          notes: z.string().optional(),
          internalNotes: z.string().optional(),
          
          // Status
          status: z.enum(["ativo", "afastado", "desligado"]).optional(),
          active: z.boolean().optional(),
        }),
      })
    )
    .mutation(async ({ input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });

      // Verificar se funcionário existe
      const existing = await db
        .select()
        .from(employees)
        .where(eq(employees.id, input.id))
        .limit(1);

      if (existing.length === 0) {
        throw new TRPCError({ code: "NOT_FOUND", message: "Funcionário não encontrado" });
      }

      // Converter datas
      const processedData: any = { ...input.data };
      if (input.data.birthDate) processedData.birthDate = new Date(input.data.birthDate);
      if (input.data.hireDate) processedData.hireDate = new Date(input.data.hireDate);
      if (input.data.rgIssueDate) processedData.rgIssueDate = new Date(input.data.rgIssueDate);
      if (input.data.terminationDate) processedData.terminationDate = new Date(input.data.terminationDate);

      processedData.updatedAt = new Date();

      // Atualizar funcionário
      await db.update(employees).set(processedData).where(eq(employees.id, input.id));

      return { success: true };
    }),

  /**
   * Upload de foto de perfil
   */
  uploadPhoto: adminProcedure
    .input(
      z.object({
        employeeId: z.number(),
        fileData: z.string(), // Base64
        fileName: z.string(),
        mimeType: z.string(),
      })
    )
    .mutation(async ({ input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });

      // Converter base64 para buffer
      const buffer = Buffer.from(input.fileData, "base64");

      // Upload para S3
      const fileKey = `employees/${input.employeeId}/photo/${Date.now()}-${input.fileName}`;
      const { url } = await storagePut(fileKey, buffer, input.mimeType);

      // Atualizar URL da foto no banco
      await db
        .update(employees)
        .set({ photoUrl: url, updatedAt: new Date() })
        .where(eq(employees.id, input.employeeId));

      return { url, success: true };
    }),

  /**
   * Upload de documento
   */
  uploadDocument: adminProcedure
    .input(
      z.object({
        employeeId: z.number(),
        documentType: z.enum(["rg", "cpf", "ctps", "proof_of_address", "diploma", "other"]),
        fileData: z.string(), // Base64
        fileName: z.string(),
        mimeType: z.string(),
      })
    )
    .mutation(async ({ input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });

      // Converter base64 para buffer
      const buffer = Buffer.from(input.fileData, "base64");

      // Upload para S3
      const fileKey = `employees/${input.employeeId}/documents/${input.documentType}/${Date.now()}-${input.fileName}`;
      const { url } = await storagePut(fileKey, buffer, input.mimeType);

      // Atualizar URL do documento no banco
      const updateData: any = { updatedAt: new Date() };
      
      switch (input.documentType) {
        case "rg":
          updateData.documentRgUrl = url;
          break;
        case "cpf":
          updateData.documentCpfUrl = url;
          break;
        case "ctps":
          updateData.documentCtpsUrl = url;
          break;
        case "proof_of_address":
          updateData.documentProofOfAddressUrl = url;
          break;
        case "diploma":
          updateData.documentDiplomaUrl = url;
          break;
        case "other":
          // Para outros documentos, adicionar ao array JSON
          const employee = await db
            .select({ documentOthersUrl: employees.documentOthersUrl })
            .from(employees)
            .where(eq(employees.id, input.employeeId))
            .limit(1);
          
          const others = employee[0]?.documentOthersUrl 
            ? JSON.parse(employee[0].documentOthersUrl as string) 
            : [];
          others.push({ url, fileName: input.fileName, uploadedAt: new Date().toISOString() });
          updateData.documentOthersUrl = JSON.stringify(others);
          break;
      }

      await db.update(employees).set(updateData).where(eq(employees.id, input.employeeId));

      return { url, success: true };
    }),

  /**
   * Desativar funcionário
   */
  deactivate: adminProcedure
    .input(z.object({ id: z.number(), reason: z.string().optional() }))
    .mutation(async ({ input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });

      await db
        .update(employees)
        .set({
          active: false,
          status: "desligado",
          terminationDate: new Date(),
          terminationReason: input.reason,
          updatedAt: new Date(),
        })
        .where(eq(employees.id, input.id));

      return { success: true };
    }),

  /**
   * Reativar funcionário
   */
  reactivate: adminProcedure
    .input(z.object({ id: z.number() }))
    .mutation(async ({ input }) => {
      await reactivateEmployee(input.id);
      return { success: true };
    }),

  /**
   * Estatísticas gerais de funcionários
   */
  stats: protectedProcedure.query(async () => {
    const db = await getDb();
    if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });

    const [totalActive, totalInactive, byDepartment, byPosition] = await Promise.all([
      db
        .select({ count: sql<number>`count(*)` })
        .from(employees)
        .where(and(eq(employees.active, true), eq(employees.status, "ativo"))),
      
      db
        .select({ count: sql<number>`count(*)` })
        .from(employees)
        .where(or(eq(employees.active, false), eq(employees.status, "desligado"))),
      
      db
        .select({
          departmentId: employees.departmentId,
          departmentName: departments.name,
          count: sql<number>`count(*)`,
        })
        .from(employees)
        .leftJoin(departments, eq(employees.departmentId, departments.id))
        .where(eq(employees.active, true))
        .groupBy(employees.departmentId, departments.name),
      
      db
        .select({
          positionId: employees.positionId,
          positionTitle: positions.title,
          count: sql<number>`count(*)`,
        })
        .from(employees)
        .leftJoin(positions, eq(employees.positionId, positions.id))
        .where(eq(employees.active, true))
        .groupBy(employees.positionId, positions.title),
    ]);

    return {
      totalActive: Number(totalActive[0]?.count || 0),
      totalInactive: Number(totalInactive[0]?.count || 0),
      byDepartment: byDepartment.map((d) => ({
        departmentId: d.departmentId,
        departmentName: d.departmentName || "Sem departamento",
        count: Number(d.count),
      })),
      byPosition: byPosition.map((p) => ({
        positionId: p.positionId,
        positionTitle: p.positionTitle || "Sem cargo",
        count: Number(p.count),
      })),
    };
  }),
});
