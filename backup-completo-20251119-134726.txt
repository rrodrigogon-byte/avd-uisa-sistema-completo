==================================================================
BACKUP COMPLETO - SISTEMA AVD UISA
Data: 19/11/2025 13:47:26
==================================================================

## ESTRUTURA DO PROJETO

.
├── ANALISE_SISTEMA_100.md
├── CONFIGURACAO.md
├── backup-completo-20251119-134726.txt
├── backup-generator.sh
├── check-cycle.mjs
├── check-smtp.mjs
├── client
│   ├── index.html
│   ├── public
│   │   ├── models
│   │   └── uisa-all-succession-plans.json
│   └── src
│       ├── App.tsx
│       ├── _core
│       ├── components
│       ├── const.ts
│       ├── contexts
│       ├── hooks
│       ├── index.css
│       ├── lib
│       ├── main.tsx
│       ├── pages
│       └── utils
├── components.json
├── create-cycle.mjs
├── drizzle
│   ├── 0000_redundant_rocket_racer.sql
│   ├── 0001_silly_leech.sql
│   ├── 0002_massive_mad_thinker.sql
│   ├── 0003_bumpy_morbius.sql
│   ├── 0004_zippy_gideon.sql
│   ├── 0005_striped_sheva_callister.sql
│   ├── 0006_bitter_secret_warriors.sql
│   ├── 0007_blushing_amphibian.sql
│   ├── 0008_glorious_brother_voodoo.sql
│   ├── 0009_curly_scrambler.sql
│   ├── 0010_fantastic_patriot.sql
│   ├── 0011_pink_tony_stark.sql
│   ├── 0012_gray_juggernaut.sql
│   ├── 0013_nasty_tyger_tiger.sql
│   ├── 0014_gray_madelyne_pryor.sql
│   ├── 0015_mysterious_nomad.sql
│   ├── 0016_silky_maelstrom.sql
│   ├── 0017_steady_black_knight.sql
│   ├── 0018_ambitious_gabe_jones.sql
│   ├── 0019_freezing_prowler.sql
│   ├── 0020_special_dreadnoughts.sql
│   ├── 0021_broken_gargoyle.sql
│   ├── 0022_perpetual_demogoblin.sql
│   ├── 0023_free_khan.sql
│   ├── 0024_orange_joshua_kane.sql
│   ├── 0025_known_rachel_grey.sql
│   ├── 0026_parallel_dragon_lord.sql
│   ├── 0027_outgoing_the_fallen.sql
│   ├── meta
│   │   ├── 0000_snapshot.json
│   │   ├── 0001_snapshot.json
│   │   ├── 0002_snapshot.json
│   │   ├── 0003_snapshot.json
│   │   ├── 0004_snapshot.json
│   │   ├── 0005_snapshot.json
│   │   ├── 0006_snapshot.json
│   │   ├── 0007_snapshot.json
│   │   ├── 0008_snapshot.json
│   │   ├── 0009_snapshot.json
│   │   ├── 0010_snapshot.json
│   │   ├── 0011_snapshot.json
│   │   ├── 0012_snapshot.json
│   │   ├── 0013_snapshot.json
│   │   ├── 0014_snapshot.json
│   │   ├── 0015_snapshot.json
│   │   ├── 0016_snapshot.json
│   │   ├── 0017_snapshot.json
│   │   ├── 0018_snapshot.json
│   │   ├── 0019_snapshot.json
│   │   ├── 0020_snapshot.json
│   │   ├── 0021_snapshot.json
│   │   ├── 0022_snapshot.json
│   │   ├── 0023_snapshot.json
│   │   ├── 0024_snapshot.json
│   │   ├── 0025_snapshot.json
│   │   ├── 0026_snapshot.json
│   │   ├── 0027_snapshot.json
│   │   └── _journal.json
│   ├── migrations
│   ├── relations.ts
│   └── schema.ts
├── drizzle.config.ts
├── examples
│   └── email-service-example.ts
├── import-uisa-final.mjs
├── insert-cycle.mjs
├── package.json
├── patches
│   └── wouter@3.7.1.patch
├── pnpm-lock.yaml
├── process-uisa-data.mjs
├── scripts
│   ├── activate-cycle.mjs
│   ├── customize-tests.py
│   ├── download-face-models.sh
│   ├── import-data.py
│   ├── import-from-excel.ts
│   ├── import-real-data.ts
│   ├── import-to-db.ts
│   ├── imported_employees.json
│   ├── imported_sections.json
│   ├── populate-9box.mjs
│   ├── quick-seed.sql
│   ├── seed-360-questions.ts
│   ├── seed-badges.ts
│   ├── seed-benchmarking.mjs
│   ├── seed-bigfive.ts
│   ├── seed-careeranchors.mjs
│   ├── seed-competencias-cargos.sql
│   ├── seed-competencias.sql
│   ├── seed-demo-data.mjs
│   ├── seed-ie.ts
│   ├── seed-leadership.mjs
│   ├── seed-mbti.ts
│   ├── seed-niveis-competencias.sql
│   ├── seed-perguntas-avaliacao.sql
│   ├── seed-psychometric-tests.sql
│   ├── seed-sucessao-9box.sql
│   ├── seed-tests.mjs
│   ├── seed-vark.ts
│   ├── seed.ts
│   ├── seed_demo.py
│   ├── send-test-invites.ts
│   └── send-tests-rodrigo.ts
├── seed-all-tests.mjs
├── seed-demo-data.mjs
├── seed-disc-questions.mjs
├── seed-uisa-complete.mjs
├── seed-uisa-data-v2.mjs
├── seed-uisa-data.mjs
├── seed-uisa-final.mjs
├── seed.mjs
├── server
│   ├── __tests__
│   │   ├── badgeEmailIntegration.test.ts
│   │   ├── badges.test.ts
│   │   ├── dashboardGestor.test.ts
│   │   ├── notifications.test.ts
│   │   └── scheduledReports.test.ts
│   ├── _core
│   │   ├── context.ts
│   │   ├── cookies.ts
│   │   ├── dataApi.ts
│   │   ├── env.ts
│   │   ├── imageGeneration.ts
│   │   ├── index.ts
│   │   ├── llm.ts
│   │   ├── map.ts
│   │   ├── notification.ts
│   │   ├── oauth.ts
│   │   ├── sdk.ts
│   │   ├── systemRouter.ts
│   │   ├── trpc.ts
│   │   ├── types
│   │   ├── vite.ts
│   │   └── voiceTranscription.ts
│   ├── analyticsRouter.ts
│   ├── analyticsRouter.ts.bak
│   ├── badgesRouter.ts
│   ├── bonusRouter.ts
│   ├── calibrationRouter.ts
│   ├── cron.ts
│   ├── db.ts
│   ├── email-service-v2.ts
│   ├── emailService.ts
│   ├── emailTemplates.ts
│   ├── evaluation360Router.ts
│   ├── executiveRouter.ts
│   ├── feedbackRouter.ts
│   ├── gamificationRouter.ts
│   ├── goalsRouter.ts
│   ├── integrationsRouter.ts
│   ├── jobs
│   │   └── notificationCron.ts
│   ├── nineBoxRouter.ts
│   ├── pdiIntelligentRouter.ts
│   ├── reportAnalyticsRouter.ts
│   ├── reportBuilderRouter.ts
│   ├── reportGenerators
│   │   ├── nineBoxPDF.ts
│   │   ├── pdiPDF.ts
│   │   └── performanceExcel.ts
│   ├── routers.ts
│   ├── scheduledReportsRouter.ts
│   ├── services
│   │   └── badgeService.ts
│   ├── storage.ts
│   ├── successionRouter.ts
│   ├── utils
│   │   ├── badgeHelper.ts
│   │   ├── bonusApprovalPDF.ts
│   │   ├── bonusEmailNotifications.ts
│   │   ├── bonusExcel.ts
│   │   ├── calibrationPDF.ts
│   │   ├── consolidatedPerformancePDF.ts
│   │   ├── emailService.ts
│   │   ├── externalIntegrations.ts
│   │   ├── goalsPDF.ts
│   │   ├── notifications.ts
│   │   ├── pdiRecommendations.ts
│   │   ├── permissions.ts
│   │   ├── testInviteTemplate.ts
│   │   └── totvsIntegration.ts
│   └── websocket.ts
├── shared
│   ├── _core
│   │   └── errors.ts
│   ├── const.ts
│   └── types.ts
├── succession-data-uisa.json
├── test-email-send.mjs
├── test-email.mjs
├── todo-new.md
├── todo.md
├── tsconfig.json
├── uisa-all-succession-plans.json
├── uisa-succession-plans.json
├── vite.config.ts
├── vite.config.ts.bak
└── vitest.config.ts

27 directories, 199 files

==================================================================
## SCHEMA DO BANCO DE DADOS
==================================================================

import { relations } from "drizzle-orm";
import {
  boolean,
  date,
  datetime,
  decimal,
  int,
  json,
  mysqlEnum,
  mysqlTable,
  text,
  timestamp,
  varchar,
} from "drizzle-orm/mysql-core";

/**
 * Sistema AVD UISA - Schema Completo
 * Sistema de Avaliação de Desempenho e Gestão de Talentos
 */

// ============================================================================
// TABELAS DE AUTENTICAÇÃO E USUÁRIOS
// ============================================================================

export const users = mysqlTable("users", {
  id: int("id").autoincrement().primaryKey(),
  openId: varchar("openId", { length: 64 }).notNull().unique(),
  name: text("name"),
  email: varchar("email", { length: 320 }),
  loginMethod: varchar("loginMethod", { length: 64 }),
  role: mysqlEnum("role", ["admin", "rh", "gestor", "colaborador"]).default("colaborador").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  lastSignedIn: timestamp("lastSignedIn").defaultNow().notNull(),
  // Reconhecimento facial
  faceDescriptor: text("faceDescriptor"), // JSON com descritores faciais
  facePhotoUrl: varchar("facePhotoUrl", { length: 512 }),
  faceRegisteredAt: datetime("faceRegisteredAt"),
});

export type User = typeof users.$inferSelect;
export type InsertUser = typeof users.$inferInsert;

export const passwordResetTokens = mysqlTable("passwordResetTokens", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull(),
  token: varchar("token", { length: 255 }).notNull().unique(),
  expiresAt: datetime("expiresAt").notNull(),
  used: boolean("used").default(false).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type PasswordResetToken = typeof passwordResetTokens.$inferSelect;
export type InsertPasswordResetToken = typeof passwordResetTokens.$inferInsert;

// ============================================================================
// TABELAS DE ESTRUTURA ORGANIZACIONAL
// ============================================================================

export const departments = mysqlTable("departments", {
  id: int("id").autoincrement().primaryKey(),
  code: varchar("code", { length: 50 }).notNull().unique(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  parentId: int("parentId"), // Departamento pai (hierarquia)
  managerId: int("managerId"), // Gestor do departamento
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Department = typeof departments.$inferSelect;
export type InsertDepartment = typeof departments.$inferInsert;

export const positions = mysqlTable("positions", {
  id: int("id").autoincrement().primaryKey(),
  code: varchar("code", { length: 50 }).notNull().unique(),
  title: varchar("title", { length: 255 }).notNull(),
  description: text("description"),
  level: mysqlEnum("level", ["junior", "pleno", "senior", "especialista", "coordenador", "gerente", "diretor"]),
  departmentId: int("departmentId"),
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Position = typeof positions.$inferSelect;
export type InsertPosition = typeof positions.$inferInsert;

export const employees = mysqlTable("employees", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").unique(), // Vinculação com usuário do sistema
  employeeCode: varchar("employeeCode", { length: 50 }).notNull().unique(),
  name: varchar("name", { length: 255 }).notNull(),
  email: varchar("email", { length: 320 }).notNull(),
  cpf: varchar("cpf", { length: 14 }).unique(),
  birthDate: datetime("birthDate"),
  hireDate: datetime("hireDate").notNull(),
  departmentId: int("departmentId").notNull(),
  positionId: int("positionId").notNull(),
  managerId: int("managerId"), // Gestor direto
  costCenter: varchar("costCenter", { length: 100 }), // Centro de custos
  
  // Informações financeiras e hierárquicas
  salary: int("salary"), // Salário em centavos (ex: 500000 = R$ 5.000,00)
  hierarchyLevel: mysqlEnum("hierarchyLevel", [
    "diretoria",
    "gerencia",
    "coordenacao",
    "supervisao",
    "operacional"
  ]),
  
  photoUrl: varchar("photoUrl", { length: 512 }),
  phone: varchar("phone", { length: 20 }),
  address: text("address"),
  status: mysqlEnum("status", ["ativo", "afastado", "desligado"]).default("ativo").notNull(),
  // Integração TOTVS RM
  rmCode: varchar("rmCode", { length: 50 }),
  rmLastSync: datetime("rmLastSync"),
  // Gamificação
  gamificationPoints: int("gamificationPoints").default(0).notNull(),
  gamificationLevel: varchar("gamificationLevel", { length: 20 }).default("Bronze").notNull(),
  lastPointsUpdate: timestamp("lastPointsUpdate").defaultNow(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Employee = typeof employees.$inferSelect;
export type InsertEmployee = typeof employees.$inferInsert;

// ============================================================================
// TABELAS DE COMPETÊNCIAS
// ============================================================================

export const competencies = mysqlTable("competencies", {
  id: int("id").autoincrement().primaryKey(),
  code: varchar("code", { length: 50 }).notNull().unique(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  category: mysqlEnum("category", ["tecnica", "comportamental", "lideranca"]).notNull(),
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Competency = typeof competencies.$inferSelect;
export type InsertCompetency = typeof competencies.$inferInsert;

export const competencyLevels = mysqlTable("competencyLevels", {
  id: int("id").autoincrement().primaryKey(),
  competencyId: int("competencyId").notNull(),
  level: int("level").notNull(), // 1 a 5
  name: varchar("name", { length: 100 }).notNull(),
  description: text("description"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type CompetencyLevel = typeof competencyLevels.$inferSelect;
export type InsertCompetencyLevel = typeof competencyLevels.$inferInsert;

export const positionCompetencies = mysqlTable("positionCompetencies", {
  id: int("id").autoincrement().primaryKey(),
  positionId: int("positionId").notNull(),
  competencyId: int("competencyId").notNull(),
  requiredLevel: int("requiredLevel").notNull(), // Nível exigido (1-5)
  weight: int("weight").default(1).notNull(), // Peso da competência
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type PositionCompetency = typeof positionCompetencies.$inferSelect;
export type InsertPositionCompetency = typeof positionCompetencies.$inferInsert;

export const employeeCompetencies = mysqlTable("employeeCompetencies", {
  id: int("id").autoincrement().primaryKey(),
  employeeId: int("employeeId").notNull(),
  competencyId: int("competencyId").notNull(),
  currentLevel: int("currentLevel").notNull(), // Nível atual (1-5)
  evaluatedAt: datetime("evaluatedAt").notNull(),
  evaluatedBy: int("evaluatedBy"), // ID do avaliador
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type EmployeeCompetency = typeof employeeCompetencies.$inferSelect;
export type InsertEmployeeCompetency = typeof employeeCompetencies.$inferInsert;

// ============================================================================
// TABELAS DE CICLOS DE AVALIAÇÃO
// ============================================================================

export const evaluationCycles = mysqlTable("evaluationCycles", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  year: int("year").notNull(),
  type: mysqlEnum("type", ["anual", "semestral", "trimestral"]).notNull(),
  startDate: datetime("startDate").notNull(),
  endDate: datetime("endDate").notNull(),
  status: mysqlEnum("status", ["planejamento", "em_andamento", "concluido", "cancelado"]).default("planejamento").notNull(),
  description: text("description"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type EvaluationCycle = typeof evaluationCycles.$inferSelect;
export type InsertEvaluationCycle = typeof evaluationCycles.$inferInsert;

// ============================================================================
// TABELAS DE METAS
// ============================================================================

export const goals = mysqlTable("goals", {
  id: int("id").autoincrement().primaryKey(),
  cycleId: int("cycleId").notNull(),
  employeeId: int("employeeId").notNull(),
  title: varchar("title", { length: 255 }).notNull(),
  description: text("description"),
  type: mysqlEnum("type", ["individual", "equipe", "organizacional"]).notNull(),
  category: mysqlEnum("category", ["quantitativa", "qualitativa"]).notNull(),
  targetValue: varchar("targetValue", { length: 100 }),
  currentValue: varchar("currentValue", { length: 100 }),
  unit: varchar("unit", { length: 50 }), // unidade de medida
  weight: int("weight").default(1).notNull(), // Peso da meta
  startDate: datetime("startDate").notNull(),
  endDate: datetime("endDate").notNull(),
  status: mysqlEnum("status", ["rascunho", "pendente_aprovacao", "aprovada", "em_andamento", "concluida", "cancelada"]).default("rascunho").notNull(),
  progress: int("progress").default(0).notNull(), // Percentual 0-100
  linkedToPLR: boolean("linkedToPLR").default(false).notNull(),
  linkedToBonus: boolean("linkedToBonus").default(false).notNull(),
  createdBy: int("createdBy").notNull(),
  approvedBy: int("approvedBy"),
  approvedAt: datetime("approvedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Goal = typeof goals.$inferSelect;
export type InsertGoal = typeof goals.$inferInsert;

export const goalUpdates = mysqlTable("goalUpdates", {
  id: int("id").autoincrement().primaryKey(),
  goalId: int("goalId").notNull(),
  progress: int("progress").notNull(),
  currentValue: varchar("currentValue", { length: 100 }),
  notes: text("notes"),
  updatedBy: int("updatedBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type GoalUpdate = typeof goalUpdates.$inferSelect;
export type InsertGoalUpdate = typeof goalUpdates.$inferInsert;

// ============================================================================
// TABELAS DE AVALIAÇÃO 360°
// ============================================================================

export const performanceEvaluations = mysqlTable("performanceEvaluations", {
  id: int("id").autoincrement().primaryKey(),
  cycleId: int("cycleId").notNull(),
  employeeId: int("employeeId").notNull(),
  type: mysqlEnum("type", ["360", "180", "90"]).notNull(),
  status: mysqlEnum("status", ["pendente", "em_andamento", "concluida"]).default("pendente").notNull(),
  
  // Workflow de etapas sequenciais
  workflowStatus: mysqlEnum("workflowStatus", [
    "pending_self",        // Aguardando autoavaliação
    "pending_manager",     // Aguardando avaliação do gestor
    "pending_consensus",   // Aguardando consenso do líder
    "completed"            // Concluído
  ]).default("pending_self").notNull(),
  
  selfEvaluationCompleted: boolean("selfEvaluationCompleted").default(false).notNull(),
  managerEvaluationCompleted: boolean("managerEvaluationCompleted").default(false).notNull(),
  peersEvaluationCompleted: boolean("peersEvaluationCompleted").default(false).notNull(),
  subordinatesEvaluationCompleted: boolean("subordinatesEvaluationCompleted").default(false).notNull(),
  
  // Datas de conclusão de cada etapa
  selfCompletedAt: datetime("selfCompletedAt"),
  managerCompletedAt: datetime("managerCompletedAt"),
  consensusCompletedAt: datetime("consensusCompletedAt"),
  
  finalScore: int("finalScore"), // Nota final (0-100)
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  completedAt: datetime("completedAt"),
});

export type PerformanceEvaluation = typeof performanceEvaluations.$inferSelect;
export type InsertPerformanceEvaluation = typeof performanceEvaluations.$inferInsert;

export const evaluationQuestions = mysqlTable("evaluationQuestions", {
  id: int("id").autoincrement().primaryKey(),
  code: varchar("code", { length: 50 }).notNull().unique(),
  question: text("question").notNull(),
  category: varchar("category", { length: 100 }),
  type: mysqlEnum("type", ["escala", "texto", "multipla_escolha"]).notNull(),
  options: text("options"), // JSON com opções para múltipla escolha
  weight: int("weight").default(1).notNull(),
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type EvaluationQuestion = typeof evaluationQuestions.$inferSelect;
export type InsertEvaluationQuestion = typeof evaluationQuestions.$inferInsert;

export const evaluationResponses = mysqlTable("evaluationResponses", {
  id: int("id").autoincrement().primaryKey(),
  evaluationId: int("evaluationId").notNull(),
  questionId: int("questionId").notNull(),
  evaluatorId: int("evaluatorId").notNull(),
  evaluatorType: mysqlEnum("evaluatorType", ["self", "manager", "peer", "subordinate"]).notNull(),
  score: int("score"), // Para questões de escala (1-5)
  textResponse: text("textResponse"), // Para questões abertas
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type EvaluationResponse = typeof evaluationResponses.$inferSelect;
export type InsertEvaluationResponse = typeof evaluationResponses.$inferInsert;

export const calibrationSessions = mysqlTable("calibrationSessions", {
  id: int("id").autoincrement().primaryKey(),
  cycleId: int("cycleId").notNull(),
  departmentId: int("departmentId"),
  facilitatorId: int("facilitatorId").notNull(), // Quem conduziu a sessão
  status: mysqlEnum("status", ["agendada", "em_andamento", "concluida"]).default("agendada").notNull(),
  scheduledDate: datetime("scheduledDate"),
  startedAt: datetime("startedAt"),
  completedAt: datetime("completedAt"),
  notes: text("notes"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type CalibrationSession = typeof calibrationSessions.$inferSelect;
export type InsertCalibrationSession = typeof calibrationSessions.$inferInsert;

export const calibrationReviews = mysqlTable("calibrationReviews", {
  id: int("id").autoincrement().primaryKey(),
  sessionId: int("sessionId").notNull(),
  evaluationId: int("evaluationId").notNull(),
  originalScore: int("originalScore").notNull(),
  calibratedScore: int("calibratedScore").notNull(),
  reason: text("reason").notNull(),
  reviewedBy: int("reviewedBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type CalibrationReview = typeof calibrationReviews.$inferSelect;
export type InsertCalibrationReview = typeof calibrationReviews.$inferInsert;

export const calibrationMessages = mysqlTable("calibrationMessages", {
  id: int("id").autoincrement().primaryKey(),
  sessionId: int("sessionId").notNull(),
  userId: int("userId").notNull(),
  message: text("message").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type CalibrationMessage = typeof calibrationMessages.$inferSelect;
export type InsertCalibrationMessage = typeof calibrationMessages.$inferInsert;

// ============================================================================
// TABELAS DE MATRIZ 9-BOX
// ============================================================================

export const nineBoxPositions = mysqlTable("nineBoxPositions", {
  id: int("id").autoincrement().primaryKey(),
  cycleId: int("cycleId").notNull(),
  employeeId: int("employeeId").notNull(),
  performance: int("performance").notNull(), // 1-3 (baixo, médio, alto)
  potential: int("potential").notNull(), // 1-3 (baixo, médio, alto)
  box: varchar("box", { length: 50 }).notNull(), // ex: "alto_desempenho_alto_potencial"
  calibrated: boolean("calibrated").default(false).notNull(),
  calibratedBy: int("calibratedBy"),
  calibratedAt: datetime("calibratedAt"),
  notes: text("notes"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type NineBoxPosition = typeof nineBoxPositions.$inferSelect;
export type InsertNineBoxPosition = typeof nineBoxPositions.$inferInsert;

// ============================================================================
// TABELAS DE PDI (Plano de Desenvolvimento Individual)
// ============================================================================

export const pdiPlans = mysqlTable("pdiPlans", {
  id: int("id").autoincrement().primaryKey(),
  cycleId: int("cycleId").notNull(),
  employeeId: int("employeeId").notNull(),
  targetPositionId: int("targetPositionId"), // Cargo almejado
  status: mysqlEnum("status", ["rascunho", "pendente_aprovacao", "aprovado", "em_andamento", "concluido", "cancelado"]).default("rascunho").notNull(),
  startDate: datetime("startDate").notNull(),
  endDate: datetime("endDate").notNull(),
  overallProgress: int("overallProgress").default(0).notNull(), // Percentual 0-100
  approvedBy: int("approvedBy"),
  approvedAt: datetime("approvedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  completedAt: datetime("completedAt"),
});

export type PdiPlan = typeof pdiPlans.$inferSelect;
export type InsertPdiPlan = typeof pdiPlans.$inferInsert;

export const developmentActions = mysqlTable("developmentActions", {
  id: int("id").autoincrement().primaryKey(),
  code: varchar("code", { length: 50 }).notNull().unique(),
  title: varchar("title", { length: 255 }).notNull(),
  description: text("description"),
  category: mysqlEnum("category", ["70_pratica", "20_mentoria", "10_curso"]).notNull(), // Modelo 70-20-10
  type: varchar("type", { length: 100 }), // ex: "projeto", "job_rotation", "curso_online"
  competencyId: int("competencyId"), // Competência desenvolvida
  duration: int("duration"), // Duração em horas
  provider: varchar("provider", { length: 255 }), // Fornecedor/plataforma
  url: varchar("url", { length: 512 }),
  cost: int("cost"), // Custo em centavos
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type DevelopmentAction = typeof developmentActions.$inferSelect;
export type InsertDevelopmentAction = typeof developmentActions.$inferInsert;

export const pdiItems = mysqlTable("pdiItems", {
  id: int("id").autoincrement().primaryKey(),
  planId: int("planId").notNull(),
  actionId: int("actionId"), // Ação do catálogo (opcional)
  competencyId: int("competencyId").notNull(),
  title: varchar("title", { length: 255 }).notNull(),
  description: text("description"),
  category: mysqlEnum("category", ["70_pratica", "20_mentoria", "10_curso"]).notNull(),
  type: varchar("type", { length: 100 }),
  startDate: datetime("startDate").notNull(),
  endDate: datetime("endDate").notNull(),
  status: mysqlEnum("status", ["pendente", "em_andamento", "concluida", "cancelada"]).default("pendente").notNull(),
  progress: int("progress").default(0).notNull(), // Percentual 0-100
  notes: text("notes"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  completedAt: datetime("completedAt"),
});

export type PdiItem = typeof pdiItems.$inferSelect;
export type InsertPdiItem = typeof pdiItems.$inferInsert;

export const pdiProgress = mysqlTable("pdiProgress", {
  id: int("id").autoincrement().primaryKey(),
  itemId: int("itemId").notNull(),
  progress: int("progress").notNull(),
  notes: text("notes"),
  evidenceUrl: varchar("evidenceUrl", { length: 512 }), // URL de evidência (certificado, etc)
  updatedBy: int("updatedBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type PdiProgress = typeof pdiProgress.$inferSelect;
export type InsertPdiProgress = typeof pdiProgress.$inferInsert;

// ============================================================================
// TABELAS DE SUCESSÃO
// ============================================================================

export const successionPlans = mysqlTable("successionPlans", {
  id: int("id").autoincrement().primaryKey(),
  positionId: int("positionId").notNull(),
  currentHolderId: int("currentHolderId"), // Ocupante atual
  isCritical: boolean("isCritical").default(false).notNull(),
  riskLevel: mysqlEnum("riskLevel", ["baixo", "medio", "alto", "critico"]).default("medio").notNull(),
  status: mysqlEnum("status", ["ativo", "inativo"]).default("ativo").notNull(),
  
  // Riscos (Metodologia 9-Box Succession Planning)
  exitRisk: mysqlEnum("exitRisk", ["baixo", "medio", "alto"]).default("medio"),
  competencyGap: text("competencyGap"), // Gaps de competências identificados
  preparationTime: int("preparationTime"), // Tempo estimado de preparo em meses
  
  // Plano de Acompanhamento
  trackingPlan: text("trackingPlan"), // JSON com marcos e progress
  nextReviewDate: timestamp("nextReviewDate"),
  
  notes: text("notes"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type SuccessionPlan = typeof successionPlans.$inferSelect;
export type InsertSuccessionPlan = typeof successionPlans.$inferInsert;

export const successionCandidates = mysqlTable("successionCandidates", {
  id: int("id").autoincrement().primaryKey(),
  planId: int("planId").notNull(),
  employeeId: int("employeeId").notNull(),
  readinessLevel: mysqlEnum("readinessLevel", ["imediato", "1_ano", "2_3_anos", "mais_3_anos"]).notNull(),
  priority: int("priority").default(1).notNull(), // Ordem de prioridade
  developmentPlanId: int("developmentPlanId"), // PDI associado
  notes: text("notes"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type SuccessionCandidate = typeof successionCandidates.$inferSelect;
export type InsertSuccessionCandidate = typeof successionCandidates.$inferInsert;

// ============================================================================
// TABELAS DE NOTIFICAÇÕES E E-MAIL
// ============================================================================

export const emailMetrics = mysqlTable("emailMetrics", {
  id: int("id").autoincrement().primaryKey(),
  type: varchar("type", { length: 100 }).notNull(), // Tipo de e-mail
  toEmail: varchar("toEmail", { length: 320 }).notNull(),
  subject: varchar("subject", { length: 255 }),
  success: boolean("success").notNull(),
  deliveryTime: int("deliveryTime"), // Tempo em ms
  messageId: varchar("messageId", { length: 255 }),
  error: text("error"),
  attempts: int("attempts").default(1).notNull(),
  sentAt: timestamp("sentAt").defaultNow().notNull(),
});

export type EmailMetric = typeof emailMetrics.$inferSelect;
export type InsertEmailMetric = typeof emailMetrics.$inferInsert;

export const notifications = mysqlTable("notifications", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull(),
  type: varchar("type", { length: 100 }).notNull(),
  title: varchar("title", { length: 255 }).notNull(),
  message: text("message"),
  link: varchar("link", { length: 512 }),
  read: boolean("read").default(false).notNull(),
  readAt: datetime("readAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type Notification = typeof notifications.$inferSelect;
export type InsertNotification = typeof notifications.$inferInsert;

// ============================================================================
// TABELAS DE AUDITORIA
// ============================================================================

export const auditLogs = mysqlTable("auditLogs", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId"),
  action: varchar("action", { length: 100 }).notNull(),
  entity: varchar("entity", { length: 100 }).notNull(),
  entityId: int("entityId"),
  changes: text("changes"), // JSON com mudanças
  ipAddress: varchar("ipAddress", { length: 45 }),
  userAgent: text("userAgent"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type AuditLog = typeof auditLogs.$inferSelect;
export type InsertAuditLog = typeof auditLogs.$inferInsert;

// ============================================================================
// SISTEMA DE FEEDBACK CONTÍNUO
// ============================================================================

export const feedbacks = mysqlTable("feedbacks", {
  id: int("id").autoincrement().primaryKey(),
  managerId: int("managerId").notNull(), // Gestor que deu o feedback
  employeeId: int("employeeId").notNull(), // Colaborador que recebeu
  type: mysqlEnum("type", ["positivo", "construtivo", "desenvolvimento"]).notNull(),
  category: varchar("category", { length: 100 }), // Ex: Comunicação, Liderança, etc
  content: text("content").notNull(), // Conteúdo do feedback
  context: text("context"), // Contexto/situação
  actionItems: text("actionItems"), // Ações recomendadas (JSON)
  linkedPDIId: int("linkedPDIId"), // PDI vinculado (opcional)
  isPrivate: boolean("isPrivate").default(false).notNull(), // Visível apenas para gestor e colaborador
  acknowledgedAt: datetime("acknowledgedAt"), // Quando o colaborador visualizou
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Feedback = typeof feedbacks.$inferSelect;
export type InsertFeedback = typeof feedbacks.$inferInsert;

// ============================================================================
// SISTEMA DE BADGES E GAMIFICAÇÃO
// ============================================================================

export const badges = mysqlTable("badges", {
  id: int("id").autoincrement().primaryKey(),
  code: varchar("code", { length: 50 }), // Código único do badge
  name: varchar("name", { length: 100 }).notNull(),
  description: text("description").notNull(),
  icon: varchar("icon", { length: 50 }), // Nome do ícone lucide-react
  category: mysqlEnum("category", ["metas", "pdi", "avaliacao", "feedback", "geral"]).notNull(),
  points: int("points").notNull().default(0), // Pontos ganhos ao conquistar
  condition: text("condition"), // Condição para desbloquear (JSON)
  isActive: boolean("isActive").default(true).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type Badge = typeof badges.$inferSelect;
export type InsertBadge = typeof badges.$inferInsert;

export const employeeBadges = mysqlTable("employeeBadges", {
  id: int("id").autoincrement().primaryKey(),
  employeeId: int("employeeId").notNull(),
  badgeId: int("badgeId").notNull(),
  earnedAt: timestamp("earnedAt").defaultNow().notNull(),
  notified: boolean("notified").default(false).notNull(), // Se o colaborador foi notificado
});

export type EmployeeBadge = typeof employeeBadges.$inferSelect;
export type InsertEmployeeBadge = typeof employeeBadges.$inferInsert;

// ============================================================================
// RELAÇÕES (Relations)
// ============================================================================

export const employeesRelations = relations(employees, ({ one, many }) => ({
  user: one(users, {
    fields: [employees.userId],
    references: [users.id],
  }),
  department: one(departments, {
    fields: [employees.departmentId],
    references: [departments.id],
  }),
  position: one(positions, {
    fields: [employees.positionId],
    references: [positions.id],
  }),
  manager: one(employees, {
    fields: [employees.managerId],
    references: [employees.id],
  }),
  goals: many(goals),
  evaluations: many(performanceEvaluations),
  pdiPlans: many(pdiPlans),
  competencies: many(employeeCompetencies),
}));

export const goalsRelations = relations(goals, ({ one, many }) => ({
  employee: one(employees, {
    fields: [goals.employeeId],
    references: [employees.id],
  }),
  cycle: one(evaluationCycles, {
    fields: [goals.cycleId],
    references: [evaluationCycles.id],
  }),
  updates: many(goalUpdates),
}));

export const pdiPlansRelations = relations(pdiPlans, ({ one, many }) => ({
  employee: one(employees, {
    fields: [pdiPlans.employeeId],
    references: [employees.id],
  }),
  cycle: one(evaluationCycles, {
    fields: [pdiPlans.cycleId],
    references: [evaluationCycles.id],
  }),
  targetPosition: one(positions, {
    fields: [pdiPlans.targetPositionId],
    references: [positions.id],
  }),
  items: many(pdiItems),
}));

export const pdiItemsRelations = relations(pdiItems, ({ one, many }) => ({
  plan: one(pdiPlans, {
    fields: [pdiItems.planId],
    references: [pdiPlans.id],
  }),
  action: one(developmentActions, {
    fields: [pdiItems.actionId],
    references: [developmentActions.id],
  }),
  competency: one(competencies, {
    fields: [pdiItems.competencyId],
    references: [competencies.id],
  }),
  progress: many(pdiProgress),
}));


// ============================================================================
// TESTES PSICOMÉTRICOS
// ============================================================================

export const psychometricTests = mysqlTable("psychometricTests", {
  id: int("id").autoincrement().primaryKey(),
  employeeId: int("employeeId").notNull(),
  testType: mysqlEnum("testType", ["disc", "bigfive", "mbti", "ie", "vark", "leadership", "careeranchors"]).notNull(),
  completedAt: datetime("completedAt").notNull(),
  // Resultados DISC (0-100 para cada dimensão)
  discDominance: int("discDominance"), // Dominância
  discInfluence: int("discInfluence"), // Influência
  discSteadiness: int("discSteadiness"), // Estabilidade
  discCompliance: int("discCompliance"), // Conformidade
  discProfile: varchar("discProfile", { length: 10 }), // Ex: "D", "I", "S", "C", "DI", "SC"
  // Resultados Big Five (0-100 para cada dimensão)
  bigFiveOpenness: int("bigFiveOpenness"), // Abertura
  bigFiveConscientiousness: int("bigFiveConscientiousness"), // Conscienciosidade
  bigFiveExtraversion: int("bigFiveExtraversion"), // Extroversão
  bigFiveAgreeableness: int("bigFiveAgreeableness"), // Amabilidade
  bigFiveNeuroticism: int("bigFiveNeuroticism"), // Neuroticismo
  // Metadados
  responses: text("responses"), // JSON com todas as respostas
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type PsychometricTest = typeof psychometricTests.$inferSelect;
export type InsertPsychometricTest = typeof psychometricTests.$inferInsert;

export const testQuestions = mysqlTable("testQuestions", {
  id: int("id").autoincrement().primaryKey(),
  testType: mysqlEnum("testType", ["disc", "bigfive", "mbti", "ie", "vark", "leadership", "careeranchors"]).notNull(),
  questionNumber: int("questionNumber").notNull(),
  questionText: text("questionText").notNull(),
  dimension: varchar("dimension", { length: 50 }).notNull(), // Ex: "dominance", "openness", "E/I", "Autoconsciência", "Visual"
  reverse: boolean("reverse").default(false).notNull(), // Se a pontuação é invertida
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type TestQuestion = typeof testQuestions.$inferSelect;
export type InsertTestQuestion = typeof testQuestions.$inferInsert;

// ============================================================================
// CONFIGURAÇÕES DO SISTEMA
// ============================================================================

export const systemSettings = mysqlTable("systemSettings", {
  id: int("id").autoincrement().primaryKey(),
  settingKey: varchar("settingKey", { length: 100 }).notNull().unique(),
  settingValue: text("settingValue"),
  description: text("description"),
  isEncrypted: boolean("isEncrypted").default(false).notNull(),
  updatedBy: int("updatedBy"), // ID do usuário que atualizou
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type SystemSetting = typeof systemSettings.$inferSelect;
export type InsertSystemSetting = typeof systemSettings.$inferInsert;


// ============================================================================
// RELATÓRIOS AGENDADOS
// ============================================================================

export const scheduledReports = mysqlTable("scheduledReports", {
  id: int("id").autoincrement().primaryKey(),
  reportType: mysqlEnum("reportType", [
    "nine_box",
    "performance",
    "pdi",
    "evaluations",
    "goals",
    "competencies",
    "succession",
    "turnover",
    "headcount"
  ]).notNull(),
  reportName: varchar("reportName", { length: 255 }).notNull(),
  frequency: mysqlEnum("frequency", ["daily", "weekly", "monthly", "quarterly"]).notNull(),
  dayOfWeek: int("dayOfWeek"), // 0-6 para semanal (0=domingo)
  dayOfMonth: int("dayOfMonth"), // 1-31 para mensal
  hour: int("hour").default(9).notNull(), // Hora do dia (0-23)
  recipients: text("recipients").notNull(), // JSON array de e-mails
  departments: text("departments"), // JSON array de IDs de departamentos (filtro opcional)
  format: mysqlEnum("format", ["pdf", "excel", "csv"]).default("pdf").notNull(),
  includeCharts: boolean("includeCharts").default(true).notNull(),
  active: boolean("active").default(true).notNull(),
  lastExecutedAt: datetime("lastExecutedAt"),
  nextExecutionAt: datetime("nextExecutionAt"),
  createdBy: int("createdBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type ScheduledReport = typeof scheduledReports.$inferSelect;
export type InsertScheduledReport = typeof scheduledReports.$inferInsert;

export const reportExecutionLogs = mysqlTable("reportExecutionLogs", {
  id: int("id").autoincrement().primaryKey(),
  scheduledReportId: int("scheduledReportId").notNull(),
  executedAt: datetime("executedAt").notNull(),
  status: mysqlEnum("status", ["success", "failed", "partial"]).notNull(),
  recipientCount: int("recipientCount").default(0).notNull(),
  successCount: int("successCount").default(0).notNull(),
  failedCount: int("failedCount").default(0).notNull(),
  errorMessage: text("errorMessage"),
  executionTimeMs: int("executionTimeMs"), // Tempo de execução em milissegundos
  fileSize: int("fileSize"), // Tamanho do arquivo gerado em bytes
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type ReportExecutionLog = typeof reportExecutionLogs.$inferSelect;
export type InsertReportExecutionLog = typeof reportExecutionLogs.$inferInsert;


// ============================================================================
// TABELAS DE RELATÓRIOS CUSTOMIZÁVEIS
// ============================================================================

export const customReports = mysqlTable("customReports", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  createdBy: int("createdBy").notNull(),
  metrics: json("metrics").notNull(), // Array de métricas selecionadas
  filters: json("filters"), // Filtros aplicados (departamento, período, cargo)
  chartType: varchar("chartType", { length: 50 }), // bar, line, pie, table
  isTemplate: boolean("isTemplate").default(false).notNull(),
  isPublic: boolean("isPublic").default(false).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type CustomReport = typeof customReports.$inferSelect;
export type InsertCustomReport = typeof customReports.$inferInsert;

// Tabela de analytics de relatórios
export const reportAnalytics = mysqlTable("reportAnalytics", {
  id: int("id").autoincrement().primaryKey(),
  reportId: int("reportId"), // ID do relatório customizado (se aplicável)
  reportName: varchar("reportName", { length: 255 }),
  action: mysqlEnum("action", ["view", "export_pdf", "export_excel", "create", "update", "delete"]).notNull(),
  userId: int("userId").notNull(),
  metrics: json("metrics"), // Métricas utilizadas
  filters: json("filters"), // Filtros aplicados
  executionTimeMs: int("executionTimeMs"), // Tempo de execução
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type ReportAnalytic = typeof reportAnalytics.$inferSelect;
export type InsertReportAnalytic = typeof reportAnalytics.$inferInsert;

// ============================================================================
// TABELAS DE PDI INTELIGENTE (Extensão para Sucessão Estratégica)
// ============================================================================

/**
 * Tabela de detalhes estendidos do PDI para sucessão estratégica
 * Armazena informações de comparação de perfis, gaps, sponsors e riscos
 */
export const pdiIntelligentDetails = mysqlTable("pdiIntelligentDetails", {
  id: int("id").autoincrement().primaryKey(),
  planId: int("planId").notNull().unique(), // Relacionamento 1:1 com pdiPlans
  
  // Contexto estratégico
  strategicContext: text("strategicContext"), // Descrição do desafio estratégico
  durationMonths: int("durationMonths").default(24).notNull(), // Duração do plano em meses
  
  // Sponsors e responsáveis
  mentorId: int("mentorId"), // Gestor/Mentor direto
  sponsorId1: int("sponsorId1"), // Sponsor 1 (ex: Diretor Agroindustrial)
  sponsorId2: int("sponsorId2"), // Sponsor 2 (ex: Diretor de Gente e Cultura)
  guardianId: int("guardianId"), // Guardião do PDI (DGC)
  
  // Perfil atual (JSON com dados de testes psicométricos)
  currentProfile: json("currentProfile").$type<{
    disc?: { d: number; i: number; s: number; c: number };
    bigFive?: { o: number; c: number; e: number; a: number; n: number };
    mbti?: string;
    ie?: number;
    competencies?: { competencyId: number; level: number }[];
  }>(),
  
  // Perfil da posição-alvo (JSON)
  targetProfile: json("targetProfile").$type<{
    disc?: { d: number; i: number; s: number; c: number };
    bigFive?: { o: number; c: number; e: number; a: number; n: number };
    mbti?: string;
    ie?: number;
    competencies?: { competencyId: number; level: number }[];
  }>(),
  
  // Análise de gaps (JSON)
  gapsAnalysis: json("gapsAnalysis").$type<{
    gaps: Array<{
      type: "competency" | "behavioral" | "technical" | "leadership";
      name: string;
      currentLevel: number;
      targetLevel: number;
      priority: "high" | "medium" | "low";
      actions: string[];
    }>;
  }>(),
  
  // Marcos de progressão
  milestone12Months: text("milestone12Months"), // Marco de 12 meses
  milestone24Months: text("milestone24Months"), // Marco de 24 meses
  milestone12Status: mysqlEnum("milestone12Status", ["pendente", "concluido", "atrasado"]).default("pendente"),
  milestone24Status: mysqlEnum("milestone24Status", ["pendente", "concluido", "atrasado"]).default("pendente"),
  
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type PdiIntelligentDetail = typeof pdiIntelligentDetails.$inferSelect;
export type InsertPdiIntelligentDetail = typeof pdiIntelligentDetails.$inferInsert;

/**
 * Tabela de gaps de competências identificados no PDI
 */
export const pdiCompetencyGaps = mysqlTable("pdiCompetencyGaps", {
  id: int("id").autoincrement().primaryKey(),
  planId: int("planId").notNull(),
  competencyId: int("competencyId").notNull(),
  
  currentLevel: int("currentLevel").notNull(), // Nível atual (1-5)
  targetLevel: int("targetLevel").notNull(), // Nível desejado (1-5)
  gap: int("gap").notNull(), // Diferença (targetLevel - currentLevel)
  priority: mysqlEnum("priority", ["alta", "media", "baixa"]).default("media").notNull(),
  
  // Responsabilidades para superar o gap
  employeeActions: text("employeeActions"), // Ações do colaborador
  managerActions: text("managerActions"), // Ações do gestor
  sponsorActions: text("sponsorActions"), // Ações dos sponsors
  
  status: mysqlEnum("status", ["identificado", "em_desenvolvimento", "superado"]).default("identificado").notNull(),
  
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type PdiCompetencyGap = typeof pdiCompetencyGaps.$inferSelect;
export type InsertPdiCompetencyGap = typeof pdiCompetencyGaps.$inferInsert;

/**
 * Tabela de riscos do PDI
 */
export const pdiRisks = mysqlTable("pdiRisks", {
  id: int("id").autoincrement().primaryKey(),
  planId: int("planId").notNull(),
  
  type: mysqlEnum("type", ["saida", "gap_competencia", "tempo_preparo", "mudanca_estrategica", "outro"]).notNull(),
  description: text("description").notNull(),
  impact: mysqlEnum("impact", ["baixo", "medio", "alto", "critico"]).notNull(),
  probability: mysqlEnum("probability", ["baixa", "media", "alta"]).notNull(),
  
  mitigation: text("mitigation"), // Plano de mitigação
  responsible: int("responsible"), // Responsável pela mitigação
  
  status: mysqlEnum("status", ["identificado", "em_mitigacao", "mitigado", "materializado"]).default("identificado").notNull(),
  
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type PdiRisk = typeof pdiRisks.$inferSelect;
export type InsertPdiRisk = typeof pdiRisks.$inferInsert;

/**
 * Tabela de acompanhamento e reviews do PDI
 */
export const pdiReviews = mysqlTable("pdiReviews", {
  id: int("id").autoincrement().primaryKey(),
  planId: int("planId").notNull(),
  reviewerId: int("reviewerId").notNull(), // Quem fez o review (gestor, sponsor, DGC)
  reviewerRole: mysqlEnum("reviewerRole", ["mentor", "sponsor", "guardiao"]).notNull(),
  
  reviewDate: datetime("reviewDate").notNull(),
  overallProgress: int("overallProgress").notNull(), // Avaliação geral (0-100)
  
  strengths: text("strengths"), // Pontos fortes observados
  improvements: text("improvements"), // Pontos de melhoria
  nextSteps: text("nextSteps"), // Próximos passos recomendados
  
  recommendation: mysqlEnum("recommendation", ["manter", "acelerar", "ajustar", "pausar"]).notNull(),
  
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type PdiReview = typeof pdiReviews.$inferSelect;
export type InsertPdiReview = typeof pdiReviews.$inferInsert;

// Relações para PDI Inteligente
export const pdiIntelligentDetailsRelations = relations(pdiIntelligentDetails, ({ one }) => ({
  plan: one(pdiPlans, {
    fields: [pdiIntelligentDetails.planId],
    references: [pdiPlans.id],
  }),
  mentor: one(employees, {
    fields: [pdiIntelligentDetails.mentorId],
    references: [employees.id],
  }),
  sponsor1: one(employees, {
    fields: [pdiIntelligentDetails.sponsorId1],
    references: [employees.id],
  }),
  sponsor2: one(employees, {
    fields: [pdiIntelligentDetails.sponsorId2],
    references: [employees.id],
  }),
  guardian: one(employees, {
    fields: [pdiIntelligentDetails.guardianId],
    references: [employees.id],
  }),
}));

export const pdiCompetencyGapsRelations = relations(pdiCompetencyGaps, ({ one }) => ({
  plan: one(pdiPlans, {
    fields: [pdiCompetencyGaps.planId],
    references: [pdiPlans.id],
  }),
  competency: one(competencies, {
    fields: [pdiCompetencyGaps.competencyId],
    references: [competencies.id],
  }),
}));

export const pdiRisksRelations = relations(pdiRisks, ({ one }) => ({
  plan: one(pdiPlans, {
    fields: [pdiRisks.planId],
    references: [pdiPlans.id],
  }),
  responsibleEmployee: one(employees, {
    fields: [pdiRisks.responsible],
    references: [employees.id],
  }),
}));

export const pdiReviewsRelations = relations(pdiReviews, ({ one }) => ({
  plan: one(pdiPlans, {
    fields: [pdiReviews.planId],
    references: [pdiPlans.id],
  }),
  reviewer: one(employees, {
    fields: [pdiReviews.reviewerId],
    references: [employees.id],
  }),
}));


/**
 * ========================================
 * METAS SMART (SMART Goals)
 * ========================================
 * Sistema completo de metas com validação SMART,
 * aprovações e elegibilidade para bônus financeiro
 */

export const smartGoals = mysqlTable("smartGoals", {
  id: int("id").autoincrement().primaryKey(),
  employeeId: int("employeeId").notNull(),
  cycleId: int("cycleId").notNull(),
  pdiPlanId: int("pdiPlanId"), // Opcional: vincular com PDI
  
  // Informações básicas
  title: varchar("title", { length: 255 }).notNull(),
  description: text("description").notNull(),
  type: mysqlEnum("type", ["individual", "team", "organizational"]).notNull(),
  category: mysqlEnum("category", ["financial", "behavioral", "corporate", "development"]).notNull(),
  
  // Critérios SMART
  isSpecific: boolean("isSpecific").default(false).notNull(), // S - Específica
  isMeasurable: boolean("isMeasurable").default(false).notNull(), // M - Mensurável
  isAchievable: boolean("isAchievable").default(false).notNull(), // A - Atingível
  isRelevant: boolean("isRelevant").default(false).notNull(), // R - Relevante
  isTimeBound: boolean("isTimeBound").default(false).notNull(), // T - Temporal
  
  // Métricas
  measurementUnit: varchar("measurementUnit", { length: 50 }), // Ex: "R$", "%", "unidades"
  targetValue: decimal("targetValue", { precision: 10, scale: 2 }), // Valor alvo
  currentValue: decimal("currentValue", { precision: 10, scale: 2 }).default("0"), // Valor atual
  weight: int("weight").default(10).notNull(), // Peso da meta (para cálculo de bônus)
  
  // Datas
  startDate: date("startDate").notNull(),
  endDate: date("endDate").notNull(),
  
  // Bônus financeiro
  bonusEligible: boolean("bonusEligible").default(false).notNull(), // Elegível para bônus?
  bonusPercentage: decimal("bonusPercentage", { precision: 5, scale: 2 }), // % de bônus se atingir
  bonusAmount: decimal("bonusAmount", { precision: 10, scale: 2 }), // Valor fixo de bônus
  
  // Status e aprovação
  status: mysqlEnum("status", ["draft", "pending_approval", "approved", "rejected", "in_progress", "completed", "cancelled"]).default("draft").notNull(),
  approvalStatus: mysqlEnum("approvalStatus", ["not_submitted", "pending_manager", "pending_hr", "approved", "rejected"]).default("not_submitted").notNull(),
  progress: int("progress").default(0).notNull(), // 0-100%
  
  // Metadados
  createdBy: int("createdBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  completedAt: timestamp("completedAt"),
});

export const goalMilestones = mysqlTable("goalMilestones", {
  id: int("id").autoincrement().primaryKey(),
  goalId: int("goalId").notNull(),
  
  title: varchar("title", { length: 255 }).notNull(),
  description: text("description"),
  dueDate: date("dueDate").notNull(),
  
  status: mysqlEnum("status", ["pending", "in_progress", "completed", "delayed"]).default("pending").notNull(),
  progress: int("progress").default(0).notNull(), // 0-100%
  
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  completedAt: timestamp("completedAt"),
});

export const goalApprovals = mysqlTable("goalApprovals", {
  id: int("id").autoincrement().primaryKey(),
  goalId: int("goalId").notNull(),
  
  approverId: int("approverId").notNull(), // ID do aprovador (gestor ou RH)
  approverRole: mysqlEnum("approverRole", ["manager", "hr", "director"]).notNull(),
  
  status: mysqlEnum("status", ["pending", "approved", "rejected"]).default("pending").notNull(),
  comments: text("comments"),
  
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  decidedAt: timestamp("decidedAt"),
});

export const goalComments = mysqlTable("goalComments", {
  id: int("id").autoincrement().primaryKey(),
  goalId: int("goalId").notNull(),
  
  authorId: int("authorId").notNull(),
  comment: text("comment").notNull(),
  
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

// Relations
export const smartGoalsRelations = relations(smartGoals, ({ one, many }) => ({
  employee: one(employees, {
    fields: [smartGoals.employeeId],
    references: [employees.id],
  }),
  cycle: one(evaluationCycles, {
    fields: [smartGoals.cycleId],
    references: [evaluationCycles.id],
  }),
  pdiPlan: one(pdiPlans, {
    fields: [smartGoals.pdiPlanId],
    references: [pdiPlans.id],
  }),
  creator: one(employees, {
    fields: [smartGoals.createdBy],
    references: [employees.id],
  }),
  milestones: many(goalMilestones),
  approvals: many(goalApprovals),
  comments: many(goalComments),
}));

export const goalMilestonesRelations = relations(goalMilestones, ({ one }) => ({
  goal: one(smartGoals, {
    fields: [goalMilestones.goalId],
    references: [smartGoals.id],
  }),
}));

export const goalApprovalsRelations = relations(goalApprovals, ({ one }) => ({
  goal: one(smartGoals, {
    fields: [goalApprovals.goalId],
    references: [smartGoals.id],
  }),
  approver: one(employees, {
    fields: [goalApprovals.approverId],
    references: [employees.id],
  }),
}));

export const goalCommentsRelations = relations(goalComments, ({ one }) => ({
  goal: one(smartGoals, {
    fields: [goalComments.goalId],
    references: [smartGoals.id],
  }),
  author: one(employees, {
    fields: [goalComments.authorId],
    references: [employees.id],
  }),
}));

export type SmartGoal = typeof smartGoals.$inferSelect;
export type InsertSmartGoal = typeof smartGoals.$inferInsert;
export type GoalMilestone = typeof goalMilestones.$inferSelect;
export type InsertGoalMilestone = typeof goalMilestones.$inferInsert;
export type GoalApproval = typeof goalApprovals.$inferSelect;
export type InsertGoalApproval = typeof goalApprovals.$inferInsert;
export type GoalComment = typeof goalComments.$inferSelect;
export type InsertGoalComment = typeof goalComments.$inferInsert;

/**
 * Configurações de Bônus por Função
 * Define quantos salários cada função tem direito + bônus extra
 */
export const bonusConfigs = mysqlTable("bonusConfigs", {
  id: int("id").autoincrement().primaryKey(),
  positionId: int("positionId").notNull(), // Referência para positions
  positionName: varchar("positionName", { length: 255 }).notNull(),
  
  // Configuração de bônus
  baseSalaryMultiplier: decimal("baseSalaryMultiplier", { precision: 5, scale: 2 }).default("0").notNull(), // Ex: 1.5 = 1.5 salários
  extraBonusPercentage: decimal("extraBonusPercentage", { precision: 5, scale: 2 }).default("0").notNull(), // % adicional
  
  // Metadados
  isActive: boolean("isActive").default(true).notNull(),
  createdBy: int("createdBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

/**
 * Workflows de Aprovação de Bônus
 * Define até 5 níveis de aprovadores
 */
export const bonusWorkflows = mysqlTable("bonusWorkflows", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  
  // Aprovadores (até 5 níveis)
  approver1Id: int("approver1Id"), // RH
  approver1Role: varchar("approver1Role", { length: 100 }), // Ex: "Analista RH"
  approver2Id: int("approver2Id"), // Gerente RH
  approver2Role: varchar("approver2Role", { length: 100 }),
  approver3Id: int("approver3Id"), // Diretor de Gente
  approver3Role: varchar("approver3Role", { length: 100 }),
  approver4Id: int("approver4Id"), // Opcional
  approver4Role: varchar("approver4Role", { length: 100 }),
  approver5Id: int("approver5Id"), // Opcional
  approver5Role: varchar("approver5Role", { length: 100 }),
  
  // Configurações
  requireAllApprovals: boolean("requireAllApprovals").default(true).notNull(),
  isActive: boolean("isActive").default(true).notNull(),
  
  createdBy: int("createdBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

/**
 * Aprovações de Bônus
 * Registra cada etapa de aprovação no workflow
 */
export const bonusApprovals = mysqlTable("bonusApprovals", {
  id: int("id").autoincrement().primaryKey(),
  cycleId: int("cycleId").notNull(),
  employeeId: int("employeeId").notNull(),
  workflowId: int("workflowId").notNull(),
  
  // Valores de bônus
  eligibleAmount: decimal("eligibleAmount", { precision: 10, scale: 2 }).notNull(), // Valor elegível baseado em metas
  extraBonusPercentage: decimal("extraBonusPercentage", { precision: 5, scale: 2 }).default("0"), // Bônus extra do RH
  finalAmount: decimal("finalAmount", { precision: 10, scale: 2 }).notNull(), // Valor final aprovado
  
  // Status do workflow
  currentLevel: int("currentLevel").default(1).notNull(), // Nível atual de aprovação (1-5)
  status: mysqlEnum("status", ["pending", "approved", "rejected", "cancelled"]).default("pending").notNull(),
  
  // Aprovações por nível
  level1Status: mysqlEnum("level1Status", ["pending", "approved", "rejected"]).default("pending"),
  level1ApproverId: int("level1ApproverId"),
  level1ApprovedAt: timestamp("level1ApprovedAt"),
  level1Comments: text("level1Comments"),
  
  level2Status: mysqlEnum("level2Status", ["pending", "approved", "rejected"]).default("pending"),
  level2ApproverId: int("level2ApproverId"),
  level2ApprovedAt: timestamp("level2ApprovedAt"),
  level2Comments: text("level2Comments"),
  
  level3Status: mysqlEnum("level3Status", ["pending", "approved", "rejected"]).default("pending"),
  level3ApproverId: int("level3ApproverId"),
  level3ApprovedAt: timestamp("level3ApprovedAt"),
  level3Comments: text("level3Comments"),
  
  level4Status: mysqlEnum("level4Status", ["pending", "approved", "rejected"]).default("pending"),
  level4ApproverId: int("level4ApproverId"),
  level4ApprovedAt: timestamp("level4ApprovedAt"),
  level4Comments: text("level4Comments"),
  
  level5Status: mysqlEnum("level5Status", ["pending", "approved", "rejected"]).default("pending"),
  level5ApproverId: int("level5ApproverId"),
  level5ApprovedAt: timestamp("level5ApprovedAt"),
  level5Comments: text("level5Comments"),
  
  // Documento final
  signedPdfUrl: varchar("signedPdfUrl", { length: 500 }), // URL do PDF assinado
  sentToFinanceAt: timestamp("sentToFinanceAt"),
  
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

/**
 * Evidências de Cumprimento de Metas
 * Armazena descrições e anexos que comprovam a conclusão da meta
 */
export const goalEvidences = mysqlTable("goalEvidences", {
  id: int("id").autoincrement().primaryKey(),
  goalId: int("goalId").notNull(),
  
  // Evidência
  description: text("description").notNull(), // Descrição da evidência
  attachmentUrl: varchar("attachmentUrl", { length: 500 }), // URL do arquivo anexado (S3)
  attachmentName: varchar("attachmentName", { length: 255 }), // Nome original do arquivo
  attachmentType: varchar("attachmentType", { length: 100 }), // Tipo MIME
  attachmentSize: int("attachmentSize"), // Tamanho em bytes
  
  // Metadados
  uploadedBy: int("uploadedBy").notNull(),
  uploadedAt: timestamp("uploadedAt").defaultNow().notNull(),
  isVerified: boolean("isVerified").default(false).notNull(), // Verificado por auditor/gestor
  verifiedBy: int("verifiedBy"),
  verifiedAt: timestamp("verifiedAt"),
});

// Relations
export const bonusConfigsRelations = relations(bonusConfigs, ({ one }) => ({
  position: one(positions, {
    fields: [bonusConfigs.positionId],
    references: [positions.id],
  }),
  creator: one(employees, {
    fields: [bonusConfigs.createdBy],
    references: [employees.id],
  }),
}));

export const bonusWorkflowsRelations = relations(bonusWorkflows, ({ one, many }) => ({
  approver1: one(employees, {
    fields: [bonusWorkflows.approver1Id],
    references: [employees.id],
  }),
  approver2: one(employees, {
    fields: [bonusWorkflows.approver2Id],
    references: [employees.id],
  }),
  approver3: one(employees, {
    fields: [bonusWorkflows.approver3Id],
    references: [employees.id],
  }),
  approver4: one(employees, {
    fields: [bonusWorkflows.approver4Id],
    references: [employees.id],
  }),
  approver5: one(employees, {
    fields: [bonusWorkflows.approver5Id],
    references: [employees.id],
  }),
  creator: one(employees, {
    fields: [bonusWorkflows.createdBy],
    references: [employees.id],
  }),
  approvals: many(bonusApprovals),
}));

export const bonusApprovalsRelations = relations(bonusApprovals, ({ one }) => ({
  cycle: one(evaluationCycles, {
    fields: [bonusApprovals.cycleId],
    references: [evaluationCycles.id],
  }),
  employee: one(employees, {
    fields: [bonusApprovals.employeeId],
    references: [employees.id],
  }),
  workflow: one(bonusWorkflows, {
    fields: [bonusApprovals.workflowId],
    references: [bonusWorkflows.id],
  }),
}));

export const goalEvidencesRelations = relations(goalEvidences, ({ one }) => ({
  goal: one(smartGoals, {
    fields: [goalEvidences.goalId],
    references: [smartGoals.id],
  }),
  uploader: one(employees, {
    fields: [goalEvidences.uploadedBy],
    references: [employees.id],
  }),
  verifier: one(employees, {
    fields: [goalEvidences.verifiedBy],
    references: [employees.id],
  }),
}));

// Types
export type BonusConfig = typeof bonusConfigs.$inferSelect;
export type InsertBonusConfig = typeof bonusConfigs.$inferInsert;
export type BonusWorkflow = typeof bonusWorkflows.$inferSelect;
export type InsertBonusWorkflow = typeof bonusWorkflows.$inferInsert;
export type BonusApproval = typeof bonusApprovals.$inferSelect;
export type InsertBonusApproval = typeof bonusApprovals.$inferInsert;
export type GoalEvidence = typeof goalEvidences.$inferSelect;
export type InsertGoalEvidence = typeof goalEvidences.$inferInsert;

/**
 * Tabela de movimentações de calibração no Nine Box
 */
export const calibrationMovements = mysqlTable("calibrationMovements", {
  id: int("id").autoincrement().primaryKey(),
  employeeId: int("employeeId").notNull(),
  movedBy: int("movedBy").notNull(), // ID do usuário que moveu (RH)
  fromPerformance: mysqlEnum("fromPerformance", ["baixo", "médio", "alto"]),
  fromPotential: mysqlEnum("fromPotential", ["baixo", "médio", "alto"]),
  toPerformance: mysqlEnum("toPerformance", ["baixo", "médio", "alto"]).notNull(),
  toPotential: mysqlEnum("toPotential", ["baixo", "médio", "alto"]).notNull(),
  justification: text("justification").notNull(), // Justificativa obrigatória
  status: mysqlEnum("status", ["pending", "approved_hr", "approved_people_director", "approved_area_director", "rejected"]).default("pending").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type CalibrationMovement = typeof calibrationMovements.$inferSelect;
export type InsertCalibrationMovement = typeof calibrationMovements.$inferInsert;

/**
 * Tabela de aprovações de calibração (workflow)
 */
export const calibrationApprovals = mysqlTable("calibrationApprovals", {
  id: int("id").autoincrement().primaryKey(),
  movementId: int("movementId").notNull(),
  approverId: int("approverId").notNull(), // ID do aprovador
  approverRole: mysqlEnum("approverRole", ["hr", "people_director", "area_director"]).notNull(),
  status: mysqlEnum("status", ["pending", "approved", "rejected"]).default("pending").notNull(),
  evidence: text("evidence"), // Evidências (obrigatório para Diretor de Área)
  comments: text("comments"),
  approvedAt: timestamp("approvedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type CalibrationApproval = typeof calibrationApprovals.$inferSelect;
export type InsertCalibrationApproval = typeof calibrationApprovals.$inferInsert;

/**
 * Tabela de configuração de workflows de calibração
 */
export const calibrationWorkflows = mysqlTable("calibrationWorkflows", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  steps: text("steps").notNull(), // JSON com os passos do workflow
  isActive: boolean("isActive").default(true).notNull(),
  createdBy: int("createdBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type CalibrationWorkflow = typeof calibrationWorkflows.$inferSelect;
export type InsertCalibrationWorkflow = typeof calibrationWorkflows.$inferInsert;

// ============================================================================
// TABELAS DE WORKFLOWS GENÉRICOS
// ============================================================================

/**
 * Workflows Genéricos
 * Sistema flexível de aprovação para qualquer tipo de processo
 */
export const workflows = mysqlTable("workflows", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  type: mysqlEnum("type", [
    "aprovacao_metas",
    "aprovacao_pdi",
    "aprovacao_avaliacao",
    "aprovacao_bonus",
    "aprovacao_ferias",
    "aprovacao_promocao",
    "aprovacao_horas_extras",
    "aprovacao_despesas",
    "outro"
  ]).notNull(),
  
  // Configuração das etapas (JSON)
  steps: text("steps").notNull(), // Array de { order, name, approverType, approverIds, condition }
  
  // Status e controle
  isActive: boolean("isActive").default(true).notNull(),
  isDefault: boolean("isDefault").default(false).notNull(), // Workflow padrão para o tipo
  
  // Auditoria
  createdBy: int("createdBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Workflow = typeof workflows.$inferSelect;
export type InsertWorkflow = typeof workflows.$inferInsert;

/**
 * Instâncias de Execução de Workflows
 * Rastreia cada execução de um workflow
 */
export const workflowInstances = mysqlTable("workflowInstances", {
  id: int("id").autoincrement().primaryKey(),
  workflowId: int("workflowId").notNull(),
  entityType: varchar("entityType", { length: 100 }).notNull(), // "goal", "pdi", "evaluation", etc
  entityId: int("entityId").notNull(), // ID da entidade sendo aprovada
  
  // Status atual
  currentStep: int("currentStep").default(1).notNull(),
  status: mysqlEnum("status", ["pending", "approved", "rejected", "cancelled"]).default("pending").notNull(),
  
  // Auditoria
  requestedBy: int("requestedBy").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  completedAt: timestamp("completedAt"),
});

export type WorkflowInstance = typeof workflowInstances.$inferSelect;
export type InsertWorkflowInstance = typeof workflowInstances.$inferInsert;

/**
 * Aprovações de Etapas de Workflow
 * Registra cada aprovação individual em uma etapa
 */
export const workflowStepApprovals = mysqlTable("workflowStepApprovals", {
  id: int("id").autoincrement().primaryKey(),
  instanceId: int("instanceId").notNull(),
  stepOrder: int("stepOrder").notNull(),
  approverId: int("approverId").notNull(),
  
  // Decisão
  status: mysqlEnum("status", ["pending", "approved", "rejected"]).default("pending").notNull(),
  comments: text("comments"),
  
  // Auditoria
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  approvedAt: timestamp("approvedAt"),
});

export type WorkflowStepApproval = typeof workflowStepApprovals.$inferSelect;
export type InsertWorkflowStepApproval = typeof workflowStepApprovals.$inferInsert;


/**
 * SMTP Configuration
 * Stores email server configuration for sending notifications
 */
export const smtpConfig = mysqlTable("smtp_config", {
  id: int("id").autoincrement().primaryKey(),
  host: varchar("host", { length: 255 }).notNull(),
  port: int("port").notNull().default(587),
  secure: boolean("secure").default(false), // true for 465, false for other ports
  user: varchar("user", { length: 255 }).notNull(),
  password: text("password").notNull(), // Encrypted
  fromEmail: varchar("from_email", { length: 320 }).notNull(),
  fromName: varchar("from_name", { length: 255 }).notNull(),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().onUpdateNow().notNull(),
});

export type SmtpConfig = typeof smtpConfig.$inferSelect;
export type InsertSmtpConfig = typeof smtpConfig.$inferInsert;

// ============================================================================
// BENCHMARKING EXTERNO
// ============================================================================

/**
 * Dados de Benchmarking de Mercado
 * Armazena médias de mercado por setor, cargo e região para comparação
 */
export const marketBenchmarks = mysqlTable("marketBenchmarks", {
  id: int("id").autoincrement().primaryKey(),
  sector: varchar("sector", { length: 100 }).notNull(), // Setor (TI, Saúde, Financeiro, etc)
  position: varchar("position", { length: 100 }).notNull(), // Cargo
  region: varchar("region", { length: 100 }).default("Brasil").notNull(), // Região
  
  // Métricas de Performance
  avgPerformanceScore: int("avgPerformanceScore"), // Média de performance (0-100)
  avgEngagementScore: int("avgEngagementScore"), // Média de engajamento (0-100)
  avgTurnoverRate: int("avgTurnoverRate"), // Taxa de turnover (%)
  avgTenureYears: int("avgTenureYears"), // Tempo médio de permanência (anos)
  
  // Métricas Salariais
  avgSalary: int("avgSalary"), // Salário médio
  medianSalary: int("medianSalary"), // Salário mediano
  
  // Perfis Psicométricos Médios (DISC)
  avgDiscD: int("avgDiscD"), // Dominância (0-100)
  avgDiscI: int("avgDiscI"), // Influência (0-100)
  avgDiscS: int("avgDiscS"), // Estabilidade (0-100)
  avgDiscC: int("avgDiscC"), // Conformidade (0-100)
  
  // Perfis Psicométricos Médios (Big Five)
  avgOpenness: int("avgOpenness"), // Abertura (0-100)
  avgConscientiousness: int("avgConscientiousness"), // Conscienciosidade (0-100)
  avgExtraversion: int("avgExtraversion"), // Extroversão (0-100)
  avgAgreeableness: int("avgAgreeableness"), // Amabilidade (0-100)
  avgNeuroticism: int("avgNeuroticism"), // Neuroticismo (0-100)
  
  // Metadados
  sampleSize: int("sampleSize"), // Tamanho da amostra
  dataSource: varchar("dataSource", { length: 255 }), // Fonte dos dados
  year: int("year").notNull(), // Ano de referência
  
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type MarketBenchmark = typeof marketBenchmarks.$inferSelect;
export type InsertMarketBenchmark = typeof marketBenchmarks.$inferInsert;


// ============================================================================
// PDI INTELIGENTE - AÇÕES E ACOMPANHAMENTO (MODELO NADIA)
// ============================================================================

/**
 * Ações do PDI Inteligente (Modelo 70-20-10)
 * Tabela de ações específicas do plano de desenvolvimento com status e métricas
 */
export const pdiActions = mysqlTable("pdiActions", {
  id: int("id").autoincrement().primaryKey(),
  planId: int("planId").notNull(), // Relacionamento com pdiPlans
  
  // Informações da ação
  title: varchar("title", { length: 255 }).notNull(),
  description: text("description").notNull(),
  axis: mysqlEnum("axis", ["70_pratica", "20_experiencia", "10_educacao"]).notNull(), // Eixo 70-20-10
  developmentArea: varchar("developmentArea", { length: 100 }).notNull(), // Ex: "Visão Holística", "Liderança Sênior"
  
  // Métrica de sucesso
  successMetric: text("successMetric").notNull(), // Como medir o sucesso
  evidenceRequired: text("evidenceRequired"), // Evidências necessárias
  
  // Responsáveis
  responsible: varchar("responsible", { length: 255 }).notNull(), // Ex: "Nadia C. (Líder), Carlos M. (Sponsor)"
  
  // Prazo e status
  dueDate: datetime("dueDate").notNull(),
  status: mysqlEnum("status", ["nao_iniciado", "em_andamento", "concluido"]).default("nao_iniciado").notNull(),
  progress: int("progress").default(0).notNull(), // Percentual 0-100
  
  // Auditoria
  completedAt: datetime("completedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type PdiAction = typeof pdiActions.$inferSelect;
export type InsertPdiAction = typeof pdiActions.$inferInsert;

/**
 * Acompanhamento e Feedbacks do PDI (Governança DGC)
 * Registros de reuniões de acompanhamento com índice de prontidão
 */
export const pdiGovernanceReviews = mysqlTable("pdiGovernanceReviews", {
  id: int("id").autoincrement().primaryKey(),
  planId: int("planId").notNull(),
  
  // Data e responsável
  reviewDate: datetime("reviewDate").notNull(),
  reviewerId: int("reviewerId").notNull(), // Quem fez o acompanhamento (DGC, Gestor, Sponsor)
  reviewerRole: mysqlEnum("reviewerRole", ["dgc", "mentor", "sponsor"]).notNull(),
  
  // Índice de Prontidão para Sucessão (IPS)
  readinessIndex: decimal("readinessIndex", { precision: 3, scale: 1 }).notNull(), // 1.0 a 5.0
  
  // Feedback
  keyPoints: text("keyPoints").notNull(), // Pontos-chave da reunião
  strengths: text("strengths"), // Pontos fortes observados
  improvements: text("improvements"), // Áreas de melhoria
  nextSteps: text("nextSteps"), // Próximos passos
  
  // Auditoria
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type PdiGovernanceReview = typeof pdiGovernanceReviews.$inferSelect;
export type InsertPdiGovernanceReview = typeof pdiGovernanceReviews.$inferInsert;

==================================================================
## BACKEND - ROUTERS
==================================================================

import { TRPCError } from "@trpc/server";
import { z } from "zod";
import crypto from "crypto";
import { COOKIE_NAME } from "@shared/const";
import { getSessionCookieOptions } from "./_core/cookies";
import { systemRouter } from "./_core/systemRouter";
import { protectedProcedure, publicProcedure, router } from "./_core/trpc";
import * as db from "./db";
import { getUserByOpenId } from "./db";
import { employees, goals, pdiPlans, pdiItems, performanceEvaluations, nineBoxPositions, passwordResetTokens, users, successionPlans, testQuestions, psychometricTests, systemSettings, emailMetrics, calibrationSessions, calibrationReviews, evaluationResponses, evaluationQuestions, departments, positions, evaluationCycles, notifications, auditLogs, scheduledReports, reportExecutionLogs, workflows, workflowInstances, workflowStepApprovals, smtpConfig } from "../drizzle/schema";
import { getDb } from "./db";
import { analyticsRouter } from "./analyticsRouter";
import { feedbackRouter } from "./feedbackRouter";
import { badgesRouter } from "./badgesRouter";
import { scheduledReportsRouter } from "./scheduledReportsRouter";
import { executiveRouter } from "./executiveRouter";
import { successionRouter } from "./successionRouter";
import { nineBoxRouter } from "./nineBoxRouter";
import { pdiIntelligentRouter } from "./pdiIntelligentRouter";
import { evaluation360Router } from "./evaluation360Router";
import { reportBuilderRouter } from "./reportBuilderRouter";
import { reportAnalyticsRouter } from "./reportAnalyticsRouter";
import { goalsRouter } from "./goalsRouter";
import { bonusRouter } from "./bonusRouter";
import { calibrationRouter } from "./calibrationRouter";
import { gamificationRouter } from "./gamificationRouter";
import { integrationsRouter } from "./integrationsRouter";
import { eq, and, desc, sql } from "drizzle-orm";

export const appRouter = router({
  system: systemRouter,
  
  auth: router({
    me: publicProcedure.query(opts => opts.ctx.user),
    logout: publicProcedure.mutation(({ ctx }) => {
      const cookieOptions = getSessionCookieOptions(ctx.req);
      ctx.res.clearCookie(COOKIE_NAME, { ...cookieOptions, maxAge: -1 });
      return {
        success: true,
      } as const;
    }),

    // Solicitar reset de senha
    requestPasswordReset: publicProcedure
      .input(z.object({ email: z.string().email() }))
      .mutation(async ({ input }) => {
        const db = await getDb();
        if (!db) throw new Error("Database not available");

        // Buscar usuário por e-mail
        const user = await db.select()
          .from(users)
          .where(eq(users.email, input.email))
          .limit(1);

        if (user.length === 0) {
          // Não revelar se o e-mail existe ou não (segurança)
          return { success: true };
        }

        // Gerar token único
        const token = crypto.randomBytes(32).toString('hex');
        const expiresAt = new Date();
        expiresAt.setHours(expiresAt.getHours() + 1); // Expira em 1 hora

        // Salvar token no banco
        await db.insert(passwordResetTokens).values({
          userId: user[0].id,
          token,
          expiresAt,
        });

        // TODO: Enviar e-mail com link de reset
        // await emailService.sendResetPassword(input.email, { token, name: user[0].name });

        return { success: true };
      }),

    // Validar token de reset
    validateResetToken: publicProcedure
      .input(z.object({ token: z.string() }))
      .query(async ({ input }) => {
        const db = await getDb();
        if (!db) throw new Error("Database not available");

        const tokenRecord = await db.select()
          .from(passwordResetTokens)
          .where(
            and(
              eq(passwordResetTokens.token, input.token),
              eq(passwordResetTokens.used, false)
            )
          )
          .limit(1);

        if (tokenRecord.length === 0) {
          return { valid: false, message: "Token inválido" };
        }

        const token = tokenRecord[0];
        if (new Date() > new Date(token.expiresAt)) {
          return { valid: false, message: "Token expirado" };
        }

        return { valid: true };
      }),

    // Redefinir senha
    resetPassword: publicProcedure
      .input(z.object({ token: z.string(), newPassword: z.string().min(6) }))
      .mutation(async ({ input }) => {
        const db = await getDb();
        if (!db) throw new Error("Database not available");

        // Validar token
        const tokenRecord = await db.select()
          .from(passwordResetTokens)
          .where(
            and(
              eq(passwordResetTokens.token, input.token),
              eq(passwordResetTokens.used, false)
            )
          )
          .limit(1);

        if (tokenRecord.length === 0) {
          throw new Error("Token inválido");
        }

        const token = tokenRecord[0];
        if (new Date() > new Date(token.expiresAt)) {
          throw new Error("Token expirado");
        }

        // TODO: Atualizar senha do usuário (requer implementação de hash de senha)
        // await db.update(users)
        //   .set({ password: await hashPassword(input.newPassword) })
        //   .where(eq(users.id, token.userId));

        // Marcar token como usado
        await db.update(passwordResetTokens)
          .set({ used: true })
          .where(eq(passwordResetTokens.id, token.id));

        return { success: true };
      }),
  }),

  // ============================================================================
  // COLABORADORES
  // ============================================================================
  employees: router({
    list: protectedProcedure.query(async () => {
      return await db.getAllEmployees();
    }),

    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        const employee = await db.getEmployeeById(input.id);
        if (!employee) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Colaborador não encontrado",
          });
        }
        return employee;
      }),

    getByUserId: protectedProcedure
      .input(z.object({ userId: z.number() }))
      .query(async ({ input }) => {
        const employee = await db.getEmployeeByUserId(input.userId);
        return employee || null;
      }),

    getCurrent: protectedProcedure.query(async ({ ctx }) => {
      if (!ctx.user) {
        throw new TRPCError({
          code: "UNAUTHORIZED",
          message: "Usuário não autenticado",
        });
      }
      const employee = await db.getEmployeeByUserId(ctx.user.id);
      return employee || null;
    }),

    // Buscar equipe direta do gestor
    getTeamByManager: protectedProcedure
      .input(z.object({ managerId: z.number() }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) return [];

        const teamMembers = await database
          .select({
            id: employees.id,
            name: employees.name,
            email: employees.email,
            managerId: employees.managerId,
            departmentId: employees.departmentId,
            positionId: employees.positionId,
          })
          .from(employees)
          .where(eq(employees.managerId, input.managerId));

        // Buscar departamentos e cargos
        const depts = await database.select().from(departments);
        const positionsData = await database.select().from(positions);

        return teamMembers.map(emp => ({
          ...emp,
          department: depts.find(d => d.id === emp.departmentId),
          position: positionsData.find((p: any) => p.id === emp.positionId),
        }));
      }),

    // Hierarquia organizacional
    getHierarchy: protectedProcedure.query(async () => {
      const database = await getDb();
      if (!database) return [];

      // Buscar todos os colaboradores com JOIN em departments e positions
      const allEmployees = await database
        .select({
          id: employees.id,
          userId: employees.userId,
          employeeCode: employees.employeeCode,
          name: employees.name,
          email: employees.email,
          managerId: employees.managerId,
          costCenter: employees.costCenter,
          department: departments.name,
          departmentId: employees.departmentId,
          position: positions.title,
          positionId: employees.positionId,
        })
        .from(employees)
        .leftJoin(departments, eq(employees.departmentId, departments.id))
        .leftJoin(positions, eq(employees.positionId, positions.id));
      
      // Calcular contagem de subordinados para cada colaborador
      const employeesWithCount = allEmployees.map(emp => {
        const subordinateCount = allEmployees.filter(e => e.managerId === emp.id).length;
        return { ...emp, subordinateCount };
      });
      
      return employeesWithCount;
    }),

    // Atualizar colaborador (para importação em massa)
    exportHierarchyReport: protectedProcedure.query(async ({ ctx }) => {
      const db = await getDb();
      if (!db) throw new Error("Database not available");

      // Buscar todos os colaboradores com departamentos e cargos
      const allEmployees = await db
        .select({
          id: employees.id,
          name: employees.name,
          email: employees.email,
          managerId: employees.managerId,
          departmentId: employees.departmentId,
          positionId: employees.positionId,
          costCenter: employees.costCenter,
        })
        .from(employees);

      // Buscar departamentos e cargos
      const depts = await db.select().from(departments);
      const positionsData = await db.select().from(positions);

      // Calcular estatísticas
      const totalEmployees = allEmployees.length;
      const employeesWithManager = allEmployees.filter(e => e.managerId).length;
      const employeesWithoutManager = totalEmployees - employeesWithManager;
      const uniqueManagers = new Set(allEmployees.map(e => e.managerId).filter(Boolean)).size;

      // Agrupar por departamento
      const byDepartment = new Map<number, number>();
      allEmployees.forEach(e => {
        if (e.departmentId) {
          byDepartment.set(e.departmentId, (byDepartment.get(e.departmentId) || 0) + 1);
        }
      });

      // Calcular span of control (média de subordinados por gestor)
      const subordinatesCount = new Map<number, number>();
      allEmployees.forEach(e => {
        if (e.managerId) {
          subordinatesCount.set(e.managerId, (subordinatesCount.get(e.managerId) || 0) + 1);
        }
      });
      const avgSpanOfControl = subordinatesCount.size > 0
        ? Array.from(subordinatesCount.values()).reduce((a, b) => a + b, 0) / subordinatesCount.size
        : 0;

      return {
        totalEmployees,
        employeesWithManager,
        employeesWithoutManager,
        uniqueManagers,
        avgSpanOfControl: Math.round(avgSpanOfControl * 10) / 10,
        departmentStats: Array.from(byDepartment.entries()).map(([deptId, count]) => ({
          departmentId: deptId,
          departmentName: depts.find(d => d.id === deptId)?.name || `Dept ${deptId}`,
          count,
        })),
        employeesWithoutManagerList: allEmployees
          .filter(e => !e.managerId)
          .map(e => ({
            id: e.id,
            name: e.name,
            email: e.email,
            department: depts.find(d => d.id === e.departmentId)?.name || "",
            position: positionsData.find((p: any) => p.id === e.positionId)?.title || "",
            costCenter: e.costCenter || "",
          })),
      };
    }),

    updateEmployee: protectedProcedure
      .input(
        z.object({
          id: z.number(),
          managerId: z.number().optional(),
          costCenter: z.string().optional(),
        })
      )
      .mutation(async ({ input }) => {
        const database = await getDb();
        if (!database) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Database not available",
          });
        }

        const updateData: any = {};
        if (input.managerId !== undefined) updateData.managerId = input.managerId;
        if (input.costCenter !== undefined) updateData.costCenter = input.costCenter;

        await database
          .update(employees)
          .set(updateData)
          .where(eq(employees.id, input.id));

        return { success: true, message: "Colaborador atualizado com sucesso" };
      }),

    // Atualizar colaborador completo (para formulário de edição)
    update: protectedProcedure
      .input(
        z.object({
          id: z.number(),
          employeeCode: z.string(),
          name: z.string(),
          email: z.string().email(),
          cpf: z.string().optional(),
          birthDate: z.string().optional(),
          hireDate: z.string(),
          departmentId: z.number(),
          positionId: z.number(),
          managerId: z.number().optional(),
          salary: z.number().optional(),
          hierarchyLevel: z.enum(["diretoria", "gerencia", "coordenacao", "supervisao", "operacional"]).optional(),
          phone: z.string().optional(),
          address: z.string().optional(),
        })
      )
      .mutation(async ({ input }) => {
        const database = await getDb();
        if (!database) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Database not available",
          });
        }

        const updateData: any = {
          employeeCode: input.employeeCode,
          name: input.name,
          email: input.email,
          hireDate: input.hireDate,
          departmentId: input.departmentId,
          positionId: input.positionId,
          updatedAt: new Date(),
        };

        if (input.cpf !== undefined) updateData.cpf = input.cpf;
        if (input.birthDate !== undefined) updateData.birthDate = input.birthDate;
        if (input.managerId !== undefined) updateData.managerId = input.managerId;
        if (input.salary !== undefined) updateData.salary = input.salary;
        if (input.hierarchyLevel !== undefined) updateData.hierarchyLevel = input.hierarchyLevel;
        if (input.phone !== undefined) updateData.phone = input.phone;
        if (input.address !== undefined) updateData.address = input.address;

        await database
          .update(employees)
          .set(updateData)
          .where(eq(employees.id, input.id));

        return { success: true, message: "Colaborador atualizado com sucesso" };
      }),

    getDepartments: protectedProcedure.query(async () => {
      const database = await getDb();
      if (!database) return [];

      const allDepartments = await database.select().from(departments).where(eq(departments.active, true));
      return allDepartments.map(d => d.name).sort();
    }),

    getManagers: protectedProcedure.query(async () => {
      const database = await getDb();
      if (!database) return [];

      const allEmployees = await database.select().from(employees);
      return allEmployees;
    }),
  }),

  // ============================================================================
  // METAS
  // ============================================================================
  goals: router({
    list: protectedProcedure
      .input(z.object({ 
        employeeId: z.number().optional(),
        cycleId: z.number().optional(),
      }))
      .query(async ({ input, ctx }) => {
        const employeeId = input.employeeId || (await db.getEmployeeByUserId(ctx.user!.id))?.id;
        if (!employeeId) {
          return [];
        }
        return await db.getGoalsByEmployee(employeeId, input.cycleId);
      }),

    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        const goal = await db.getGoalById(input.id);
        if (!goal) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Meta não encontrada",
          });
        }
        return goal;
      }),

    // Buscar metas da equipe do gestor
    getTeamGoals: protectedProcedure
      .input(z.object({ managerId: z.number() }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) return [];

        // Buscar subordinados diretos
        const teamMembers = await database
          .select({ id: employees.id })
          .from(employees)
          .where(eq(employees.managerId, input.managerId));

        const teamMemberIds = teamMembers.map(e => e.id);
        if (teamMemberIds.length === 0) return [];

        // Buscar metas dos subordinados
        const teamGoals = await database
          .select()
          .from(goals)
          .where(sql`${goals.employeeId} IN (${sql.join(teamMemberIds, sql`, `)})`);

        // Buscar dados dos colaboradores
        const employeesData = await database
          .select({
            id: employees.id,
            name: employees.name,
          })
          .from(employees)
          .where(sql`${employees.id} IN (${sql.join(teamMemberIds, sql`, `)})`);

        return teamGoals.map(goal => ({
          ...goal,
          employee: employeesData.find(e => e.id === goal.employeeId),
        }));
      }),

    create: protectedProcedure
      .input(z.object({
        cycleId: z.number(),
        employeeId: z.number(),
        title: z.string().min(1),
        description: z.string().optional(),
        type: z.enum(["individual", "equipe", "organizacional"]),
        category: z.enum(["quantitativa", "qualitativa"]),
        targetValue: z.string().optional(),
        unit: z.string().optional(),
        weight: z.number().default(1),
        startDate: z.date(),
        endDate: z.date(),
        linkedToPLR: z.boolean().default(false),
        linkedToBonus: z.boolean().default(false),
      }))
      .mutation(async ({ input, ctx }) => {
        const database = await getDb();
        if (!database) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Banco de dados indisponível",
          });
        }

        const [result] = await database.insert(goals).values({
          ...input,
          createdBy: ctx.user!.id,
          status: "rascunho",
          progress: 0,
        });

        const goalId = Number(result.insertId);

        await db.logAudit(
          ctx.user!.id,
          "CREATE",
          "goals",
          goalId,
          input,
          ctx.req.ip,
          ctx.req.headers["user-agent"]
        );

        return { id: goalId, success: true };
      }),

    updateProgress: protectedProcedure
      .input(z.object({
        id: z.number(),
        progress: z.number().min(0).max(100),
        currentValue: z.string().optional(),
        notes: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const database = await getDb();
        if (!database) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Banco de dados indisponível",
          });
        }

        const goal = await db.getGoalById(input.id);
        if (!goal) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Meta não encontrada",
          });
        }

        await database.update(goals)
          .set({
            progress: input.progress,
            currentValue: input.currentValue,
            status: input.progress === 100 ? "concluida" : "em_andamento",
          })
          .where(eq(goals.id, input.id));

        await db.logAudit(
          ctx.user!.id,
          "UPDATE_PROGRESS",
          "goals",
          input.id,
          { progress: input.progress, currentValue: input.currentValue },
          ctx.req.ip,
          ctx.req.headers["user-agent"]
        );

        // Verificar badges de metas se progresso = 100%
        if (input.progress === 100 && goal.employeeId) {
          const { checkGoalBadges } = await import("./services/badgeService");
          await checkGoalBadges(goal.employeeId);

          // Criar notificação de meta atingida
          try {
            const employee = await database.select()
              .from(employees)
              .where(eq(employees.id, goal.employeeId))
              .limit(1);

            if (employee.length > 0 && employee[0].managerId) {
              const manager = await database.select()
                .from(employees)
                .where(eq(employees.id, employee[0].managerId))
                .limit(1);

              if (manager.length > 0 && manager[0].userId) {
                await createNotification({
                  userId: manager[0].userId,
                  type: "goal_achieved",
                  title: "Meta Atingida",
                  message: `${employee[0].name} atingiu 100% da meta: ${goal.title}`,
                  link: `/metas`,
                });
              }
            }
          } catch (error) {
            console.error("Erro ao criar notificação de meta:", error);
          }
        }

        // Notificar marcos de progresso (25%, 50%, 75%)
        const milestones = [25, 50, 75];
        if (milestones.includes(input.progress) && goal.employeeId) {
          try {
            const employee = await database.select()
              .from(employees)
              .where(eq(employees.id, goal.employeeId))
              .limit(1);

            if (employee.length > 0 && employee[0].managerId) {
              const manager = await database.select()
                .from(employees)
                .where(eq(employees.id, employee[0].managerId))
                .limit(1);

              if (manager.length > 0 && manager[0].userId) {
                await createNotification({
                  userId: manager[0].userId,
                  type: "pdi_milestone",
                  title: "Marco de Progresso Atingido",
                  message: `${employee[0].name} atingiu ${input.progress}% da meta: ${goal.title}`,
                  link: `/metas`,
                });
              }
            }
          } catch (error) {
            console.error("Erro ao criar notificação de marco:", error);
          }
        }

        return { success: true };
      }),
  }),

  // ============================================================================
  // AVALIAÇÕES 360°
  // ============================================================================
  evaluations: router({
    list: protectedProcedure
      .input(z.object({
        employeeId: z.number().optional(),
        cycleId: z.number().optional(),
      }))
      .query(async ({ input, ctx }) => {
        const employeeId = input.employeeId || (await db.getEmployeeByUserId(ctx.user!.id))?.id;
        if (!employeeId) {
          return [];
        }
        return await db.getEvaluationsByEmployee(employeeId, input.cycleId);
      }),

    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        const evaluation = await db.getEvaluationById(input.id);
        if (!evaluation) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Avaliação não encontrada",
          });
        }
        return evaluation;
      }),

    create: protectedProcedure
      .input(z.object({
        cycleId: z.number(),
        employeeId: z.number(),
        type: z.enum(["360", "180", "90"]),
      }))
      .mutation(async ({ input, ctx }) => {
        const database = await getDb();
        if (!database) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Banco de dados indisponível",
          });
        }

        const [result] = await database.insert(performanceEvaluations).values({
          ...input,
          status: "pendente",
        });

        const evaluationId = Number(result.insertId);

        await db.logAudit(
          ctx.user!.id,
          "CREATE",
          "performanceEvaluations",
          evaluationId,
          input,
          ctx.req.ip,
          ctx.req.headers["user-agent"]
        );

        return { id: evaluationId, success: true };
      }),

    // Buscar avaliações pendentes da equipe do gestor
    getPendingByManager: protectedProcedure
      .input(z.object({ managerId: z.number() }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) return [];

        // Buscar subordinados diretos
        const teamMembers = await database
          .select({ id: employees.id })
          .from(employees)
          .where(eq(employees.managerId, input.managerId));

        const teamMemberIds = teamMembers.map(e => e.id);
        if (teamMemberIds.length === 0) return [];

        // Buscar avaliações pendentes dos subordinados
        const pendingEvaluations = await database
          .select()
          .from(performanceEvaluations)
          .where(
            sql`${performanceEvaluations.employeeId} IN (${sql.join(teamMemberIds, sql`, `)}) AND ${performanceEvaluations.status} IN ('pendente', 'em_andamento')`
          );

        // Buscar dados dos colaboradores e ciclos
        const employeesData = await database
          .select({
            id: employees.id,
            name: employees.name,
          })
          .from(employees)
          .where(sql`${employees.id} IN (${sql.join(teamMemberIds, sql`, `)})`);

        const cyclesData = await database.select().from(evaluationCycles);

        return pendingEvaluations.map(evaluation => ({
          ...evaluation,
          employee: employeesData.find(e => e.id === evaluation.employeeId),
          cycle: cyclesData.find((c: any) => c.id === evaluation.cycleId),
        }));
      }),
  }),

  // ============================================================================
  // PDI (Plano de Desenvolvimento Individual)
  // ============================================================================
  pdi: router({
    list: protectedProcedure
      .input(z.object({
        employeeId: z.number().optional(),
        cycleId: z.number().optional(),
      }))
      .query(async ({ input, ctx }) => {
        const employeeId = input.employeeId || (await db.getEmployeeByUserId(ctx.user!.id))?.id;
        if (!employeeId) {
          return [];
        }
        return await db.getPDIsByEmployee(employeeId, input.cycleId);
      }),

    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        const pdi = await db.getPDIById(input.id);
        if (!pdi) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "PDI não encontrado",
          });
        }
        return pdi;
      }),

    getItems: protectedProcedure
      .input(z.object({ planId: z.number() }))
      .query(async ({ input }) => {
        return await db.getPDIItemsByPlan(input.planId);
      }),

    // Buscar PDIs da equipe do gestor
    getTeamPDIs: protectedProcedure
      .input(z.object({ managerId: z.number() }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) return [];

        // Buscar subordinados diretos
        const teamMembers = await database
          .select({ id: employees.id })
          .from(employees)
          .where(eq(employees.managerId, input.managerId));

        const teamMemberIds = teamMembers.map(e => e.id);
        if (teamMemberIds.length === 0) return [];

        // Buscar PDIs dos subordinados
        const teamPDIs = await database
          .select()
          .from(pdiPlans)
          .where(sql`${pdiPlans.employeeId} IN (${sql.join(teamMemberIds, sql`, `)})`);

        // Buscar dados dos colaboradores e cargos
        const employeesData = await database
          .select({
            id: employees.id,
            name: employees.name,
          })
          .from(employees)
          .where(sql`${employees.id} IN (${sql.join(teamMemberIds, sql`, `)})`);

        const positionsData = await database.select().from(positions);

        return teamPDIs.map(pdi => ({
          ...pdi,
          employee: employeesData.find(e => e.id === pdi.employeeId),
          targetPosition: positionsData.find((p: any) => p.id === pdi.targetPositionId),
        }));
      }),

    create: protectedProcedure
      .input(z.object({
        cycleId: z.number(),
        employeeId: z.number(),
        targetPositionId: z.number().optional(),
        startDate: z.date(),
        endDate: z.date(),
      }))
      .mutation(async ({ input, ctx }) => {
        const database = await getDb();
        if (!database) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Banco de dados indisponível",
          });
        }

        const [result] = await database.insert(pdiPlans).values({
          ...input,
          status: "rascunho",
          overallProgress: 0,
        });

        const pdiId = Number(result.insertId);

        await db.logAudit(
          ctx.user!.id,
          "CREATE",
          "pdiPlans",
          pdiId,
          input,
          ctx.req.ip,
          ctx.req.headers["user-agent"]
        );

        // Verificar badges de PDI ao criar
        if (input.employeeId) {
          const { checkPDIBadges } = await import("./services/badgeService");
          await checkPDIBadges(input.employeeId);
        }

        return { id: pdiId, success: true };
      }),

    addItem: protectedProcedure
      .input(z.object({
        planId: z.number(),
        actionId: z.number().optional(),
        competencyId: z.number(),
        title: z.string().min(1),
        description: z.string().optional(),
        category: z.enum(["70_pratica", "20_mentoria", "10_curso"]),
        type: z.string().optional(),
        startDate: z.date(),
        endDate: z.date(),
      }))
      .mutation(async ({ input, ctx }) => {
        const database = await getDb();
        if (!database) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Banco de dados indisponível",
          });
        }

        const [result] = await database.insert(pdiItems).values({
          ...input,
          status: "pendente",
          progress: 0,
        });

        const itemId = Number(result.insertId);

        await db.logAudit(
          ctx.user!.id,
          "ADD_ITEM",
          "pdiItems",
          itemId,
          input,
          ctx.req.ip,
          ctx.req.headers["user-agent"]
        );

        return { id: itemId, success: true };
      }),

    getDevelopmentActions: protectedProcedure.query(async () => {
      return await db.getDevelopmentActions();
    }),
  }),

  // ============================================================================
  // MATRIZ 9-BOX
  // ============================================================================
  nineBox: router({
    getByCycle: protectedProcedure
      .input(z.object({ cycleId: z.number() }))
      .query(async ({ input }) => {
        return await db.getNineBoxByCycle(input.cycleId);
      }),

    // Listar posições da matriz 9-box
    list: protectedProcedure
      .input(z.object({ cycleId: z.number() }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) return [];

        const positions = await database.select()
          .from(nineBoxPositions)
          .innerJoin(employees, eq(nineBoxPositions.employeeId, employees.id))
          .where(eq(nineBoxPositions.cycleId, input.cycleId));

        return positions.map(p => ({
          employeeId: p.nineBoxPositions.employeeId,
          employeeName: p.employees.name,
          positionName: 'Cargo', // TODO: Join com positions table
          departmentName: 'Departamento', // TODO: Join com departments table
          performance: p.nineBoxPositions.performance,
          potential: p.nineBoxPositions.potential,
          calibratedAt: p.nineBoxPositions.calibratedAt,
        }));
      }),

    // Ajustar posição (calibração/RH)
    adjust: protectedProcedure
      .input(z.object({
        cycleId: z.number(),
        employeeId: z.number(),
        performance: z.number().min(1).max(3),
        potential: z.number().min(1).max(3),
        reason: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        const employee = await getUserByOpenId(ctx.user.openId);
        if (!employee) throw new Error("Employee not found");

        const box = `${input.performance}_${input.potential}`;

        await database.update(nineBoxPositions)
          .set({
            performance: input.performance,
            potential: input.potential,
            box,
            calibratedBy: employee.id,
            calibratedAt: new Date(),
            notes: input.reason,
          })
          .where(
            and(
              eq(nineBoxPositions.cycleId, input.cycleId),
              eq(nineBoxPositions.employeeId, input.employeeId)
            )
          );

        return { success: true };
      }),

    updatePosition: protectedProcedure
      .input(z.object({
        id: z.number(),
        performance: z.number().min(1).max(3),
        potential: z.number().min(1).max(3),
        notes: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const database = await getDb();
        if (!database) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Banco de dados indisponível",
          });
        }

        const box = `${input.performance}_${input.potential}`;
        
        await database.update(nineBoxPositions)
          .set({
            performance: input.performance,
            potential: input.potential,
            box,
            notes: input.notes,
          })
          .where(eq(nineBoxPositions.id, input.id));

        await db.logAudit(
          ctx.user!.id,
          "UPDATE_POSITION",
          "nineBoxPositions",
          input.id,
          input,
          ctx.req.ip,
          ctx.req.headers["user-agent"]
        );

        return { success: true };
      }),
  }),

  // ============================================================================
  // DASHBOARD E ESTATÍSTICAS
  // ============================================================================
  dashboard: router({
    getStats: protectedProcedure
      .input(z.object({
        employeeId: z.number().optional(),
        cycleId: z.number().optional(),
      }))
      .query(async ({ input, ctx }) => {
        const employeeId = input.employeeId || (await db.getEmployeeByUserId(ctx.user!.id))?.id;
        if (!employeeId) {
          // Retornar dados vazios se colaborador não existir
          return {
            activeGoals: 0,
            completedGoals: 0,
            pendingEvaluations: 0,
            activePDIs: 0,
            recentActivities: [],
            cycle: null,
            goalsCount: 0,
            pdisCount: 0,
            evaluationsCount: 0,
          };
        }
        return await db.getDashboardStats(employeeId, input.cycleId);
      }),
  }),

  // ============================================================================
  // CICLOS, DEPARTAMENTOS E CARGOS
  // ============================================================================
  cycles: router({
    list: protectedProcedure.query(async () => {
      return await db.getAllCycles();
    }),

    getActive: protectedProcedure.query(async () => {
      return await db.getActiveCycle();
    }),
  }),

  departments: router({
    list: protectedProcedure.query(async () => {
      return await db.getAllDepartments();
    }),
  }),

  positions: router({
    list: protectedProcedure.query(async () => {
      return await db.getAllPositions();
    }),
  }),

  // ============================================================================
  // COMPETÊNCIAS
  // ============================================================================
  competencies: router({
    getByEmployee: protectedProcedure
      .input(z.object({ employeeId: z.number() }))
      .query(async ({ input }) => {
        return await db.getEmployeeCompetencies(input.employeeId);
      }),
  }),

  // ============================================================================
  // PDI INTELIGENTE COM IA
  // ============================================================================
  pdiAI: router({
    // Gerar recomendações de PDI com IA Gemini
    generateRecommendations: protectedProcedure
      .input(z.object({ 
        employeeId: z.number(),
        competencyGaps: z.array(z.object({
          competencyName: z.string(),
          currentLevel: z.number(),
          requiredLevel: z.number(),
          category: z.string()
        }))
      }))
      .mutation(async ({ input }) => {
        const { invokeLLM } = await import("./_core/llm");
        
        const gapsText = input.competencyGaps
          .map(g => `- ${g.competencyName} (${g.category}): Nível atual ${g.currentLevel}, Nível esperado ${g.requiredLevel}, Gap: ${g.requiredLevel - g.currentLevel}`)
          .join("\n");

        const prompt = `Você é um especialista em Recursos Humanos e Desenvolvimento de Pessoas. Analise os gaps de competências abaixo e gere recomendações de ações de desenvolvimento seguindo o modelo 70-20-10:

**Gaps de Competências:**
${gapsText}

**Modelo 70-20-10:**
- 70% Aprendizado na Prática (projetos, desafios, rotacionação de funções)
- 20% Aprendizado Social (mentoria, coaching, feedback de pares)
- 10% Aprendizado Formal (cursos, treinamentos, certificações)

Gere 6-8 ações de desenvolvimento específicas, práticas e mensuráveis, distribuídas proporcionalmente no modelo 70-20-10. Para cada ação, inclua:
- Título claro e objetivo
- Descrição detalhada
- Tipo (pratica, social ou formal)
- Competência que desenvolve
- Prazo estimado em meses`;

        const response = await invokeLLM({
          messages: [
            { role: "system", content: "Você é um especialista em RH e desenvolvimento de talentos. Sempre fornece recomendações práticas, específicas e mensuráveis." },
            { role: "user", content: prompt }
          ],
          response_format: {
            type: "json_schema",
            json_schema: {
              name: "pdi_recommendations",
              strict: true,
              schema: {
                type: "object",
                properties: {
                  actions: {
                    type: "array",
                    items: {
                      type: "object",
                      properties: {
                        title: { type: "string", description: "Título da ação" },
                        description: { type: "string", description: "Descrição detalhada" },
                        type: { type: "string", enum: ["pratica", "social", "formal"], description: "Tipo de aprendizado" },
                        competency: { type: "string", description: "Competência que desenvolve" },
                        estimatedMonths: { type: "integer", description: "Prazo estimado em meses" }
                      },
                      required: ["title", "description", "type", "competency", "estimatedMonths"],
                      additionalProperties: false
                    }
                  }
                },
                required: ["actions"],
                additionalProperties: false
              }
            }
          }
        });

        const content = response.choices[0].message.content;
        const result = typeof content === "string" ? JSON.parse(content) : content;
        
        return result.actions;
      }),
  }),

  // ============================================================================
  // APROVAÇÃO DE PDI
  // ============================================================================
  pdiApproval: router({
    // Submeter PDI para aprovação
    submit: protectedProcedure
      .input(z.object({ planId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const db = await getDb();
        if (!db) throw new Error("Database not available");

        await db.update(pdiPlans)
          .set({ 
            status: "pendente_aprovacao",
            updatedAt: new Date()
          })
          .where(eq(pdiPlans.id, input.planId));

        // TODO: Enviar notificação por e-mail ao gestor
        return { success: true };
      }),

    // Aprovar PDI (gestor)
    approve: protectedProcedure
      .input(z.object({ planId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const db = await getDb();
        if (!db) throw new Error("Database not available");

        const employee = await getUserByOpenId(ctx.user.openId);
        if (!employee) throw new Error("Employee not found");

        // Buscar PDI para pegar employeeId
        const pdi = await db.select().from(pdiPlans).where(eq(pdiPlans.id, input.planId)).limit(1);
        
        await db.update(pdiPlans)
          .set({ 
            status: "aprovado",
            approvedBy: employee.id,
            approvedAt: new Date(),
            updatedAt: new Date()
          })
          .where(eq(pdiPlans.id, input.planId));

        // Verificar badges de PDI ao aprovar
        if (pdi[0]?.employeeId) {
          const { checkPDIBadges } = await import("./services/badgeService");
          await checkPDIBadges(pdi[0].employeeId);
        }

        // TODO: Enviar notificação por e-mail ao colaborador
        return { success: true };
      }),

    // Rejeitar PDI (gestor)
    reject: protectedProcedure
      .input(z.object({ planId: z.number(), reason: z.string() }))
      .mutation(async ({ input, ctx }) => {
        const db = await getDb();
        if (!db) throw new Error("Database not available");

        await db.update(pdiPlans)
          .set({ 
            status: "rascunho",
            updatedAt: new Date()
          })
          .where(eq(pdiPlans.id, input.planId));

        // TODO: Enviar notificação por e-mail ao colaborador com motivo da rejeição
        return { success: true, reason: input.reason };
      }),

    // Listar PDIs pendentes de aprovação (gestor)
    listPending: protectedProcedure
      .query(async ({ ctx }) => {
        const db = await getDb();
        if (!db) return [];

        const employee = await getUserByOpenId(ctx.user.openId);
        if (!employee) return [];

        // Buscar PDIs de subordinados pendentes de aprovação
        const result = await db.select()
          .from(pdiPlans)
          .innerJoin(employees, eq(pdiPlans.employeeId, employees.id))
          .where(
            and(
              eq(employees.managerId, employee.id),
              eq(pdiPlans.status, "pendente_aprovacao")
            )
          );

        return result;
      }),
  }),

  // ============================================================================
  // CALIBRAÇÃO DA MATRIZ 9-BOX
  // ============================================================================
  nineBoxCalibration: router({
    // Listar colaboradores para calibração
    list: protectedProcedure
      .input(z.object({ cycleId: z.number(), departmentId: z.number().optional() }))
      .query(async ({ input }) => {
        const db = await getDb();
        if (!db) return [];

        const conditions = [eq(nineBoxPositions.cycleId, input.cycleId)];
        if (input.departmentId) {
          conditions.push(eq(employees.departmentId, input.departmentId));
        }

        const result = await db.select()
          .from(nineBoxPositions)
          .innerJoin(employees, eq(nineBoxPositions.employeeId, employees.id))
          .where(and(...conditions));

        return result;
      }),

    // Ajustar posicionamento na Matriz 9-Box
    adjust: protectedProcedure
      .input(z.object({ 
        positionId: z.number(),
        performance: z.number().min(1).max(3),
        potential: z.number().min(1).max(3),
        justification: z.string()
      }))
      .mutation(async ({ input, ctx }) => {
        const db = await getDb();
        if (!db) throw new Error("Database not available");

        const employee = await getUserByOpenId(ctx.user.openId);
        if (!employee) throw new Error("Employee not found");

        await db.update(nineBoxPositions)
          .set({ 
            performance: input.performance,
            potential: input.potential,
            calibrated: true,
            calibratedBy: employee.id,
            calibratedAt: new Date(),
            notes: input.justification,
            updatedAt: new Date()
          })
          .where(eq(nineBoxPositions.id, input.positionId));

        return { success: true };
      }),

    // Finalizar calibração
    finalize: protectedProcedure
      .input(z.object({ cycleId: z.number() }))
      .mutation(async ({ input }) => {
        const db = await getDb();
        if (!db) throw new Error("Database not available");

        // Marcar todas as posições do ciclo como calibradas
        await db.update(nineBoxPositions)
          .set({ 
            calibrated: true,
            updatedAt: new Date()
          })
          .where(eq(nineBoxPositions.cycleId, input.cycleId));

        return { success: true };
      }),
  }),

  // ============================================================================
  // EXPORTAÇÃO DE RELATÓRIOS PDF
  // ============================================================================
  reports: router({
    // Exportar relatório de avaliação 360°
    export360: protectedProcedure
      .input(z.object({ evaluationId: z.number() }))
      .query(async ({ input }) => {
        const db = await getDb();
        if (!db) throw new Error("Database not available");

        const evaluation = await db.select()
          .from(performanceEvaluations)
          .innerJoin(employees, eq(performanceEvaluations.employeeId, employees.id))
          .where(eq(performanceEvaluations.id, input.evaluationId))
          .limit(1);

        if (evaluation.length === 0) throw new Error("Evaluation not found");

        return evaluation[0];
      }),

    // Exportar relatório de PDI
    exportPDI: protectedProcedure
      .input(z.object({ pdiId: z.number() }))
      .query(async ({ input }) => {
        const db = await getDb();
        if (!db) throw new Error("Database not available");

        const pdi = await db.select()
          .from(pdiPlans)
          .innerJoin(employees, eq(pdiPlans.employeeId, employees.id))
          .where(eq(pdiPlans.id, input.pdiId))
          .limit(1);

        if (pdi.length === 0) throw new Error("PDI not found");

        // Buscar itens do PDI
        const items = await db.select()
          .from(pdiItems)
          .where(eq(pdiItems.planId, input.pdiId));

        return { pdi: pdi[0], items };
      }),

    // Exportar relatório de Matriz 9-Box
    export9Box: protectedProcedure
      .input(z.object({ cycleId: z.number() }))
      .query(async ({ input }) => {
        const db = await getDb();
        if (!db) throw new Error("Database not available");

        const positions = await db.select()
          .from(nineBoxPositions)
          .innerJoin(employees, eq(nineBoxPositions.employeeId, employees.id))
          .where(eq(nineBoxPositions.cycleId, input.cycleId));

        return positions;
      }),
  }),

  // ============================================================================
  // HISTÓRICO
  // ============================================================================
  history: router({
    // Histórico de avaliações 360°
    evaluations: protectedProcedure
      .input(z.object({ employeeId: z.number() }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) return [];

        const evaluations = await database
          .select()
          .from(performanceEvaluations)
          .where(eq(performanceEvaluations.employeeId, input.employeeId))
          .orderBy(desc(performanceEvaluations.createdAt));

        return evaluations;
      }),

    // Histórico de PDIs
    pdis: protectedProcedure
      .input(z.object({ employeeId: z.number() }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) return [];

        const pdis = await database
          .select()
          .from(pdiPlans)
          .where(eq(pdiPlans.employeeId, input.employeeId))
          .orderBy(desc(pdiPlans.createdAt));

        return pdis;
      }),

    // Histórico de Matriz 9-Box
    nineBox: protectedProcedure
      .input(z.object({ employeeId: z.number() }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) return [];

        const positions = await database
          .select()
          .from(nineBoxPositions)
          .where(eq(nineBoxPositions.employeeId, input.employeeId))
          .orderBy(desc(nineBoxPositions.createdAt));

        return positions;
      }),

    // Evolução de competências ao longo do tempo
    competenciesEvolution: protectedProcedure
      .input(z.object({ employeeId: z.number() }))
      .query(async ({ input }) => {
        return await db.getEmployeeCompetencies(input.employeeId);
      }),
  }),

  // Router de Planos de Sucessão
  successionPlans: router({
    list: protectedProcedure.query(async () => {
      const database = await getDb();
      if (!database) return [];

      // Buscar planos de sucessão com informações relacionadas
      const plans = await database.select()
        .from(successionPlans)
        .orderBy(desc(successionPlans.createdAt));

      return plans;
    }),
  }),

  // Router de Testes Psicométricos
  psychometric: router({
    // Buscar perguntas de um teste específico (PÚBLICO - sem necessidade de login)
    getQuestionsPublic: publicProcedure
      .input(z.object({ testType: z.enum(["disc", "bigfive", "mbti", "ie", "vark", "leadership", "careeranchors"]) }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) return [];

        const questions = await database.select()
          .from(testQuestions)
          .where(eq(testQuestions.testType, input.testType))
          .orderBy(testQuestions.questionNumber);

        return questions;
      }),

    // Buscar perguntas de um teste específico (PROTEGIDO - requer login)
    getQuestions: protectedProcedure
      .input(z.object({ testType: z.enum(["disc", "bigfive", "mbti", "ie", "vark", "leadership", "careeranchors"]) }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) return [];

        const questions = await database.select()
          .from(testQuestions)
          .where(eq(testQuestions.testType, input.testType))
          .orderBy(testQuestions.questionNumber);

        return questions;
      }),

    // Submeter respostas de um teste (PÚBLICO - sem necessidade de login)
    submitTestPublic: publicProcedure
      .input(z.object({
        testType: z.enum(["disc", "bigfive", "mbti", "ie", "vark", "leadership", "careeranchors"]),
        email: z.string().email(),
        responses: z.array(z.object({
          questionId: z.number(),
          score: z.number().min(1).max(5),
        })),
      }))
      .mutation(async ({ input }) => {
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        // Buscar colaborador pelo email
        const employee = await database.select()
          .from(employees)
          .where(eq(employees.email, input.email))
          .limit(1);

        if (employee.length === 0) {
          throw new Error("Email não encontrado. Por favor, verifique se o email está correto.");
        }

        // Calcular perfil baseado nas respostas
        const profile = await calculateProfile(input.testType, input.responses, database);

        // Preparar valores para inserção
        const testValues: any = {
          employeeId: employee[0].id,
          testType: input.testType,
          completedAt: new Date(),
          responses: JSON.stringify(input.responses),
        };

        // Adicionar scores específicos baseado no tipo de teste
        if (input.testType === "disc") {
          testValues.discDominance = Math.round((profile.D || 0) * 20);
          testValues.discInfluence = Math.round((profile.I || 0) * 20);
          testValues.discSteadiness = Math.round((profile.S || 0) * 20);
          testValues.discCompliance = Math.round((profile.C || 0) * 20);
          const maxDimension = Object.entries(profile).reduce((a, b) => a[1] > b[1] ? a : b)[0];
          testValues.discProfile = maxDimension;
        } else if (input.testType === "bigfive") {
          testValues.bigFiveOpenness = Math.round((profile.O || 0) * 20);
          testValues.bigFiveConscientiousness = Math.round((profile.C || 0) * 20);
          testValues.bigFiveExtraversion = Math.round((profile.E || 0) * 20);
          testValues.bigFiveAgreeableness = Math.round((profile.A || 0) * 20);
          testValues.bigFiveNeuroticism = Math.round((profile.N || 0) * 20);
        }

        // Salvar teste no banco
        await database.insert(psychometricTests).values(testValues);

        return { success: true, profile, employeeName: employee[0].name };
      }),

    // Submeter respostas de um teste (PROTEGIDO - requer login)
    submitTest: protectedProcedure
      .input(z.object({
        testType: z.enum(["disc", "bigfive", "mbti", "ie", "vark", "leadership", "careeranchors"]),
        responses: z.array(z.object({
          questionId: z.number(),
          score: z.number().min(1).max(5),
        })),
      }))
      .mutation(async ({ input, ctx }) => {
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        // Buscar colaborador do usuário
        const employee = await database.select()
          .from(employees)
          .where(eq(employees.userId, ctx.user.id))
          .limit(1);

        if (employee.length === 0) {
          throw new Error("Colaborador não encontrado");
        }

        // Calcular perfil baseado nas respostas
        const profile = await calculateProfile(input.testType, input.responses, database);

        // Preparar valores para inserção
        const testValues: any = {
          employeeId: employee[0].id,
          testType: input.testType,
          completedAt: new Date(),
          responses: JSON.stringify(input.responses),
        };

        // Adicionar scores específicos baseado no tipo de teste
        if (input.testType === "disc") {
          testValues.discDominance = Math.round((profile.D || 0) * 20); // Converter 1-5 para 0-100
          testValues.discInfluence = Math.round((profile.I || 0) * 20);
          testValues.discSteadiness = Math.round((profile.S || 0) * 20);
          testValues.discCompliance = Math.round((profile.C || 0) * 20);
          // Determinar perfil dominante
          const maxDimension = Object.entries(profile).reduce((a, b) => a[1] > b[1] ? a : b)[0];
          testValues.discProfile = maxDimension;
        } else if (input.testType === "bigfive") {
          testValues.bigFiveOpenness = Math.round((profile.O || 0) * 20);
          testValues.bigFiveConscientiousness = Math.round((profile.C || 0) * 20);
          testValues.bigFiveExtraversion = Math.round((profile.E || 0) * 20);
          testValues.bigFiveAgreeableness = Math.round((profile.A || 0) * 20);
          testValues.bigFiveNeuroticism = Math.round((profile.N || 0) * 20);
        }

        // Salvar teste no banco
        await database.insert(psychometricTests).values(testValues);

        // Criar notificação para gestores/RH
        try {
          // Buscar gestor do colaborador
          if (employee[0].managerId) {
            const manager = await database.select()
              .from(employees)
              .where(eq(employees.id, employee[0].managerId))
              .limit(1);

            if (manager.length > 0 && manager[0].userId) {
              await createNotification({
                userId: manager[0].userId,
                type: "test_completed",
                title: "Teste Psicométrico Concluído",
                message: `${employee[0].name} completou o teste ${input.testType.toUpperCase()}`,
                link: `/testes/resultados-rh`,
              });
            }
          }
        } catch (error) {
          console.error("Erro ao criar notificação:", error);
          // Não falhar a operação principal se notificação falhar
        }

        return { success: true, profile };
      }),

    // Buscar TODOS os testes (apenas RH/Admin)
    getAllTests: protectedProcedure.query(async ({ ctx }) => {
      const database = await getDb();
      if (!database) return [];

      // Verificar se é RH/Admin
      const employee = await database.select()
        .from(employees)
        .where(eq(employees.userId, ctx.user.id))
        .limit(1);

      // TODO: Verificar role quando campo estiver disponível no schema de employees
      // if (employee.length === 0 || (employee[0].role !== 'admin' && employee[0].role !== 'rh')) {
      //   throw new TRPCError({
      //     code: "FORBIDDEN",
      //     message: "Apenas RH e Administradores podem visualizar todos os testes",
      //   });
      // }

      // Buscar todos os testes com informações do colaborador
      const tests = await database.select({
        id: psychometricTests.id,
        employeeId: psychometricTests.employeeId,
        employeeName: employees.name,
        employeeDepartmentId: employees.departmentId,
        employeeDepartmentName: departments.name,
        testType: psychometricTests.testType,
        discProfile: psychometricTests.discProfile,
        discDominance: psychometricTests.discDominance,
        discInfluence: psychometricTests.discInfluence,
        discSteadiness: psychometricTests.discSteadiness,
        discCompliance: psychometricTests.discCompliance,
        bigFiveOpenness: psychometricTests.bigFiveOpenness,
        bigFiveConscientiousness: psychometricTests.bigFiveConscientiousness,
        bigFiveExtraversion: psychometricTests.bigFiveExtraversion,
        bigFiveAgreeableness: psychometricTests.bigFiveAgreeableness,
        bigFiveNeuroticism: psychometricTests.bigFiveNeuroticism,
        completedAt: psychometricTests.completedAt,
        createdAt: psychometricTests.createdAt,
      })
        .from(psychometricTests)
        .leftJoin(employees, eq(psychometricTests.employeeId, employees.id))
        .leftJoin(departments, eq(employees.departmentId, departments.id))
        .where(sql`${psychometricTests.completedAt} IS NOT NULL`)
        .orderBy(desc(psychometricTests.completedAt));

      return tests;
    }),

    // Buscar testes de um colaborador
    getTests: protectedProcedure.query(async ({ ctx }) => {
      const database = await getDb();
      if (!database) return [];

      // Buscar colaborador do usuário
      const employee = await database.select()
        .from(employees)
        .where(eq(employees.userId, ctx.user.id))
        .limit(1);

      if (employee.length === 0) return [];

      const tests = await database.select()
        .from(psychometricTests)
        .where(eq(psychometricTests.employeeId, employee[0].id))
        .orderBy(desc(psychometricTests.completedAt));

      return tests.map(test => {
        // Reconstruir perfil a partir dos campos individuais
        let profile: any = null;
        if (test.testType === "disc") {
          profile = {
            D: test.discDominance ? test.discDominance / 20 : 0,
            I: test.discInfluence ? test.discInfluence / 20 : 0,
            S: test.discSteadiness ? test.discSteadiness / 20 : 0,
            C: test.discCompliance ? test.discCompliance / 20 : 0,
            dominantProfile: test.discProfile,
          };
        } else if (test.testType === "bigfive") {
          profile = {
            O: test.bigFiveOpenness ? test.bigFiveOpenness / 20 : 0,
            C: test.bigFiveConscientiousness ? test.bigFiveConscientiousness / 20 : 0,
            E: test.bigFiveExtraversion ? test.bigFiveExtraversion / 20 : 0,
            A: test.bigFiveAgreeableness ? test.bigFiveAgreeableness / 20 : 0,
            N: test.bigFiveNeuroticism ? test.bigFiveNeuroticism / 20 : 0,
          };
        } else if (test.testType === "mbti" || test.testType === "ie" || test.testType === "vark") {
          // Para novos testes, retornar profile vazio por enquanto
          // TODO: Implementar cálculo de perfil para MBTI, IE e VARK
          profile = {};
        }
        return { ...test, profile };
      });
    }),

    // Enviar convite para teste psicométrico por email
    sendTestInvite: protectedProcedure
      .input(z.object({
        emails: z.array(z.string().email()),
        testType: z.enum(["disc", "bigfive", "mbti", "ie", "vark", "leadership", "careeranchors"]),
      }))
      .mutation(async ({ input, ctx }) => {
        // Verificar se é admin
        if (ctx.user.role !== "admin") {
          throw new Error("Acesso negado: apenas administradores");
        }

        const { createTestInviteEmail, testInfo } = await import("./utils/testInviteTemplate");
        const { emailService } = await import("./utils/emailService");
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        const results = [];
        const testData = testInfo[input.testType];

        for (const email of input.emails) {
          // Buscar colaborador pelo email
          const employee = await database.select()
            .from(employees)
            .where(eq(employees.email, email))
            .limit(1);

          if (employee.length === 0) {
            results.push({ email, success: false, message: "Colaborador não encontrado" });
            continue;
          }

          // Usar URL base do ambiente (funciona tanto em dev quanto em produção)
          const baseUrl = process.env.VITE_APP_URL || ctx.req.headers.origin || `${ctx.req.protocol}://${ctx.req.get('host')}`;
          const testUrl = `${baseUrl}/teste-${input.testType}`;
          
          const emailTemplate = createTestInviteEmail({
            employeeName: employee[0].name,
            testType: testData.type,
            testName: testData.name,
            testDescription: testData.description,
            estimatedTime: testData.estimatedTime,
            testUrl,
          });

          // Enviar email usando o emailService
          const sent = await emailService.sendCustomEmail(
            email,
            emailTemplate.subject,
            emailTemplate.html
          );

          results.push({
            email,
            success: sent,
            message: sent ? "Convite enviado com sucesso" : "Erro ao enviar email",
          });
        }

        return { results };
      }),

    // Buscar resultados agregados por equipe/departamento/cargo
    getAggregatedResults: protectedProcedure
      .input(z.object({
        groupBy: z.enum(["department", "position", "team"]),
        testType: z.enum(["disc", "bigfive", "mbti", "ie", "vark", "leadership", "careeranchors"]).optional(),
      }))
      .query(async ({ input, ctx }) => {
        const database = await getDb();
        if (!database) return [];

        // Buscar todos os testes
        const testsQuery = database.select({
          test: psychometricTests,
          employee: employees,
          department: departments,
          position: positions,
        })
          .from(psychometricTests)
          .leftJoin(employees, eq(psychometricTests.employeeId, employees.id))
          .leftJoin(departments, eq(employees.departmentId, departments.id))
          .leftJoin(positions, eq(employees.positionId, positions.id));

        const tests = input.testType 
          ? await testsQuery.where(eq(psychometricTests.testType, input.testType))
          : await testsQuery;

        // Agrupar por critério
        const grouped: Record<string, any[]> = {};
        for (const item of tests) {
          let groupKey = "";
          let groupName = "";

          if (input.groupBy === "department" && item.department) {
            groupKey = item.department.id.toString();
            groupName = item.department.name;
          } else if (input.groupBy === "position" && item.position) {
            groupKey = item.position.id.toString();
            groupName = item.position.title;
          } else if (input.groupBy === "team" && item.employee?.managerId) {
            groupKey = item.employee.managerId.toString();
            groupName = `Equipe ${item.employee.managerId}`;
          } else {
            continue;
          }

          if (!grouped[groupKey]) {
            grouped[groupKey] = [];
          }
          grouped[groupKey].push({ ...item.test, groupName });
        }

        // Calcular médias por grupo
        const results = [];
        for (const [groupKey, groupTests] of Object.entries(grouped)) {
          const groupName = groupTests[0]?.groupName || "Sem nome";
          const testsByType: Record<string, any[]> = {};

          // Agrupar por tipo de teste
          for (const test of groupTests) {
            if (!testsByType[test.testType]) {
              testsByType[test.testType] = [];
            }
            testsByType[test.testType].push(test);
          }

          // Calcular médias por tipo
          const averages: Record<string, any> = {};
          for (const [testType, testList] of Object.entries(testsByType)) {
            if (testType === "disc") {
              averages.disc = {
                D: testList.reduce((sum, t) => sum + (t.discD || 0), 0) / testList.length,
                I: testList.reduce((sum, t) => sum + (t.discI || 0), 0) / testList.length,
                S: testList.reduce((sum, t) => sum + (t.discS || 0), 0) / testList.length,
                C: testList.reduce((sum, t) => sum + (t.discC || 0), 0) / testList.length,
              };
            } else if (testType === "bigfive") {
              averages.bigfive = {
                O: testList.reduce((sum, t) => sum + (t.bigFiveOpenness || 0), 0) / testList.length / 20,
                C: testList.reduce((sum, t) => sum + (t.bigFiveConscientiousness || 0), 0) / testList.length / 20,
                E: testList.reduce((sum, t) => sum + (t.bigFiveExtraversion || 0), 0) / testList.length / 20,
                A: testList.reduce((sum, t) => sum + (t.bigFiveAgreeableness || 0), 0) / testList.length / 20,
                N: testList.reduce((sum, t) => sum + (t.bigFiveNeuroticism || 0), 0) / testList.length / 20,
              };
            }
            // TODO: Adicionar cálculos para outros tipos de teste
          }

          results.push({
            groupKey,
            groupName,
            count: groupTests.length,
            averages,
          });
        }

        return results;
      }),

    // Gerar recomendações de PDI baseadas em testes psicométricos
    getPDIRecommendations: protectedProcedure
      .input(z.object({
        employeeId: z.number(),
      }))
      .query(async ({ input, ctx }) => {
        const database = await getDb();
        if (!database) return [];

        // Buscar todos os testes do funcionário
        const tests = await database.select()
          .from(psychometricTests)
          .where(eq(psychometricTests.employeeId, input.employeeId))
          .orderBy(desc(psychometricTests.completedAt));

        if (tests.length === 0) {
          return [];
        }

        // Importar funções de recomendação
        const { generateConsolidatedRecommendations } = await import("./utils/pdiRecommendations");

        // Preparar perfis dos testes mais recentes
        const latestTests: any = {};
        
        for (const test of tests) {
          if (!latestTests[test.testType]) {
            if (test.testType === "disc") {
              latestTests.disc = {
                D: test.discDominance || 0,
                I: test.discInfluence || 0,
                S: test.discSteadiness || 0,
                C: test.discCompliance || 0,
              };
            } else if (test.testType === "bigfive") {
              latestTests.bigfive = {
                O: (test.bigFiveOpenness || 0) / 20,
                C: (test.bigFiveConscientiousness || 0) / 20,
                E: (test.bigFiveExtraversion || 0) / 20,
                A: (test.bigFiveAgreeableness || 0) / 20,
                N: (test.bigFiveNeuroticism || 0) / 20,
              };
            }
            // TODO: Adicionar outros tipos de teste
          }
        }

        // Gerar recomendações consolidadas
        const recommendations = generateConsolidatedRecommendations(latestTests);

        return recommendations;
      }),
  }),

  // Router de Administração (apenas admin)
  admin: router({
    // Buscar configurações SMTP
    getSmtpConfig: protectedProcedure.query(async ({ ctx }) => {
      // Verificar se é admin
      if (ctx.user.role !== "admin") {
        throw new Error("Acesso negado: apenas administradores");
      }

      const database = await getDb();
      if (!database) return null;

      const settings = await database.select()
        .from(systemSettings)
        .where(eq(systemSettings.settingKey, "smtp_config"))
        .limit(1);

      if (settings.length === 0) return null;

      // Parse do JSON armazenado
      const config = settings[0].settingValue ? JSON.parse(settings[0].settingValue) : null;
      return config;
    }),

    // Atualizar configurações SMTP
    updateSmtpConfig: protectedProcedure
      .input(z.object({
        host: z.string().min(1),
        port: z.number().min(1).max(65535),
        secure: z.boolean(),
        user: z.string().min(1),
        pass: z.string().min(1),
        fromName: z.string().min(1),
        fromEmail: z.string().email(),
      }))
      .mutation(async ({ input, ctx }) => {
        // Verificar se é admin
        if (ctx.user.role !== "admin") {
          throw new Error("Acesso negado: apenas administradores");
        }

        const database = await getDb();
        if (!database) throw new Error("Database not available");

        // Verificar se já existe configuração
        const existing = await database.select()
          .from(systemSettings)
          .where(eq(systemSettings.settingKey, "smtp_config"))
          .limit(1);

        const configJson = JSON.stringify(input);

        if (existing.length > 0) {
          // Atualizar
          await database.update(systemSettings)
            .set({
              settingValue: configJson,
              updatedBy: ctx.user.id,
              updatedAt: new Date(),
            })
            .where(eq(systemSettings.settingKey, "smtp_config"));
        } else {
          // Inserir
          await database.insert(systemSettings).values({
            settingKey: "smtp_config",
            settingValue: configJson,
            description: "Configurações do servidor SMTP para envio de e-mails",
            isEncrypted: false,
            updatedBy: ctx.user.id,
          });
        }

        return { success: true };
      }),

    // Testar conexão SMTP
    testSmtpConnection: protectedProcedure
      .input(z.object({
        host: z.string().min(1),
        port: z.number().min(1).max(65535),
        secure: z.boolean(),
        user: z.string().min(1),
        pass: z.string().min(1),
        fromName: z.string().min(1),
        fromEmail: z.string().email(),
        testEmail: z.string().email(),
      }))
      .mutation(async ({ input, ctx }) => {
        // Verificar se é admin
        if (ctx.user.role !== "admin") {
          throw new Error("Acesso negado: apenas administradores");
        }

        const nodemailer = require("nodemailer");

        try {
          // Criar transporter com as configurações fornecidas
          const transporter = nodemailer.createTransport({
            host: input.host,
            port: input.port,
            secure: input.secure,
            auth: {
              user: input.user,
              pass: input.pass,
            },
          });

          // Verificar conexão
          await transporter.verify();

          // Enviar e-mail de teste
          await transporter.sendMail({
            from: `"${input.fromName}" <${input.fromEmail}>`,
            to: input.testEmail,
            subject: "Teste de Configuração SMTP - Sistema AVD UISA",
            html: `
              <h2>Teste de Configuração SMTP</h2>
              <p>Este é um e-mail de teste enviado pelo Sistema AVD UISA.</p>
              <p>Se você recebeu esta mensagem, significa que as configurações SMTP estão corretas!</p>
              <hr>
              <p><small>Servidor: ${input.host}:${input.port}</small></p>
              <p><small>Data/Hora: ${new Date().toLocaleString("pt-BR")}</small></p>
            `,
          });

          return { success: true, message: "E-mail de teste enviado com sucesso!" };
        } catch (error: any) {
          console.error("[SMTP Test] Erro:", error);
          return { success: false, message: error.message || "Erro ao testar conexão SMTP" };
        }
      }),

    // Buscar métricas de e-mail
    getEmailMetrics: protectedProcedure
      .input(z.object({
        startDate: z.string().optional(),
        endDate: z.string().optional(),
        limit: z.number().optional(),
      }))
      .query(async ({ ctx, input }) => {
        // Verificar se é admin
        if (ctx.user.role !== "admin") {
          throw new Error("Acesso negado: apenas administradores");
        }

        const database = await getDb();
        if (!database) return [];

        // Buscar métricas com filtros opcionais
        const metrics = await database.select()
          .from(emailMetrics)
          .orderBy(desc(emailMetrics.sentAt))
          .limit(input.limit || 1000);

        return metrics;
      }),

    // Buscar estatísticas agregadas de e-mail
    getEmailStats: protectedProcedure.query(async ({ ctx }) => {
      // Verificar se é admin
      if (ctx.user.role !== "admin") {
        throw new Error("Acesso negado: apenas administradores");
      }

      const database = await getDb();
      if (!database) return null;

      // Buscar todas as métricas
      const allMetrics = await database.select().from(emailMetrics);

      // Calcular estatísticas
      const total = allMetrics.length;
      const successful = allMetrics.filter(m => m.success).length;
      const failed = total - successful;
      const successRate = total > 0 ? (successful / total) * 100 : 0;

      // Agrupar por tipo
      const byType: Record<string, number> = {};
      allMetrics.forEach(m => {
        byType[m.type] = (byType[m.type] || 0) + 1;
      });

      // Agrupar por mês (últimos 12 meses)
      const monthlyData: Record<string, { sent: number; success: number; failed: number }> = {};
      const now = new Date();
      const twelveMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 11, 1);

      allMetrics.forEach(m => {
        const sentDate = new Date(m.sentAt);
        if (sentDate >= twelveMonthsAgo) {
          const monthKey = `${sentDate.getFullYear()}-${String(sentDate.getMonth() + 1).padStart(2, '0')}`;
          if (!monthlyData[monthKey]) {
            monthlyData[monthKey] = { sent: 0, success: 0, failed: 0 };
          }
          monthlyData[monthKey].sent++;
          if (m.success) {
            monthlyData[monthKey].success++;
          } else {
            monthlyData[monthKey].failed++;
          }
        }
      });

      // Converter para array ordenado
      const monthlyArray = Object.entries(monthlyData)
        .map(([month, data]) => ({ month, ...data }))
        .sort((a, b) => a.month.localeCompare(b.month));

      return {
        total,
        successful,
        failed,
        successRate: Math.round(successRate * 10) / 10,
        byType,
        monthlyData: monthlyArray,
      };
    }),
  }),

  // Router de Calibração
  calibration: router({
    // Listar avaliações para calibração
    getEvaluations: protectedProcedure
      .input(z.object({
        cycleId: z.number().optional(),
        departmentId: z.number().optional(),
      }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) return [];

        const evals = await database.select()
          .from(performanceEvaluations)
          .orderBy(desc(performanceEvaluations.createdAt))
          .limit(100);

        return evals;
      }),

    // Criar sessão de calibração
    createSession: protectedProcedure
      .input(z.object({
        cycleId: z.number(),
        departmentId: z.number().optional(),
        scheduledDate: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        const [session] = await database.insert(calibrationSessions).values({
          cycleId: input.cycleId,
          departmentId: input.departmentId,
          facilitatorId: ctx.user.id,
          scheduledDate: input.scheduledDate ? new Date(input.scheduledDate) : undefined,
        });

        return { success: true, sessionId: session.insertId };
      }),

    // Salvar calibração
    saveCalibration: protectedProcedure
      .input(z.object({
        sessionId: z.number(),
        evaluationId: z.number(),
        originalScore: z.number(),
        calibratedScore: z.number(),
        reason: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        // Salvar review de calibração
        await database.insert(calibrationReviews).values({
          sessionId: input.sessionId,
          evaluationId: input.evaluationId,
          originalScore: input.originalScore,
          calibratedScore: input.calibratedScore,
          reason: input.reason,
          reviewedBy: ctx.user.id,
        });

        // Atualizar nota final da avaliação
        await database.update(performanceEvaluations)
          .set({ finalScore: input.calibratedScore })
          .where(eq(performanceEvaluations.id, input.evaluationId));

        return { success: true };
      }),

    // Buscar histórico de calibrações
    getHistory: protectedProcedure
      .input(z.object({ evaluationId: z.number() }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) return [];

        const history = await database.select()
          .from(calibrationReviews)
          .where(eq(calibrationReviews.evaluationId, input.evaluationId))
          .orderBy(desc(calibrationReviews.createdAt));

        return history;
      }),
  }),

  // Router de Audit Trail (apenas admin)
  auditTrail: router({
    // Buscar logs de auditoria com filtros
    getLogs: protectedProcedure
      .input(z.object({
        userId: z.number().optional(),
        action: z.string().optional(),
        entity: z.string().optional(),
        startDate: z.string().optional(),
        endDate: z.string().optional(),
        limit: z.number().default(100),
        offset: z.number().default(0),
      }))
      .query(async ({ input, ctx }) => {
        // Apenas admin pode acessar
        if (ctx.user.role !== "admin") {
          throw new Error("Acesso negado");
        }

        const database = await getDb();
        if (!database) return { logs: [], total: 0 };

        // Construir condições de filtro
        const conditions: any[] = [];
        if (input.userId) conditions.push(eq(auditLogs.userId, input.userId));
        if (input.action) conditions.push(eq(auditLogs.action, input.action));
        if (input.entity) conditions.push(eq(auditLogs.entity, input.entity));
        
        // Buscar logs
        const logs = await database.select()
          .from(auditLogs)
          .where(conditions.length > 0 ? and(...conditions) : undefined)
          .orderBy(desc(auditLogs.createdAt))
          .limit(input.limit)
          .offset(input.offset);

        // Contar total
        const totalResult = await database.select()
          .from(auditLogs)
          .where(conditions.length > 0 ? and(...conditions) : undefined);

        return { logs, total: totalResult.length };
      }),

    // Buscar detalhes de um log específico
    getLogDetails: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input, ctx }) => {
        if (ctx.user.role !== "admin") {
          throw new Error("Acesso negado");
        }

        const database = await getDb();
        if (!database) return null;

        const log = await database.select()
          .from(auditLogs)
          .where(eq(auditLogs.id, input.id))
          .limit(1);

        return log.length > 0 ? log[0] : null;
      }),
  }),

  // Router de Analytics (apenas admin)
  analytics: analyticsRouter,

  // Router de Feedback Contínuo
  feedback: feedbackRouter,

  // Router de Badges Gamificado
  badges: badgesRouter,

  // Router de Relatórios Agendados (apenas admin)
  scheduledReports: scheduledReportsRouter,

  // Router de Dashboard Executivo (apenas admin)
  executive: executiveRouter,

  // Router de Mapa de Sucessão
  succession: successionRouter,

  // Router de PDI Inteligente
  pdiIntelligent: pdiIntelligentRouter,

  // Router de Nine Box Comparativo
  nineBoxComparative: nineBoxRouter,
  
  // Router de Avaliação 360° com Fluxo Sequencial
  evaluation360: evaluation360Router,
  
  reportBuilder: reportBuilderRouter,
  reportAnalytics: reportAnalyticsRouter,
  
  // Router de Metas SMART
  smartGoals: goalsRouter,
  bonus: bonusRouter,
  calibrationDiretoria: calibrationRouter,
  gamification: gamificationRouter,
  integrations: integrationsRouter,

  // Router de Notificações
  notifications: router({
    // Buscar notificações do usuário
    list: protectedProcedure
      .input(z.object({
        limit: z.number().optional().default(50),
        unreadOnly: z.boolean().optional().default(false),
      }))
      .query(async ({ ctx, input }) => {
        const database = await getDb();
        if (!database) return [];

        const conditions = [eq(notifications.userId, ctx.user.id)];
        if (input.unreadOnly) {
          conditions.push(eq(notifications.read, false));
        }

        const results = await database.select()
          .from(notifications)
          .where(and(...conditions))
          .orderBy(desc(notifications.createdAt))
          .limit(input.limit);

        return results;
      }),

    // Contar notificações não lidas
    countUnread: protectedProcedure
      .query(async ({ ctx }) => {
        const database = await getDb();
        if (!database) return 0;

        const [result] = await database.select({ count: sql<number>`count(*)` })
          .from(notifications)
          .where(and(
            eq(notifications.userId, ctx.user.id),
            eq(notifications.read, false)
          ));

        return result?.count || 0;
      }),

    // Marcar como lida
    markAsRead: protectedProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ ctx, input }) => {
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        await database.update(notifications)
          .set({ read: true, readAt: new Date() })
          .where(and(
            eq(notifications.id, input.id),
            eq(notifications.userId, ctx.user.id)
          ));

        return { success: true };
      }),

    // Marcar todas como lidas
    markAllAsRead: protectedProcedure
      .mutation(async ({ ctx }) => {
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        await database.update(notifications)
          .set({ read: true, readAt: new Date() })
          .where(and(
            eq(notifications.userId, ctx.user.id),
            eq(notifications.read, false)
          ));

        return { success: true };
      }),

    // Criar notificação (apenas admin)
    create: protectedProcedure
      .input(z.object({
        userId: z.number(),
        type: z.string(),
        title: z.string(),
        message: z.string(),
        link: z.string().optional(),
      }))
      .mutation(async ({ ctx, input }) => {
        if (ctx.user.role !== "admin") {
          throw new Error("Apenas administradores podem criar notificações");
        }

        const notification = await createNotification(input);
        return notification;
      }),
  }),

  // Router de Emails
  emails: router({
    // Buscar métricas de emails
    getMetrics: protectedProcedure.query(async ({ ctx }) => {
      if (ctx.user.role !== "admin" && ctx.user.role !== "rh") {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Acesso negado",
        });
      }

      const database = await getDb();
      if (!database) return { total: 0, sent: 0, failed: 0, pending: 0 };

      const allMetrics = await database.select().from(emailMetrics);

      const total = allMetrics.length;
      const sent = allMetrics.filter(m => m.success).length;
      const failed = allMetrics.filter(m => !m.success).length;
      const pending = 0; // TODO: implementar fila de emails pendentes

      return { total, sent, failed, pending };
    }),

    // Buscar histórico de emails
    getHistory: protectedProcedure.query(async ({ ctx }) => {
      if (ctx.user.role !== "admin" && ctx.user.role !== "rh") {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Acesso negado",
        });
      }

      const database = await getDb();
      if (!database) return [];

      const history = await database.select()
        .from(emailMetrics)
        .orderBy(desc(emailMetrics.sentAt))
        .limit(500);

      return history.map(email => ({
        id: email.id,
        recipient: email.toEmail,
        subject: email.subject,
        emailType: email.type,
        status: email.success ? "sent" : "failed",
        sentAt: email.sentAt,
        createdAt: email.sentAt,
        errorMessage: email.error,
      }));
    }),

    // Reenviar email falhado
    resend: protectedProcedure
      .input(z.object({ emailId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        if (ctx.user.role !== "admin" && ctx.user.role !== "rh") {
          throw new TRPCError({
            code: "FORBIDDEN",
            message: "Acesso negado",
          });
        }

        const database = await getDb();
        if (!database) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Banco de dados indisponível",
          });
        }

        // Buscar email original
        const originalEmail = await database.select()
          .from(emailMetrics)
          .where(eq(emailMetrics.id, input.emailId))
          .limit(1);

        if (originalEmail.length === 0) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Email não encontrado",
          });
        }

        // TODO: Implementar lógica de reenvio usando emailService
        // Por enquanto, apenas retornar sucesso
        return { success: true, message: "Email reenviado com sucesso" };
      }),
  }),

  // Router de Centros de Custos
  costCenters: router({
    // Listar todos os centros de custos únicos
    list: publicProcedure.query(async () => {
      const database = await getDb();
      if (!database) return [];

      // Buscar valores únicos de costCenter da tabela employees
      const result = await database.selectDistinct({ costCenter: employees.costCenter })
        .from(employees)
        .where(sql`${employees.costCenter} IS NOT NULL AND ${employees.costCenter} != ''`)
        .orderBy(employees.costCenter);

      // Transformar em formato {id, code, name}
      return result.map((r, index) => ({
        id: index + 1,
        code: r.costCenter || '',
        name: r.costCenter || '',
      }));
    }),
  }),

  // ============================================================================
  // E-MAIL
  // ============================================================================
  smtpConfig: router({
    get: protectedProcedure.query(async ({ ctx }) => {
      const db = await getDb();
      if (!db) throw new Error("Database not available");

      // Buscar configuração mais recente
      const configs = await db.select().from(smtpConfig).where(eq(smtpConfig.isActive, true)).orderBy(desc(smtpConfig.createdAt)).limit(1);
      
      return configs.length > 0 ? configs[0] : null;
    }),

    save: protectedProcedure
      .input(z.object({
        host: z.string(),
        port: z.number(),
        secure: z.boolean(),
        user: z.string(),
        password: z.string().optional(),
        fromEmail: z.string().email(),
        fromName: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        const db = await getDb();
        if (!db) throw new Error("Database not available");

        // Desativar configurações antigas
        await db.update(smtpConfig).set({ isActive: false }).where(eq(smtpConfig.isActive, true));

        // Criar nova configuração
        const result = await db.insert(smtpConfig).values({
          host: input.host,
          port: input.port,
          secure: input.secure,
          user: input.user,
          password: input.password || "***", // TODO: Encrypt password
          fromEmail: input.fromEmail,
          fromName: input.fromName,
          isActive: true,
        });

        return { success: true, configId: result[0].insertId };
      }),
  }),

  email: router({
    // Enviar e-mail de teste
    sendTest: protectedProcedure
      .input(z.object({ recipientEmail: z.string().email() }))
      .mutation(async ({ input }) => {
        const { sendTestEmail } = await import('./emailService');
        return await sendTestEmail(input.recipientEmail);
      }),

    // Enviar e-mail de meta
    sendGoalEmail: protectedProcedure
      .input(z.object({
        recipientEmail: z.string().email(),
        recipientName: z.string(),
        goalTitle: z.string(),
        goalDescription: z.string(),
        deadline: z.string(),
        assignedBy: z.string(),
        dashboardUrl: z.string(),
      }))
      .mutation(async ({ input }) => {
        const { sendTemplateEmail } = await import('./emailService');
        const { newGoalTemplate } = await import('./emailTemplates');
        
        const template = newGoalTemplate(input);
        const success = await sendTemplateEmail(input.recipientEmail, template);
        
        return { success, message: success ? 'E-mail enviado com sucesso' : 'Falha ao enviar e-mail' };
      }),

    // Enviar e-mail de resultado de performance
    sendPerformanceEmail: protectedProcedure
      .input(z.object({
        recipientEmail: z.string().email(),
        recipientName: z.string(),
        evaluationPeriod: z.string(),
        overallScore: z.number(),
        performanceLevel: z.string(),
        strengths: z.array(z.string()),
        improvements: z.array(z.string()),
        evaluatorName: z.string(),
        dashboardUrl: z.string(),
      }))
      .mutation(async ({ input }) => {
        const { sendTemplateEmail } = await import('./emailService');
        const { performanceResultTemplate } = await import('./emailTemplates');
        
        const template = performanceResultTemplate(input);
        const success = await sendTemplateEmail(input.recipientEmail, template);
        
        return { success, message: success ? 'E-mail enviado com sucesso' : 'Falha ao enviar e-mail' };
      }),
  }),

  // ============================================================================
  // WORKFLOWS
  // ============================================================================
  workflows: router({
    // Listar todos os workflows
    list: protectedProcedure.query(async () => {
      const database = await getDb();
      if (!database) return [];

      const allWorkflows = await database
        .select()
        .from(workflows)
        .orderBy(desc(workflows.createdAt));

      return allWorkflows;
    }),

    // Criar novo workflow
    create: protectedProcedure
      .input(z.object({
        name: z.string().min(1),
        description: z.string().optional(),
        type: z.enum([
          "aprovacao_metas",
          "aprovacao_pdi",
          "aprovacao_avaliacao",
          "aprovacao_bonus",
          "aprovacao_ferias",
          "aprovacao_promocao",
          "aprovacao_horas_extras",
          "aprovacao_despesas",
          "outro"
        ]),
        steps: z.string(), // JSON stringified
        isActive: z.boolean().optional(),
        isDefault: z.boolean().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        if (!ctx.user) {
          throw new TRPCError({
            code: "UNAUTHORIZED",
            message: "Usuário não autenticado",
          });
        }

        const database = await getDb();
        if (!database) throw new Error("Database not available");

        const employee = await db.getEmployeeByUserId(ctx.user.id);
        if (!employee) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Colaborador não encontrado",
          });
        }

        const [workflow] = await database.insert(workflows).values({
          name: input.name,
          description: input.description || null,
          type: input.type,
          steps: input.steps,
          isActive: input.isActive ?? true,
          isDefault: input.isDefault ?? false,
          createdBy: employee.id,
        });

        return { success: true, workflowId: workflow.insertId };
      }),

    // Atualizar workflow
    update: protectedProcedure
      .input(z.object({
        id: z.number(),
        name: z.string().min(1).optional(),
        description: z.string().optional(),
        steps: z.string().optional(),
        isActive: z.boolean().optional(),
        isDefault: z.boolean().optional(),
      }))
      .mutation(async ({ input }) => {
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        const updateData: any = {};
        if (input.name !== undefined) updateData.name = input.name;
        if (input.description !== undefined) updateData.description = input.description;
        if (input.steps !== undefined) updateData.steps = input.steps;
        if (input.isActive !== undefined) updateData.isActive = input.isActive;
        if (input.isDefault !== undefined) updateData.isDefault = input.isDefault;

        await database.update(workflows)
          .set(updateData)
          .where(eq(workflows.id, input.id));

        return { success: true };
      }),

    // Deletar workflow
    delete: protectedProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        await database.delete(workflows)
          .where(eq(workflows.id, input.id));

        return { success: true };
      }),
  }),

  // ============================================================================
  // CICLOS DE AVALIAÇÃO
  // ============================================================================
  evaluationCycles: router({
    // Listar todos os ciclos
    list: protectedProcedure.query(async () => {
      const database = await getDb();
      if (!database) return [];

      const cycles = await database
        .select()
        .from(evaluationCycles)
        .orderBy(desc(evaluationCycles.year), desc(evaluationCycles.startDate));

      return cycles;
    }),

    // Criar novo ciclo
    create: protectedProcedure
      .input(z.object({
        name: z.string().min(1),
        year: z.number().int().min(2020),
        type: z.enum(["anual", "semestral", "trimestral"]),
        startDate: z.string(), // ISO date string
        endDate: z.string(), // ISO date string
        description: z.string().optional(),
      }))
      .mutation(async ({ input }) => {
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        // Validar datas
        const start = new Date(input.startDate);
        const end = new Date(input.endDate);

        if (start >= end) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "A data de início deve ser anterior à data de fim",
          });
        }

        const [cycle] = await database.insert(evaluationCycles).values({
          name: input.name,
          year: input.year,
          type: input.type,
          startDate: start,
          endDate: end,
          description: input.description || null,
          status: "planejamento",
        });

        return { success: true, cycleId: cycle.insertId };
      }),

    // Ativar ciclo
    activate: protectedProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        await database.update(evaluationCycles)
          .set({ status: "em_andamento" })
          .where(eq(evaluationCycles.id, input.id));

        return { success: true };
      }),

    // Desativar ciclo
    deactivate: protectedProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input }) => {
        const database = await getDb();
        if (!database) throw new Error("Database not available");

        await database.update(evaluationCycles)
          .set({ status: "concluido" })
          .where(eq(evaluationCycles.id, input.id));

        return { success: true };
      }),
  }),
});

// Função auxiliar para calcular perfil psicométrico
async function calculateProfile(
  testType: "disc" | "bigfive" | "mbti" | "ie" | "vark" | "leadership" | "careeranchors",
  responses: Array<{ questionId: number; score: number }>,
  database: any
) {
  // Buscar perguntas com dimensões
  const questions = await database.select()
    .from(testQuestions)
    .where(eq(testQuestions.testType, testType));

  const dimensionScores: Record<string, number[]> = {};

  // Agrupar scores por dimensão
  for (const response of responses) {
    const question = questions.find((q: any) => q.id === response.questionId);
    if (!question) continue;

    const dimension = question.dimension;
    if (!dimensionScores[dimension]) dimensionScores[dimension] = [];

    // Inverter score se a pergunta for reversa
    const score = question.reverse ? (6 - response.score) : response.score;
    dimensionScores[dimension].push(score);
  }

  // Calcular médias por dimensão
  const profile: Record<string, number> = {};
  for (const [dimension, scores] of Object.entries(dimensionScores)) {
    const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
    profile[dimension] = Math.round(avg * 10) / 10; // Arredondar para 1 casa decimal
  }

  return profile;
}

// ============================================================================
// ROUTER DE NOTIFICAÇÕES
// ============================================================================

async function createNotification(data: {
  userId: number;
  type: string;
  title: string;
  message: string;
  link?: string;
}) {
  const database = await getDb();
  if (!database) return null;

  const [notification] = await database.insert(notifications).values({
    userId: data.userId,
    type: data.type,
    title: data.title,
    message: data.message,
    link: data.link,
    read: false,
  }).$returningId();

  return notification;
}

export type AppRouter = typeof appRouter;

==================================================================
## BACKEND - DATABASE
==================================================================

import { and, desc, eq, gte, lte, sql } from "drizzle-orm";
import { drizzle } from "drizzle-orm/mysql2";
import {
  auditLogs,
  departments,
  developmentActions,
  employeeCompetencies,
  employees,
  evaluationCycles,
  goals,
  InsertUser,
  nineBoxPositions,
  pdiItems,
  pdiPlans,
  performanceEvaluations,
  positions,
  users,
} from "../drizzle/schema";
import { ENV } from "./_core/env";

let _db: ReturnType<typeof drizzle> | null = null;

export async function getDb() {
  if (!_db && process.env.DATABASE_URL) {
    try {
      _db = drizzle(process.env.DATABASE_URL);
    } catch (error) {
      console.warn("[Database] Failed to connect:", error);
      _db = null;
    }
  }
  return _db;
}

// ============================================================================
// USUÁRIOS E AUTENTICAÇÃO
// ============================================================================

export async function upsertUser(user: InsertUser): Promise<void> {
  if (!user.openId) {
    throw new Error("User openId is required for upsert");
  }

  const db = await getDb();
  if (!db) {
    console.warn("[Database] Cannot upsert user: database not available");
    return;
  }

  try {
    const values: InsertUser = {
      openId: user.openId,
    };
    const updateSet: Record<string, unknown> = {};

    const textFields = ["name", "email", "loginMethod"] as const;
    type TextField = (typeof textFields)[number];

    const assignNullable = (field: TextField) => {
      const value = user[field];
      if (value === undefined) return;
      const normalized = value ?? null;
      values[field] = normalized;
      updateSet[field] = normalized;
    };

    textFields.forEach(assignNullable);

    if (user.lastSignedIn !== undefined) {
      values.lastSignedIn = user.lastSignedIn;
      updateSet.lastSignedIn = user.lastSignedIn;
    }
    if (user.role !== undefined) {
      values.role = user.role;
      updateSet.role = user.role;
    } else if (user.openId === ENV.ownerOpenId) {
      values.role = "admin";
      updateSet.role = "admin";
    }

    if (!values.lastSignedIn) {
      values.lastSignedIn = new Date();
    }

    if (Object.keys(updateSet).length === 0) {
      updateSet.lastSignedIn = new Date();
    }

    await db.insert(users).values(values).onDuplicateKeyUpdate({
      set: updateSet,
    });
  } catch (error) {
    console.error("[Database] Failed to upsert user:", error);
    throw error;
  }
}

export async function getUserByOpenId(openId: string) {
  const db = await getDb();
  if (!db) {
    console.warn("[Database] Cannot get user: database not available");
    return undefined;
  }

  const result = await db.select().from(users).where(eq(users.openId, openId)).limit(1);
  return result.length > 0 ? result[0] : undefined;
}

export async function getUserById(id: number) {
  const db = await getDb();
  if (!db) return undefined;

  const result = await db.select().from(users).where(eq(users.id, id)).limit(1);
  return result.length > 0 ? result[0] : undefined;
}

export async function getUserByEmail(email: string) {
  const db = await getDb();
  if (!db) return undefined;

  const result = await db.select().from(users).where(eq(users.email, email)).limit(1);
  return result.length > 0 ? result[0] : undefined;
}

// ============================================================================
// COLABORADORES
// ============================================================================

export async function getAllEmployees() {
  const db = await getDb();
  if (!db) return [];

  return await db
    .select({
      employee: employees,
      department: departments,
      position: positions,
    })
    .from(employees)
    .leftJoin(departments, eq(employees.departmentId, departments.id))
    .leftJoin(positions, eq(employees.positionId, positions.id))
    .where(eq(employees.status, "ativo"))
    .orderBy(employees.name);
}

export async function getEmployeeById(id: number) {
  const db = await getDb();
  if (!db) return undefined;

  const result = await db
    .select({
      employee: employees,
      department: departments,
      position: positions,
    })
    .from(employees)
    .leftJoin(departments, eq(employees.departmentId, departments.id))
    .leftJoin(positions, eq(employees.positionId, positions.id))
    .where(eq(employees.id, id))
    .limit(1);

  return result.length > 0 ? result[0] : undefined;
}

export async function getEmployeeByUserId(userId: number) {
  const db = await getDb();
  if (!db) return undefined;

  const result = await db
    .select()
    .from(employees)
    .where(eq(employees.userId, userId))
    .limit(1);

  return result.length > 0 ? result[0] : undefined;
}

// ============================================================================
// METAS
// ============================================================================

export async function getGoalsByEmployee(employeeId: number, cycleId?: number) {
  const db = await getDb();
  if (!db) return [];

  const conditions = [eq(goals.employeeId, employeeId)];
  if (cycleId) {
    conditions.push(eq(goals.cycleId, cycleId));
  }

  return await db
    .select()
    .from(goals)
    .where(and(...conditions))
    .orderBy(desc(goals.createdAt));
}

export async function getGoalById(id: number) {
  const db = await getDb();
  if (!db) return undefined;

  const result = await db.select().from(goals).where(eq(goals.id, id)).limit(1);
  return result.length > 0 ? result[0] : undefined;
}

// ============================================================================
// AVALIAÇÕES 360°
// ============================================================================

export async function getEvaluationsByEmployee(employeeId: number, cycleId?: number) {
  const db = await getDb();
  if (!db) return [];

  const conditions = [eq(performanceEvaluations.employeeId, employeeId)];
  if (cycleId) {
    conditions.push(eq(performanceEvaluations.cycleId, cycleId));
  }

  return await db
    .select()
    .from(performanceEvaluations)
    .where(and(...conditions))
    .orderBy(desc(performanceEvaluations.createdAt));
}

export async function getEvaluationById(id: number) {
  const db = await getDb();
  if (!db) return undefined;

  const result = await db
    .select()
    .from(performanceEvaluations)
    .where(eq(performanceEvaluations.id, id))
    .limit(1);

  return result.length > 0 ? result[0] : undefined;
}

// ============================================================================
// PDI (Plano de Desenvolvimento Individual)
// ============================================================================

export async function getPDIsByEmployee(employeeId: number, cycleId?: number) {
  const db = await getDb();
  if (!db) return [];

  const conditions = [eq(pdiPlans.employeeId, employeeId)];
  if (cycleId) {
    conditions.push(eq(pdiPlans.cycleId, cycleId));
  }

  return await db
    .select()
    .from(pdiPlans)
    .where(and(...conditions))
    .orderBy(desc(pdiPlans.createdAt));
}

export async function getPDIById(id: number) {
  const db = await getDb();
  if (!db) return undefined;

  const result = await db
    .select()
    .from(pdiPlans)
    .where(eq(pdiPlans.id, id))
    .limit(1);

  return result.length > 0 ? result[0] : undefined;
}

export async function getPDIItemsByPlan(planId: number) {
  const db = await getDb();
  if (!db) return [];

  return await db
    .select()
    .from(pdiItems)
    .where(eq(pdiItems.planId, planId))
    .orderBy(pdiItems.startDate);
}

export async function getDevelopmentActions() {
  const db = await getDb();
  if (!db) return [];

  return await db
    .select()
    .from(developmentActions)
    .where(eq(developmentActions.active, true))
    .orderBy(developmentActions.title);
}

// ============================================================================
// MATRIZ 9-BOX
// ============================================================================

export async function getNineBoxByCycle(cycleId: number) {
  const db = await getDb();
  if (!db) return [];

  return await db
    .select({
      nineBox: nineBoxPositions,
      employee: employees,
      position: positions,
    })
    .from(nineBoxPositions)
    .leftJoin(employees, eq(nineBoxPositions.employeeId, employees.id))
    .leftJoin(positions, eq(employees.positionId, positions.id))
    .where(eq(nineBoxPositions.cycleId, cycleId))
    .orderBy(desc(nineBoxPositions.performance), desc(nineBoxPositions.potential));
}

// ============================================================================
// COMPETÊNCIAS
// ============================================================================

export async function getEmployeeCompetencies(employeeId: number) {
  const db = await getDb();
  if (!db) return [];

  return await db
    .select()
    .from(employeeCompetencies)
    .where(eq(employeeCompetencies.employeeId, employeeId))
    .orderBy(desc(employeeCompetencies.evaluatedAt));
}

// ============================================================================
// CICLOS DE AVALIAÇÃO
// ============================================================================

export async function getActiveCycle() {
  const db = await getDb();
  if (!db) return undefined;

  const now = new Date();
  const result = await db
    .select()
    .from(evaluationCycles)
    .where(
      and(
        eq(evaluationCycles.status, "em_andamento"),
        lte(evaluationCycles.startDate, now),
        gte(evaluationCycles.endDate, now)
      )
    )
    .limit(1);

  return result.length > 0 ? result[0] : undefined;
}

export async function getAllCycles() {
  const db = await getDb();
  if (!db) return [];

  return await db
    .select()
    .from(evaluationCycles)
    .orderBy(desc(evaluationCycles.year), desc(evaluationCycles.startDate));
}

// ============================================================================
// DEPARTAMENTOS E CARGOS
// ============================================================================

export async function getAllDepartments() {
  const db = await getDb();
  if (!db) return [];

  return await db
    .select()
    .from(departments)
    .where(eq(departments.active, true))
    .orderBy(departments.name);
}

export async function getAllPositions() {
  const db = await getDb();
  if (!db) return [];

  return await db
    .select()
    .from(positions)
    .where(eq(positions.active, true))
    .orderBy(positions.title);
}

// ============================================================================
// AUDITORIA
// ============================================================================

export async function logAudit(
  userId: number | undefined,
  action: string,
  entity: string,
  entityId: number | undefined,
  changes: any,
  ipAddress?: string,
  userAgent?: string
) {
  const db = await getDb();
  if (!db) return;

  try {
    await db.insert(auditLogs).values({
      userId: userId || null,
      action,
      entity,
      entityId: entityId || null,
      changes: JSON.stringify(changes),
      ipAddress: ipAddress || null,
      userAgent: userAgent || null,
    });
  } catch (error) {
    console.error("[Database] Failed to log audit:", error);
  }
}

// ============================================================================
// DASHBOARD - ESTATÍSTICAS
// ============================================================================

export async function getDashboardStats(employeeId: number, cycleId?: number) {
  const db = await getDb();
  if (!db) return null;

  const cycle = cycleId ? await db.select().from(evaluationCycles).where(eq(evaluationCycles.id, cycleId)).limit(1) : [];
  const activeCycle = cycle.length > 0 ? cycle[0] : await getActiveCycle();

  if (!activeCycle) return null;

  // Contar metas
  const goalsCount = await db
    .select({ count: sql<number>`count(*)` })
    .from(goals)
    .where(and(eq(goals.employeeId, employeeId), eq(goals.cycleId, activeCycle.id)));

  // Contar PDIs
  const pdisCount = await db
    .select({ count: sql<number>`count(*)` })
    .from(pdiPlans)
    .where(and(eq(pdiPlans.employeeId, employeeId), eq(pdiPlans.cycleId, activeCycle.id)));

  // Contar avaliações
  const evaluationsCount = await db
    .select({ count: sql<number>`count(*)` })
    .from(performanceEvaluations)
    .where(and(eq(performanceEvaluations.employeeId, employeeId), eq(performanceEvaluations.cycleId, activeCycle.id)));

  return {
    cycle: activeCycle,
    goalsCount: goalsCount[0]?.count || 0,
    pdisCount: pdisCount[0]?.count || 0,
    evaluationsCount: evaluationsCount[0]?.count || 0,
  };
}

==================================================================
## FRONTEND - APP
==================================================================

import { Toaster } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import NotFound from "@/pages/NotFound";
import { Route, Switch } from "wouter";
import ErrorBoundary from "./components/ErrorBoundary";
import { ThemeProvider } from "./contexts/ThemeContext";
import { NotificationProvider } from "./contexts/NotificationContext";
import Home from "./pages/Home";
import DashboardGestor from "./pages/DashboardGestor";
import ConfiguracoesSMTP from "./pages/ConfiguracoesSMTP";
import Metas from "./pages/Metas";
import Avaliacoes from "./pages/Avaliacoes";
import PDI from "./pages/PDI";
import NineBox from "./pages/NineBox";
import Relatorios from "./pages/Relatorios";
import Calibracao from "./pages/Calibracao";
import Configuracoes from "./pages/Configuracoes";
import Perfil from "./pages/Perfil";
import History from "./pages/History";
import Funcionarios from "./pages/Funcionarios";
import FuncionariosAtivos from "./pages/FuncionariosAtivos";
import Departamentos from "./pages/Departamentos";
import CentrosCusto from "./pages/CentrosCusto";
import AprovacoesD from "./pages/aprovacoes/Dashboard";
import MinhasSolicitacoes from "./pages/aprovacoes/MinhasSolicitacoes";
import Bonus from "./pages/aprovacoes/Bonus";
import Workflows from "./pages/aprovacoes/Workflows";
import Sucessao from "./pages/Sucessao";
import SucessaoMelhorado from "./pages/SucessaoMelhorado";
import PDIInteligente from "./pages/PDIInteligente";
import PDIInteligenteNovo from "./pages/PDIInteligenteNovo";
import PDIInteligenteDetalhes from "./pages/PDIInteligenteDetalhes";
import TestesResultadosRH from "./pages/TestesResultadosRH";
import NineBoxComparativo from "./pages/NineBoxComparativo";
import ReportBuilder from "./pages/ReportBuilder";
import ReportAnalytics from "./pages/ReportAnalytics";
import SuccessionImport from "./pages/SuccessionImport";
import PerformanceIntegrada from "./pages/PerformanceIntegrada";
import Avaliacao360Enhanced from "./pages/Avaliacao360Enhanced";
import AuditTrail from "./pages/AuditTrail";
import Analytics from "./pages/Analytics";
import Feedbacks from "./pages/Feedbacks";
import Badges from "./pages/Badges";
import PsychometricTests from "./pages/PsychometricTests";
import TestDISC from "./pages/TestDISC";
import TestBigFive from "./pages/TestBigFive";
import TestMBTI from "./pages/TestMBTI";
import TestIE from "./pages/TestIE";
import TestVARK from "./pages/TestVARK";
import TestLeadership from "./pages/TestLeadership";
import TestCareerAnchors from "./pages/TestCareerAnchors";
import EnviarTestes from "./pages/EnviarTestes";
import Notificacoes from "./pages/Notificacoes";
import DashboardComparativoTestes from "./pages/DashboardComparativoTestes";
import RelatoriosExecutivos from "./pages/RelatoriosExecutivos";
import AdminSmtp from "./pages/AdminSmtp";
import EmailMetrics from "./pages/EmailMetrics";
import ScheduledReports from "./pages/ScheduledReports";
import ExecutiveDashboard from "./pages/ExecutiveDashboard";
import DashboardExecutivo from "./pages/DashboardExecutivo";
import Avaliar360 from "./pages/Avaliar360";
import MetasSMART from "./pages/MetasSMART";
import CriarMetaSMART from "./pages/CriarMetaSMART";
import DetalhesMeta from "./pages/DetalhesMeta";
import EditarMeta from "./pages/EditarMeta";
import AtualizarProgressoMeta from "./pages/AtualizarProgressoMeta";
import AnalyticsMetas from "./pages/AnalyticsMetas";
import AprovarMetas from "./pages/AprovarMetas";
import ConfiguracaoBonus from "@/pages/ConfiguracaoBonus";
import ConfiguracaoWorkflowsBonus from "@/pages/ConfiguracaoWorkflowsBonus";
import DashboardBonusRH from "./pages/DashboardBonusRH";
import MovimentacaoNineBox from "./pages/MovimentacaoNineBox";
import AprovacaoCalibracoes from "./pages/AprovacaoCalibracoes";
import RankingGamificacao from "./pages/RankingGamificacao";
import ConfiguracaoIntegracoes from "./pages/ConfiguracaoIntegracoes";
import HierarquiaOrganizacional from "./pages/HierarquiaOrganizacional";
import HierarquiaImport from "./pages/HierarquiaImport";
import DashboardEmails from "./pages/DashboardEmails";

function Router() {
  return (
    <Switch>
      <Route path={"/"} component={Home} />          <Route path="/gestor" component={DashboardGestor} />
          <Route path="/configuracoes/smtp" component={ConfiguracoesSMTP} />      <Route path={"/metas"} component={MetasSMART} />
      <Route path={"/metas/criar"} component={CriarMetaSMART} />
      <Route path={"/metas/:id"} component={DetalhesMeta} />
      <Route path={"/metas/:id/editar"} component={EditarMeta} />
      <Route path="/metas/:id/progresso" component={AtualizarProgressoMeta} />
      <Route path="/analytics/metas" component={AnalyticsMetas} />
      <Route path="/executivo/calibracao" component={MovimentacaoNineBox} />
      <Route path="/executivo/aprovacoes" component={AprovacaoCalibracoes} />
      <Route path="/gamificacao/ranking" component={RankingGamificacao} />
      <Route path="/configuracoes/integracoes" component={ConfiguracaoIntegracoes} />
      <Route path={"/avaliacoes"} component={Avaliacoes} />
      <Route path={"/pdi"} component={PDI} />
      <Route path={"/nine-box"} component={NineBox} />
      <Route path={'/relatorios'} component={Relatorios} />
      <Route path="/calibracao" component={Calibracao} />
      <Route path="/configuracoes" component={Configuracoes} />
      <Route path="/perfil" component={Perfil} />
      <Route path="/historico" component={History} />
      <Route path="/funcionarios" component={Funcionarios} />
      <Route path="/funcionarios-ativos" component={FuncionariosAtivos} />
      <Route path="/departamentos" component={Departamentos} />
      <Route path="/centros-custo" component={CentrosCusto} />
      <Route path="/aprovacoes/dashboard" component={AprovacoesD} />
      <Route path="/aprovacoes/solicitacoes" component={MinhasSolicitacoes} />      <Route path={"/aprovacoes/bonus"} component={Bonus} />
      <Route path="/aprovacoes/metas" component={AprovarMetas} />
      <Route path="/configuracoes/bonus" component={ConfiguracaoBonus} />
      <Route path="/configuracoes/workflows-bonus" component={ConfiguracaoWorkflowsBonus} />
      <Route path="/rh/dashboard-bonus" component={DashboardBonusRH} />
      <Route path="/aprovacoes/workflows" component={Workflows} />
      <Route path="/sucessao" component={Sucessao} />
      <Route path="/mapa-sucessao" component={SucessaoMelhorado} />
      <Route path="/pdi-inteligente/novo" component={PDIInteligenteNovo} />
      <Route path="/pdi-inteligente/:id/detalhes" component={PDIInteligenteDetalhes} />
      <Route path="/pdi-inteligente/:id" component={PDIInteligente} />
      <Route path="/testes-psicometricos/resultados" component={TestesResultadosRH} />
      <Route path="/nine-box-comparativo" component={NineBoxComparativo} />
      <Route path="/admin/report-builder" component={ReportBuilder} />
      <Route path="/admin/report-analytics" component={ReportAnalytics} />
      <Route path={"/admin/succession-import"} component={SuccessionImport} />
      <Route path="/performance-integrada" component={PerformanceIntegrada} />
      <Route path="/360-enhanced" component={Avaliacao360Enhanced} />
      <Route path="/testes-psicometricos" component={PsychometricTests} />
      <Route path="/teste-disc" component={TestDISC} />
      <Route path="/teste-bigfive" component={TestBigFive} />
      <Route path="/teste-mbti" component={TestMBTI} />
      <Route path="/teste-ie" component={TestIE} />
      <Route path="/teste-vark" component={TestVARK} />
      <Route path="/teste-lideranca" component={TestLeadership} />
      <Route path="/teste-ancoras-carreira" component={TestCareerAnchors} />
      <Route path="/testes/enviar" component={EnviarTestes} />
      <Route path="/notificacoes" component={Notificacoes} />
      <Route path="/testes/comparativo" component={DashboardComparativoTestes} />
      <Route path="/relatorios-executivos" component={RelatoriosExecutivos} />
      <Route path="/admin/smtp" component={AdminSmtp} />
      <Route path="/admin/hierarquia" component={HierarquiaOrganizacional} />
      <Route path="/admin/hierarquia/importar" component={HierarquiaImport} />
      <Route path="/admin/emails" component={DashboardEmails} />
      <Route path="/admin/email-metrics" component={EmailMetrics} />
      <Route path="/admin/scheduled-reports" component={ScheduledReports} />
      <Route path="/executive-dashboard" component={ExecutiveDashboard} />
      <Route path="/dashboard-executivo" component={DashboardExecutivo} />
      <Route path="/analytics" component={Analytics} />
                <Route path="/avaliar-360/:id" component={Avaliar360} />
          <Route path="/admin/audit-log" component={AuditTrail} />
          <Route path="/admin/analytics" component={Analytics} />
          <Route path="/feedback" component={Feedbacks} />
          <Route path="/badges" component={Badges} />
      <Route path={"/404"} component={NotFound} />
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <ErrorBoundary>
      <ThemeProvider
        defaultTheme="light"
        // switchable
      >
        <NotificationProvider>
          <TooltipProvider>
            <Toaster />
            <Router />
          </TooltipProvider>
        </NotificationProvider>
      </ThemeProvider>
    </ErrorBoundary>
  );
}

export default App;
==================================================================
## PACKAGE.JSON
==================================================================

{
  "name": "avd-uisa-sistema-completo",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "NODE_ENV=development tsx watch server/_core/index.ts",
    "build": "vite build && esbuild server/_core/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc --noEmit",
    "format": "prettier --write .",
    "test": "vitest run",
    "db:push": "drizzle-kit generate && drizzle-kit migrate"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.693.0",
    "@aws-sdk/s3-request-presigner": "^3.693.0",
    "@radix-ui/react-accordion": "^1.2.12",
    "@radix-ui/react-alert-dialog": "^1.1.15",
    "@radix-ui/react-aspect-ratio": "^1.1.7",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-collapsible": "^1.1.12",
    "@radix-ui/react-context-menu": "^2.2.16",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-hover-card": "^1.1.15",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-menubar": "^1.1.16",
    "@radix-ui/react-navigation-menu": "^1.2.14",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.3.8",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slider": "^1.3.6",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-toggle": "^1.1.10",
    "@radix-ui/react-toggle-group": "^1.1.11",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@tanstack/react-query": "^5.90.2",
    "@tensorflow/tfjs-converter": "^4.22.0",
    "@tensorflow/tfjs-core": "^4.22.0",
    "@trpc/client": "^11.6.0",
    "@trpc/react-query": "^11.6.0",
    "@trpc/server": "^11.6.0",
    "@types/node-cron": "^3.0.11",
    "axios": "^1.12.0",
    "chart.js": "^4.5.1",
    "chartjs-node-canvas": "^5.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "cookie": "^1.0.2",
    "cron": "^4.3.4",
    "date-fns": "^4.1.0",
    "dotenv": "^17.2.2",
    "drizzle-orm": "^0.44.5",
    "embla-carousel-react": "^8.6.0",
    "exceljs": "^4.4.0",
    "express": "^4.21.2",
    "face-api.js": "^0.22.2",
    "framer-motion": "^12.23.22",
    "html2canvas": "^1.4.1",
    "input-otp": "^1.4.2",
    "jose": "6.1.0",
    "jspdf": "^3.0.3",
    "jspdf-autotable": "^5.0.2",
    "lucide-react": "^0.453.0",
    "mysql2": "^3.15.0",
    "nanoid": "^5.1.5",
    "next-themes": "^0.4.6",
    "node-cron": "^4.2.1",
    "nodemailer": "^7.0.10",
    "openai": "^4.67.0",
    "react": "^19.1.1",
    "react-chartjs-2": "^5.3.1",
    "react-day-picker": "^9.11.1",
    "react-dom": "^19.1.1",
    "react-hook-form": "^7.64.0",
    "react-resizable-panels": "^3.0.6",
    "reactflow": "^11.11.4",
    "recharts": "^2.15.4",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "sonner": "^2.0.7",
    "streamdown": "^1.4.0",
    "superjson": "^1.13.3",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "xlsx": "^0.18.5",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@builder.io/vite-plugin-jsx-loc": "^0.1.1",
    "@tailwindcss/typography": "^0.5.15",
    "@tailwindcss/vite": "^4.1.3",
    "@types/express": "4.17.21",
    "@types/google.maps": "^3.58.1",
    "@types/node": "^24.7.0",
    "@types/nodemailer": "^7.0.3",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "add": "^2.0.6",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.31.4",
    "esbuild": "^0.25.0",
    "pnpm": "^10.15.1",
    "postcss": "^8.4.47",
    "prettier": "^3.6.2",
    "tailwindcss": "^4.1.14",
    "tsx": "^4.20.6",
    "tw-animate-css": "^1.4.0",
    "typescript": "5.9.3",
    "vite": "^7.1.7",
    "vite-plugin-manus-runtime": "^0.0.56",
    "vitest": "^2.1.4"
  },
  "packageManager": "pnpm@10.4.1+sha512.c753b6c3ad7afa13af388fa6d808035a008e30ea9993f58c6663e2bc5ff21679aa834db094987129aa4d488b86df57f7b634981b2f827cdcacc698cc0cfb88af",
  "pnpm": {
    "patchedDependencies": {
      "wouter@3.7.1": "patches/wouter@3.7.1.patch"
    },
    "overrides": {
      "tailwindcss>nanoid": "3.3.7"
    }
  }
}
==================================================================
## TODO.MD - FUNCIONALIDADES
==================================================================

# Sistema AVD UISA - TODO

## 🐛 Correção Erro pdiRisks

- [x] Adicionar coluna type (renomear category)
- [x] Adicionar coluna responsible
- [x] Testar página de PDI Inteligente

## 🐛 Correção Erro pdiIntelligentDetails

- [x] Verificar schema de pdiIntelligentDetails
- [x] Tornar campos opcionais ou adicionar valores padrão
- [x] Criar tabela pdiIntelligentDetails
- [x] Criar tabela pdiCompetencyGaps
- [x] Criar tabela pdiRisks
- [x] Criar tabela pdiReviews
- [x] Testar criação de PDI Inteligente

## 🐛 Correção Erro goalMilestones

- [x] Verificar se tabela goalMilestones existe no schema
- [x] Criar tabela goalMilestones se não existir
- [x] Executar migração do banco de dados
- [x] Testar página de progresso de meta

## 🎨 Melhorias de Performance (Cores e Layout)

- [ ] Acessar página de Avaliação 360° Enhanced
- [ ] Aplicar paleta de cores moderna (roxo #7C3AED, azul #3B82F6, verde #10B981, amarelo #F59E0B)
- [ ] Redesenhar cards de KPIs com ícones coloridos
- [ ] Melhorar layout do dashboard de avaliações
- [ ] Adicionar gráficos de progresso e métricas
- [ ] Implementar visualizações de competências

## 🧠 Testes Psicométricos Completos

- [ ] Desenvolver teste DISC (Dominância, Influência, Estabilidade, Conformidade)
- [ ] Desenvolver teste Big Five (OCEAN)
- [ ] Desenvolver teste 16 Personalities (MBTI)
- [ ] Desenvolver teste de Inteligência Emocional (Goleman)
- [ ] Desenvolver teste de Estilos de Liderança
- [ ] Desenvolver teste de Âncoras de Carreira (Schein)
- [ ] Criar schema de banco para testes e respostas
- [ ] Implementar sistema de envio de testes
- [ ] Criar interface de envio para funcionários/equipes/departamentos
- [ ] Desenvolver dashboards de resultados individuais
- [ ] Desenvolver dashboards de resultados comparativos
- [ ] Popular dados de demonstração de testes
- [ ] Testar fluxo completo end-to-end
- [ ] Aplicar paleta de cores inspirada nas imagens (roxo #7C3AED, azul #3B82F6, verde #10B981, amarelo #F59E0B)
- [ ] Redesenhar cards de KPIs com ícones coloridos
- [ ] Melhorar layout do dashboard de avaliações
- [ ] Adicionar gráficos de progresso e métricas
- [ ] Implementar visualizações de competências
- [ ] Popular dados de demonstração (ciclos, avaliações, competências)
- [ ] Testar fluxo completo de avaliação 360°
- [ ] Validar responsividade e UX

## 💰 Formatação Monetária R$ e Validar SMART

- [x] Criar helper de formatação monetária R$ (pt-BR)
- [x] Aplicar formatação R$ em campos de bônus (Metas)
- [x] Aplicar formatação R$ em campos de valores (PDI, Avaliações)
- [ ] Corrigir botão "Validar SMART" em CriarMetaSMART.tsx
- [ ] Testar gravação de meta após validação SMART
- [ ] Analisar arquivos HTML/PDF de PDIs enviados
- [ ] Extrair dados dos PDIs (Agenor, Pablo, Paulo, Nadia, Callegari, Eduardo, Fernando)
- [ ] Importar PDIs para o banco de dados
- [ ] Validar PDIs importados no sistema

## 🔍 PDI Inteligente - Busca Completa de Funcionários UISA

- [x] Verificar endpoint employees.list para retornar todos os 2.889 funcionários
- [x] Corrigir Combobox de busca de colaboradores na página /pdi-inteligente/novo
- [x] Implementar busca com filtro por nome, cargo e departamento
- [x] Testar criação de PDI com colaborador selecionado
- [x] Validar que todos os campos do formulário funcionam corretamente
- [x] Garantir que a busca funciona perfeitamente com grande volume de dados

## 📊 Sistema Completo de Testes Psicométricos (Prioridade Alta)

- [x] Popular perguntas do teste DISC no banco de dados
- [x] Popular perguntas do teste Big Five no banco de dados
- [x] Popular perguntas do teste MBTI no banco de dados
- [x] Popular perguntas do teste Inteligência Emocional no banco de dados
- [x] Popular perguntas do teste Estilos de Liderança no banco de dados
- [x] Popular perguntas do teste Âncoras de Carreira no banco de dados
- [x] Criar páginas de questionários para cada teste
- [x] Implementar cálculo de resultados para cada teste
- [x] Criar sistema de envio de testes para funcionários individuais
- [x] Criar sistema de envio de testes para equipes
- [x] Criar sistema de envio de testes para departamentos
- [ ] Criar dashboard de resultados por funcionário
- [ ] Criar dashboard de resultados comparativos por equipe/departamento
- [ ] Adicionar gráficos radar para visualização de perfis
- [ ] Integrar resultados de testes com PDI Inteligente

## 🎨 Melhorias de Performance - Design Moderno (Prioridade Alta)

- [ ] Redesenhar Performance Integrada com paleta moderna
- [ ] Redesenhar 360° Enhanced com paleta moderna
- [ ] Aplicar cores: roxo #7C3AED, azul #3B82F6, verde #10B981
- [ ] Criar cards de KPIs coloridos com ícones (lucide-react)
- [ ] Adicionar gráficos de competências com Recharts
- [ ] Melhorar visualizações de resultados 360°
- [ ] Implementar animações e transições suaves
- [ ] Adicionar indicadores visuais de progresso


## 📊 Dashboards Comparativos de Testes Psicométricos

- [x] Criar endpoint para buscar resultados agregados por equipe
- [x] Criar endpoint para buscar resultados agregados por departamento
- [x] Criar endpoint para buscar resultados agregados por cargo
- [x] Implementar página de dashboard comparativo com gráficos radar
- [x] Adicionar filtros por tipo de teste, período e grupo
- [x] Implementar visualização de distribuição de perfis
- [x] Adicionar comparação lado a lado de equipes/departamentos

## 🔗 Integração Testes + PDI Inteligente

- [x] Criar sistema de recomendações automáticas baseado em perfis
- [x] Mapear perfis psicométricos para competências e cursos
- [x] Integrar resultados na página de criação de PDI
- [x] Adicionar sugestões de desenvolvimento por perfil
- [x] Implementar análise de gaps de competências

## 📈 Relatórios Executivos de RH

- [x] Criar página de relatórios executivos
- [x] Implementar análise de distribuição de perfis organizacionais
- [x] Adicionar insights sobre gaps de competências
- [x] Criar sugestões de formação de equipes
- [x] Implementar análise de tendências ao longo do tempo
- [ ] Adicionar exportação de relatórios em PDF (preparado para implementação futura)

## 🎨 Melhorias de Design nas Páginas de Performance

- [ ] Redesenhar página de Performance Integrada com cores vibrantes
- [ ] Melhorar visualização de gráficos e métricas
- [ ] Adicionar animações e transições suaves
- [ ] Implementar tema moderno e profissional


## 📄 Exportação de Relatórios em PDF

- [x] Instalar biblioteca html2pdf ou puppeteer
- [x] Criar função de exportação de relatórios executivos
- [x] Criar função de exportação de dashboards comparativos
- [x] Criar função de exportação de recomendações de PDI
- [x] Adicionar botões de exportação nas páginas
- [x] Implementar templates de PDF profissionais
- [x] Adicionar logo e branding nos PDFs

## 🔔 Sistema de Notificações Push

- [x] Criar schema de notificações no banco de dados
- [x] Implementar endpoint de criação de notificações
- [x] Criar componente de centro de notificações no header
- [ ] Implementar notificações quando colaborador completa teste (trigger automático)
- [ ] Implementar notificações quando PDI atinge marco (trigger automático)
- [ ] Implementar notificações de insights críticos (trigger automático)
- [x] Adicionar badge de contagem de não lidas
- [x] Implementar marcação de lida/não lida

## 📊 Módulo de Benchmarking Externo

- [ ] Criar schema de dados de benchmarking
- [ ] Popular dados de médias de mercado por setor/cargo
- [ ] Criar página de benchmarking comparativo
- [ ] Implementar gráficos de comparação UISA vs Mercado
- [ ] Adicionar análise de vantagens competitivas
- [ ] Implementar identificação de gaps vs mercado
- [ ] Criar relatório de posicionamento competitivo


## 🔄 Triggers Automáticos de Notificações

- [x] Adicionar trigger ao endpoint de conclusão de teste psicométrico
- [x] Adicionar trigger ao endpoint de atualização de progresso de PDI
- [ ] Adicionar trigger ao endpoint de conclusão de avaliação 360° (pendente endpoint específico)
- [x] Adicionar trigger ao endpoint de conclusão de meta
- [ ] Adicionar trigger para insights críticos identificados (implementar quando necessário)
- [x] Testar criação automática de notificações

## 📄 Página de Histórico de Notificações

- [x] Criar página /notificacoes com lista completa
- [x] Implementar filtros por tipo de notificação
- [x] Implementar filtros por período (hoje, semana, mês, ano)
- [x] Implementar filtro por status (lidas/não lidas)
- [x] Adicionar busca textual por título e mensagem
- [x] Implementar paginação (limite de 100 notificações)
- [x] Adicionar botão de limpar todas as notificações (marcar todas como lidas)


## 🔧 Correções Urgentes

### Analytics de RH
- [x] Corrigir layout quebrado com legenda sobrepondo conteúdo
- [x] Reorganizar posicionamento dos gráficos
- [x] Ajustar z-index e overflow da legenda

### Dashboard Executivo
- [x] Adicionar seção de distribuição do Nine Box
- [x] Implementar gráfico de distribuição por quadrante
- [x] Adicionar métricas de talentos por categoria

### Criar Meta SMART
- [x] Implementar lógica de seleção exclusiva entre % e Bônus Fixo
- [x] Corrigir botão "Validar SMART" para funcionar
- [x] Garantir que meta seja gravada corretamente
- [x] Adicionar validações de campos obrigatórios

## 📊 Módulo de Benchmarking Externo
- [ ] Criar schema de dados de mercado
- [ ] Popular dados de benchmark por setor/cargo
- [ ] Criar página de comparação com médias de mercado
- [ ] Implementar gráficos radar comparativos
- [ ] Adicionar análise de gaps competitivos


## 🔧 Correção de Workflows
- [x] Verificar schema da tabela workflows no drizzle/schema.ts
- [x] Criar tabela workflows no banco de dados se não existir
- [x] Testar página /aprovacoes/workflows


## 🔄 Fluxo Completo de Avaliação 360°
- [ ] Atualizar schema com campos de status do fluxo (selfAssessmentStatus, managerAssessmentStatus, consensusStatus)
- [ ] Adicionar campos de datas (selfAssessmentCompletedAt, managerAssessmentCompletedAt, consensusCompletedAt)
- [ ] Criar endpoint para funcionário submeter autoavaliação
- [ ] Criar endpoint para gestor submeter avaliação
- [ ] Criar endpoint para líder submeter consenso
- [ ] Implementar notificações por email em cada transição
- [ ] Criar página de autoavaliação para funcionário
- [ ] Criar página de avaliação para gestor
- [ ] Criar página de consenso para líder
- [ ] Habilitar/desabilitar botões conforme etapa do fluxo
- [ ] Adicionar validações de permissões por etapa
- [ ] Testar fluxo completo end-to-end


## 🔧 Correção Nine Box
- [x] Corrigir matriz Nine Box invertida (validar eixos X e Y)

## 📊 Filtros Hierárquicos Nine Box Comparativo
- [x] Criar endpoint para buscar subordinados diretos por managerId
- [x] Implementar filtro por nível hierárquico (Diretoria, Gerência, Coordenação, Supervisão)
- [x] Implementar filtro por cargo de liderança unificado
- [x] Adicionar dropdown com lista de líderes
- [x] Filtrar matriz Nine Box pelos subordinados do líder selecionado (lógica de filtro a implementar)
- [x] Implementar lógica de classificação por nível hierárquico baseado em subordinados
- [x] Conectar filtros ao endpoint getComparative

## 🔧 Correção 360° Enhanced
- [x] Corrigir exibição de nome do colaborador (mostrar nome ao invés de código)

## 🔄 Fluxo Completo Avaliação 360°
- [ ] Atualizar schema com campos de status do fluxo (autoavaliação, avaliação gestor, consenso)
- [ ] Criar endpoint de autoavaliação
- [ ] Criar endpoint de avaliação do gestor
- [ ] Criar endpoint de consenso do líder
- [ ] Implementar notificações automáticas por email em cada transição
- [ ] Criar interface de autoavaliação para funcionário
- [ ] Criar interface de avaliação para gestor
- [ ] Criar interface de consenso para líder
- [ ] Habilitar/desabilitar botões conforme etapa

## 📊 Página de Benchmarking
- [ ] Criar página /benchmarking
- [ ] Implementar endpoint de comparação UISA vs Mercado
- [ ] Criar gráficos radar DISC comparativos
- [ ] Criar gráficos radar Big Five comparativos
- [ ] Adicionar análise automática de gaps
- [ ] Implementar filtros por setor e cargo

## 🔄 Fluxo Completo de Avaliação 360°
- [ ] Atualizar schema com campos de status do fluxo
- [ ] Criar endpoint para funcionário submeter autoavaliação
- [ ] Criar endpoint para gestor submeter avaliação
- [ ] Criar endpoint para líder submeter consenso
- [ ] Implementar notificações por email em cada transição
- [ ] Criar interface de autoavaliação
- [ ] Criar interface de avaliação do gestor
- [ ] Criar interface de consenso do líder
- [ ] Habilitar/desabilitar botões conforme etapa
- [ ] Testar fluxo completo


## 📋 PDI Inteligente Completo - Modelo Nadia (Prioridade Máxima)
- [x] Criar schema de ações do PDI (pdiActions) com campos: título, descrição, eixo (70/20/10), métrica de sucesso, responsáveis, prazo, status (não iniciado/em andamento/concluído)
- [x] Criar schema de feedbacks/acompanhamento (pdiGovernanceReviews) com campos: data reunião, índice de prontidão (IPS 1-5), feedback textual, pontos-chave
- [x] Criar endpoint para adicionar ação ao PDI
- [x] Criar endpoint para atualizar status de ação
- [x] Criar endpoint para adicionar feedback de acompanhamento
- [x] Criar endpoint para buscar histórico de feedbacks
- [x] Criar endpoint para calcular evolução do IPS ao longo do tempo
- [x] Implementar página de visualização de PDI com tabela de ações editáveis (/pdi-inteligente/:id/detalhes)
- [x] Implementar formulário de adicionar/editar ações
- [x] Implementar seletor de status (não iniciado/em andamento/concluído) com cores
- [x] Implementar seção de acompanhamento DGC com formulário de feedback
- [x] Implementar gráfico de evolução do IPS (Chart.js)
- [x] Implementar histórico de reuniões de governança
- [ ] Implementar botões de salvar progresso e exportar JSON
- [ ] Testar fluxo completo de criação, edição e acompanhamento

## 🔄 Fluxo Completo de Avaliação 360° com Emails (Prioridade Alta)
- [x] Atualizar schema performanceEvaluations com campo workflowStatus (pending_self, pending_manager, pending_consensus, completed)
- [x] Adicionar campos de datas (selfCompletedAt, managerCompletedAt, consensusCompletedAt)
- [x] Criar endpoint evaluation360.submitSelfAssessment
- [x] Criar endpoint evaluation360.submitManagerAssessment
- [x] Criar endpoint evaluation360.submitConsensus
- [x] Integrar envio de email automático ao gestor quando autoavaliação é concluída
- [x] Integrar envio de email automático ao líder quando avaliação do gestor é concluída
- [ ] Criar página de autoavaliação (/avaliacoes/autoavaliacao/:id)
- [ ] Criar página de avaliação do gestor (/avaliacoes/gestor/:id)
- [ ] Criar página de consenso do líder (/avaliacoes/consenso/:id)
- [ ] Implementar lógica de habilitação/desabilitação de botões por etapa
- [ ] Adicionar validações de permissão (apenas gestor pode avaliar, apenas líder pode fazer consenso)
- [ ] Testar fluxo completo: autoavaliação → email → avaliação gestor → email → consenso

## 📊 Página de Benchmarking de Mercado (Prioridade Alta)
- [ ] Criar página /benchmarking com layout moderno
- [ ] Implementar endpoint benchmarking.getComparison para buscar dados UISA vs 21 perfis de mercado
- [ ] Criar gráfico radar comparando DISC médio UISA vs setor selecionado
- [ ] Criar gráfico radar comparando Big Five médio UISA vs setor selecionado
- [ ] Implementar filtros por setor (Agronegócio, Indústria, Tecnologia, Financeiro, etc)
- [ ] Implementar filtros por cargo (Gerente, Coordenador, Analista, etc)
- [ ] Adicionar análise automática de gaps competitivos (dimensões abaixo da média)
- [ ] Adicionar análise de vantagens organizacionais (dimensões acima da média)
- [ ] Implementar cards de insights estratégicos
- [ ] Adicionar botão de exportação de relatório de benchmarking em PDF
- [ ] Testar comparações com todos os 21 perfis de mercado

## 🌳 Sistema de Metas em Cascata Hierárquico (Prioridade Média)
- [ ] Criar schema de metas organizacionais (organizationalGoals)
- [ ] Criar schema de vinculação de metas (goalHierarchy) com parentGoalId
- [ ] Criar endpoint para criar meta organizacional
- [ ] Criar endpoint para desdobrar meta em metas departamentais
- [ ] Criar endpoint para desdobrar meta departamental em metas individuais
- [ ] Criar endpoint para buscar árvore hierárquica de metas
- [ ] Implementar página de metas em cascata (/metas/cascata)
- [ ] Implementar visualização em árvore (ReactFlow ou similar)
- [ ] Implementar cálculo automático de contribuição percentual de cada nível
- [ ] Implementar alertas quando meta superior é alterada
- [ ] Adicionar indicadores visuais de progresso agregado por nível
- [ ] Implementar propagação de mudanças de cima para baixo
- [ ] Testar fluxo completo: meta organizacional → departamental → individual


## 🐛 Correção Erro SelectItem Nine Box Comparativo
- [x] Corrigir SelectItem com value vazio na página /nine-box-comparativo
- [x] Substituir value="" por value="todos" e ajustar lógica do Select


## 🐛 Correção Filtros Nine Box Comparativo
- [x] Corrigir filtro de nível hierárquico que não está funcionando
- [x] Verificar endpoint getComparative e lógica de filtros
- [x] Substituir leftJoin problemático por SQL raw query
- [x] Implementar combinação correta de filtros (líder + hierarquia)


## 📝 Melhorias Formulário de Funcionários
- [x] Adicionar campo "Chapa" (matrícula) ao schema employees (já existia como employeeCode)
- [x] Adicionar campo "Salário" ao schema employees (salary em centavos)
- [x] Adicionar campo "Nível" (Diretoria/Gerência/Coordenação/Supervisão/Operacional) ao schema employees (hierarchyLevel)
- [x] Adicionar campo "Data de Admissão" ao schema employees (já existia como hireDate)
- [x] Criar página FuncionariosAtivos.tsx com formulário completo
- [x] Implementar endpoint employees.update no backend
- [x] Implementar validações de campos obrigatórios
- [x] Melhorar layout do modal de edição (modal grande com scroll)
- [x] Adicionar formatação de moeda para exibição de Salário

## 📄 Backup Completo do Projeto
- [ ] Criar script de backup que exporta todo o código-fonte
- [ ] Incluir schema do banco de dados
- [ ] Incluir configurações e variáveis de ambiente
- [ ] Gerar arquivo TXT com estrutura completa do projeto
- [ ] Adicionar timestamp e metadados ao backup

==================================================================
## PÁGINAS PRINCIPAIS
==================================================================

------- AdminSmtp.tsx -------
import { useState, useEffect } from "react";
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { toast } from "sonner";
import { Loader2, Mail, Send, Settings, ShieldAlert, CheckCircle2 } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";

/**
 * Página de Administração SMTP
 * Permite configurar servidor SMTP para envio de e-mails automáticos
 */

export default function AdminSmtp() {
  const { user } = useAuth();
  const [testEmail, setTestEmail] = useState("");
  const [isTesting, setIsTesting] = useState(false);

  // Buscar configurações SMTP
  const { data: smtpConfig, isLoading, refetch } = trpc.admin.getSmtpConfig.useQuery();

  // Mutation para atualizar configurações
  const updateMutation = trpc.admin.updateSmtpConfig.useMutation({
    onSuccess: () => {
      toast.success("Configurações SMTP salvas com sucesso!");
      refetch();
    },
    onError: (error) => {
      toast.error(`Erro ao salvar: ${error.message}`);
    },
  });

  // Mutation para testar conexão
  const testMutation = trpc.admin.testSmtpConnection.useMutation({
    onSuccess: (data) => {
      if (data.success) {
        toast.success(data.message || "E-mail de teste enviado!");
      } else {
        toast.error(data.message || "Falha ao enviar e-mail de teste");
      }
      setIsTesting(false);
    },
    onError: (error) => {
      toast.error(`Erro ao testar: ${error.message}`);
      setIsTesting(false);

------- Analytics.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Loader2, Users, TrendingDown, Clock, DollarSign, Download, BarChart3 } from "lucide-react";
import { CostCenterFilter } from "@/components/CostCenterFilter";
import { trpc } from "@/lib/trpc";
import { PieChart, Pie, Cell, BarChart, Bar, LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts";
import { toast } from "sonner";

const COLORS = ["#3B82F6", "#10B981", "#F59E0B", "#EF4444", "#8B5CF6", "#EC4899", "#14B8A6", "#F97316"];

export default function Analytics() {
  const [period, setPeriod] = useState("12m");
  const [department, setDepartment] = useState("todos");
  const [selectedCostCenter, setSelectedCostCenter] = useState<string>("all");

  const { data: kpis, isLoading: kpisLoading } = trpc.analytics.getKPIs.useQuery(
    selectedCostCenter !== "all" ? { costCenter: selectedCostCenter } : undefined
  );
  const { data: headcountByDept } = trpc.analytics.getHeadcountByDepartment.useQuery(
    selectedCostCenter !== "all" ? { costCenter: selectedCostCenter } : undefined
  );
  const { data: headcountByPosition } = trpc.analytics.getHeadcountByPosition.useQuery(
    selectedCostCenter !== "all" ? { costCenter: selectedCostCenter } : undefined
  );
  const { data: turnoverRate } = trpc.analytics.getTurnoverRate.useQuery();
  const { data: averageTenure } = trpc.analytics.getAverageTenure.useQuery();
  const { data: diversity } = trpc.analytics.getDiversityAnalysis.useQuery();
  const { data: growthProjection } = trpc.analytics.getGrowthProjection.useQuery();

  const handleExport = () => {
    toast.info("Exportando relatório de Analytics...");
    setTimeout(() => toast.success("Relatório exportado com sucesso!"), 1000);
  };

  if (kpisLoading) {
    return (
      <DashboardLayout>
        <div className="flex items-center justify-center h-96">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
        </div>
      </DashboardLayout>
    );
  }

  return (
    <DashboardLayout>
      <div className="space-y-6">

------- AnalyticsMetas.tsx -------
import { useState } from "react";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import {
  BarChart3,
  TrendingUp,
  Clock,
  CheckCircle2,
  XCircle,
  AlertCircle,
  Calendar,
  Target,
} from "lucide-react";

/**
 * Dashboard de Analytics de Metas SMART
 * Análise avançada com gráficos de tendências, taxas de aprovação e métricas
 */
export default function AnalyticsMetas() {
  const [selectedPeriod, setSelectedPeriod] = useState("30");
  const [selectedDepartment, setSelectedDepartment] = useState<string>("all");

  // Buscar dados de analytics
  const { data: analytics, isLoading } = trpc.smartGoals.getAnalytics.useQuery({
    period: parseInt(selectedPeriod),
    departmentId: selectedDepartment === "all" ? undefined : parseInt(selectedDepartment),
  });

  // Buscar departamentos para filtro
  const { data: departments } = trpc.departments.list.useQuery();

  if (isLoading) {
    return (
      <div className="container mx-auto py-8">
        <div className="flex items-center justify-center h-64">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-[#F39200]"></div>
        </div>
      </div>
    );
  }


------- AprovacaoCalibracoes.tsx -------
import { useState } from "react";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, XCircle, Clock, AlertTriangle, FileText } from "lucide-react";
import { toast } from "sonner";
import { useAuth } from "@/_core/hooks/useAuth";

/**
 * Página de Aprovação de Calibrações
 * Para Diretor de Gente e Diretor de Área
 */
export default function AprovacaoCalibracoes() {
  const { user } = useAuth();
  const [selectedApproval, setSelectedApproval] = useState<any>(null);
  const [isApproveDialogOpen, setIsApproveDialogOpen] = useState(false);
  const [isRejectDialogOpen, setIsRejectDialogOpen] = useState(false);
  const [evidence, setEvidence] = useState("");
  const [comments, setComments] = useState("");

  const utils = trpc.useUtils();

  // Queries
  const { data: pendingMovements, isLoading } =
    trpc.calibrationDiretoria.listPendingMovements.useQuery();

  // Mutations
  const approveMutation = trpc.calibrationDiretoria.approveMovement.useMutation({
    onSuccess: () => {
      toast.success("Movimentação aprovada com sucesso!");
      setIsApproveDialogOpen(false);
      setSelectedApproval(null);
      setEvidence("");
      setComments("");
      utils.calibrationDiretoria.listPendingMovements.invalidate();
    },
    onError: (error) => {
      toast.error(`Erro: ${error.message}`);
    },
  });

------- AprovarMetas.tsx -------
import { useState } from "react";
import { Link } from "wouter";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { toast } from "sonner";
import {
  CheckCircle2,
  XCircle,
  Clock,
  Target,
  TrendingUp,
  Calendar,
  User,
  AlertCircle,
  FileText,
} from "lucide-react";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";

/**
 * Página de Aprovação de Metas para Gestores/RH
 * Lista metas pendentes de aprovação e permite aprovar/rejeitar
 */
export default function AprovarMetas() {
  const [cycleFilter, setCycleFilter] = useState<number | undefined>(undefined);
  const [categoryFilter, setCategoryFilter] = useState<string | undefined>(undefined);
  const [selectedGoal, setSelectedGoal] = useState<any>(null);
  const [showApproveDialog, setShowApproveDialog] = useState(false);
  const [showRejectDialog, setShowRejectDialog] = useState(false);
  const [comments, setComments] = useState("");


------- AtualizarProgressoMeta.tsx -------
import { useState } from "react";
import { useParams, useLocation } from "wouter";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { toast } from "sonner";
import {
  ArrowLeft,
  Save,
  AlertCircle,
  TrendingUp,
  Target,
  CheckCircle2,
  Plus,
  Calendar,
} from "lucide-react";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";

/**
 * Página de Atualização de Progresso da Meta
 * Permite atualizar progresso, valor atual e adicionar marcos
 */
export default function AtualizarProgressoMeta() {
  const { id } = useParams();
  const [, navigate] = useLocation();
  const goalId = parseInt(id || "0");

  const [progress, setProgress] = useState("");
  const [currentValue, setCurrentValue] = useState("");
  const [comment, setComment] = useState("");

  // Buscar meta
  const { data: goal, isLoading, refetch } = trpc.smartGoals.getById.useQuery({ goalId });

  // Atualizar progresso
  const updateProgressMutation = trpc.smartGoals.updateProgress.useMutation({
    onSuccess: () => {
      toast.success("Progresso atualizado com sucesso!");
      setProgress("");
      setCurrentValue("");
      setComment("");
      refetch();
    },

------- AuditTrail.tsx -------
import { useState } from "react";
import { Download, Filter, Search, Eye } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { trpc } from "@/lib/trpc";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";
import { toast } from "sonner";

export default function AuditTrail() {
  const [filters, setFilters] = useState({
    action: "all",
    entity: "all",
    userId: undefined as number | undefined,
  });
  const [page, setPage] = useState(0);
  const [selectedLog, setSelectedLog] = useState<number | null>(null);
  const pageSize = 50;

  // Buscar logs com filtros
  const { data, isLoading } = trpc.auditTrail.getLogs.useQuery({
    ...filters,
    limit: pageSize,
    offset: page * pageSize,
  });


------- Avaliacao360Enhanced.tsx -------
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { trpc } from "@/lib/trpc";
import { CheckCircle2, Clock, Users, Loader2, TrendingUp, AlertCircle, BarChart3, Download } from "lucide-react";
import { generate360PDF } from "@/lib/generate360PDF";
import { toast } from "sonner";
import { useState } from "react";
import { Radar } from "react-chartjs-2";

/**
 * Página de Avaliação 360° Enhanced
 * Sistema completo de avaliação 360° com múltiplos avaliadores e gráficos comparativos
 */

export default function Avaliacao360Enhanced() {
  const [selectedEvaluation, setSelectedEvaluation] = useState<number | null>(null);

  // Buscar lista de avaliações 360°
  const { data: evaluations, isLoading } = trpc.evaluation360.list.useQuery({});

  // Buscar detalhes da avaliação selecionada
  const { data: details } = trpc.evaluation360.getDetails.useQuery(
    { evaluationId: selectedEvaluation || 0 },
    { enabled: !!selectedEvaluation }
  );

  const stages = [
    { 
      name: "Autoavaliação", 
      key: "selfEvaluationCompleted",
      icon: Users,
      color: "text-blue-600"
    },
    { 
      name: "Avaliação do Gestor", 
      key: "managerEvaluationCompleted",
      icon: TrendingUp,
      color: "text-purple-600"
    },
    { 
      name: "Avaliação de Pares", 
      key: "peersEvaluationCompleted",
      icon: Users,
      color: "text-green-600"
    },
    { 
      name: "Avaliação de Subordinados", 
      key: "subordinatesEvaluationCompleted",

------- Avaliacoes.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { trpc } from "@/lib/trpc";
import { AlertCircle, CheckCircle2, Clock, Users, Plus, Calendar } from "lucide-react";
import { toast } from "sonner";

export default function Avaliacoes() {
  const [isCreateCycleDialogOpen, setIsCreateCycleDialogOpen] = useState(false);
  const [newCycle, setNewCycle] = useState({
    name: "",
    year: new Date().getFullYear(),
    type: "",
    startDate: "",
    endDate: "",
    description: "",
  });

  const { data: evaluations } = trpc.evaluations.list.useQuery({});
  const { data: employee } = trpc.employees.getCurrent.useQuery();
  const { data: cycles, refetch: refetchCycles } = trpc.evaluationCycles.list.useQuery();

  // Mutation para criar ciclo
  const createCycleMutation = trpc.evaluationCycles.create.useMutation({
    onSuccess: () => {
      toast.success(`Ciclo "${newCycle.name}" criado com sucesso!`);
      setIsCreateCycleDialogOpen(false);
      setNewCycle({
        name: "",

------- Avaliar360.tsx -------
import DashboardLayout from "@/components/DashboardLayout";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { trpc } from "@/lib/trpc";
import { AlertCircle, CheckCircle2, ChevronLeft, ChevronRight, Clipboard, Loader2, Send } from "lucide-react";
import { useState, useMemo } from "react";
import { useParams } from "wouter";
import { toast } from "sonner";

/**
 * Página de Formulário de Avaliação 360° Interativo
 * Permite responder avaliações 360° com perguntas organizadas por categoria
 */

export default function Avaliar360() {
  const params = useParams();
  const evaluationId = params.evaluationId ? parseInt(params.evaluationId) : null;

  const [evaluatorType, setEvaluatorType] = useState<"self" | "manager" | "peer" | "subordinate">("self");
  const [currentCategory, setCurrentCategory] = useState(0);
  const [responses, setResponses] = useState<Record<number, { score?: number; text?: string }>>({});

  // Buscar perguntas
  const { data: questions, isLoading } = trpc.evaluation360.getQuestions.useQuery();

  // Mutation para submeter feedback
  const submitFeedbackMutation = trpc.evaluation360.submitFeedback.useMutation({
    onSuccess: () => {
      toast.success("Resposta salva com sucesso!");
    },
    onError: (error) => {
      toast.error(`Erro ao salvar resposta: ${error.message}`);
    },
  });

  // Agrupar perguntas por categoria
  const categorizedQuestions = useMemo(() => {
    if (!questions) return [];
    
    const categories: Record<string, typeof questions> = {};
    questions.forEach(q => {
      const cat = q.category || "Sem Categoria";
      if (!categories[cat]) categories[cat] = [];
      categories[cat].push(q);
    });


------- Badges.tsx -------
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { trpc } from "@/lib/trpc";
import { Trophy, Award, Star, Lock, TrendingUp } from "lucide-react";
import * as LucideIcons from "lucide-react";

export default function Badges() {
  const { data: allBadges, isLoading: loadingBadges } = trpc.badges.getBadges.useQuery();
  const { data: myBadges, isLoading: loadingMyBadges } = trpc.badges.getEmployeeBadges.useQuery({});
  const { data: ranking, isLoading: loadingRanking } = trpc.badges.getRanking.useQuery({ limit: 10 });
  const { data: stats } = trpc.badges.getStats.useQuery();

  const earnedBadgeIds = new Set(myBadges?.badges.map((b) => b.badgeId) || []);

  const getIcon = (iconName: string | null) => {
    if (!iconName) return Trophy;
    const Icon = (LucideIcons as any)[iconName];
    return Icon || Trophy;
  };

  const getCategoryColor = (category: string) => {
    const colors: Record<string, string> = {
      metas: "bg-blue-500",
      pdi: "bg-green-500",
      avaliacao: "bg-purple-500",
      feedback: "bg-orange-500",
      geral: "bg-gray-500",
    };
    return colors[category] || "bg-gray-500";
  };

  if (loadingBadges || loadingMyBadges || loadingRanking) {
    return (
      <div className="container py-8">
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto mb-4"></div>
            <p className="text-muted-foreground">Carregando badges...</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="container py-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold mb-2">🏆 Conquistas e Badges</h1>
        <p className="text-muted-foreground">

------- Calibracao.tsx -------
import DashboardLayout from "@/components/DashboardLayout";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { trpc } from "@/lib/trpc";
import { AlertCircle, ArrowDownUp, CheckCircle2, Edit, History, Loader2, TrendingDown, TrendingUp } from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";

/**
 * Página de Calibração de Avaliações
 * Permite ajustar notas de avaliações em reuniões de consenso
 */

export default function Calibracao() {
  const [selectedEvaluation, setSelectedEvaluation] = useState<any | null>(null);
  const [showCalibrationDialog, setShowCalibrationDialog] = useState(false);
  const [showHistoryDialog, setShowHistoryDialog] = useState(false);
  const [calibrationData, setCalibrationData] = useState({
    originalScore: 0,
    newScore: 0,
    reason: "",
  });

  // Buscar avaliações
  const { data: evaluations, isLoading, refetch } = trpc.calibration.getEvaluations.useQuery({});

  // Buscar histórico de calibração
  const { data: history } = trpc.calibration.getHistory.useQuery(
    { evaluationId: selectedEvaluation?.id || 0 },
    { enabled: !!selectedEvaluation && showHistoryDialog }
  );

  // Mutation para salvar calibração
  const saveCalibrationMutation = trpc.calibration.saveCalibration.useMutation({
    onSuccess: () => {
      toast.success("Calibração salva com sucesso!");
      setShowCalibrationDialog(false);
      refetch();

------- CentrosCusto.tsx -------
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { DollarSign } from "lucide-react";

export default function CentrosCusto() {
  return (
    <DashboardLayout>
      <div className="space-y-6">
        <div className="flex items-center gap-2">
          <DollarSign className="h-8 w-8" />
          <h1 className="text-3xl font-bold">Centros de Custo</h1>
        </div>
        <Card>
          <CardHeader>
            <CardTitle>Em desenvolvimento</CardTitle>
          </CardHeader>
          <CardContent>
            <p>Página de gestão de centros de custo em desenvolvimento.</p>
          </CardContent>
        </Card>
      </div>
    </DashboardLayout>
  );
}

------- ComponentShowcase.tsx -------
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AspectRatio } from "@/components/ui/aspect-ratio";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselNext,
  CarouselPrevious,
} from "@/components/ui/carousel";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {

------- ConfiguracaoBonus.tsx -------
import { useState } from "react";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Plus, Edit, Trash2, DollarSign, Percent } from "lucide-react";
import { toast } from "sonner";

/**
 * Página de Configuração de Bônus por Função
 * Permite cadastrar quantos salários cada função tem direito + bônus extra em %
 */
export default function ConfiguracaoBonus() {
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editingConfig, setEditingConfig] = useState<any>(null);

  // Form state
  const [selectedPositionId, setSelectedPositionId] = useState<string>("");
  const [baseSalaryMultiplier, setBaseSalaryMultiplier] = useState("");
  const [extraBonusPercentage, setExtraBonusPercentage] = useState("");

  // Queries
  const { data: configs = [], refetch } = trpc.bonus.listConfigs.useQuery();
  const { data: positions = [] } = trpc.positions.list.useQuery();

------- ConfiguracaoIntegracoes.tsx -------
import { useState, useEffect } from "react";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { toast } from "sonner";
import { MessageSquare, Send, Video, CheckCircle } from "lucide-react";

/**
 * Página de Configuração de Integrações Externas
 * Microsoft Teams, Slack e Google Meet
 */
export default function ConfiguracaoIntegracoes() {
  const [teamsWebhook, setTeamsWebhook] = useState("");
  const [slackWebhook, setSlackWebhook] = useState("");
  const [slackChannel, setSlackChannel] = useState("#geral");
  const [googleMeetEnabled, setGoogleMeetEnabled] = useState(false);

  const utils = trpc.useUtils();

  // Queries
  const { data: config, isLoading } = trpc.integrations.getConfig.useQuery();

  // Mutations
  const saveConfigMutation = trpc.integrations.saveConfig.useMutation({
    onSuccess: () => {
      toast.success("Configurações salvas com sucesso!");
      utils.integrations.getConfig.invalidate();
    },
    onError: (error) => {
      toast.error(`Erro: ${error.message}`);
    },
  });

  const testTeamsMutation = trpc.integrations.testTeams.useMutation({
    onSuccess: ({ success }) => {
      if (success) {
        toast.success("Teste enviado com sucesso! Verifique o canal do Teams.");
      } else {
        toast.error("Falha ao enviar teste. Verifique o webhook.");
      }
    },
    onError: (error) => {
      toast.error(`Erro: ${error.message}`);
    },
  });

  const testSlackMutation = trpc.integrations.testSlack.useMutation({

------- ConfiguracaoWorkflowsBonus.tsx -------
import { useState } from "react";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import {
  Workflow,
  Plus,
  Trash2,
  Edit,
  Users,
  CheckCircle2,
  ArrowRight,
  Settings,
} from "lucide-react";

/**
 * Página de Configuração de Workflows de Bônus
 * Interface para criar e gerenciar workflows personalizados de aprovação
 */
export default function ConfiguracaoWorkflowsBonus() {
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [workflowName, setWorkflowName] = useState("");
  const [selectedApprovers, setSelectedApprovers] = useState<
    Array<{ level: number; approverId: number; approverName: string; role: string }>
  >([]);
  const [currentLevel, setCurrentLevel] = useState(1);
  const [selectedEmployee, setSelectedEmployee] = useState<number | null>(null);
  const [selectedRole, setSelectedRole] = useState<string>("manager");

  // Buscar workflows existentes
  const { data: workflows, refetch } = trpc.bonus.listWorkflows.useQuery();

------- Configuracoes.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { toast } from "sonner";
import { Settings, Database, Mail, Building2, Award, Calendar } from "lucide-react";

export default function Configuracoes() {
  const [emailEnabled, setEmailEnabled] = useState(true);
  const [totvsEnabled, setTotvsEnabled] = useState(false);

  const handleSaveGeneral = () => {
    toast.success("Configurações gerais salvas com sucesso!");
  };

  const handleSaveEmail = () => {
    toast.success("Configurações de e-mail salvas com sucesso!");
  };

  const handleSaveTOTVS = () => {
    toast.success("Configurações TOTVS salvas com sucesso!");
  };

  const handleTestEmail = () => {
    toast.info("Enviando e-mail de teste...");
    setTimeout(() => {
      toast.success("E-mail de teste enviado com sucesso!");
    }, 2000);
  };

  const handleTestTOTVS = () => {
    toast.info("Testando conexão TOTVS...");
    setTimeout(() => {
      toast.success("Conexão TOTVS estabelecida com sucesso!");
    }, 2000);
  };

  return (
    <DashboardLayout>
      <div className="space-y-6">
        <div>
          <h1 className="text-3xl font-bold">Configurações do Sistema</h1>
          <p className="text-muted-foreground">
            Gerencie as configurações gerais do sistema AVD UISA
          </p>
        </div>

------- ConfiguracoesSMTP.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { trpc } from "@/lib/trpc";
import { Mail, Save, Send, Loader2 } from "lucide-react";
import { toast } from "sonner";

/**
 * Configurações SMTP
 * 
 * Página para configurar servidor SMTP para envio de e-mails
 */

export default function ConfiguracoesSMTP() {
  const [config, setConfig] = useState({
    host: "",
    port: 587,
    secure: false,
    user: "",
    password: "",
    fromEmail: "",
    fromName: "Sistema AVD UISA",
  });

  const [testEmail, setTestEmail] = useState("rodrigo.goncalves@uisa.com.br");

  // Buscar configuração existente
  const { data: existingConfig, isLoading } = trpc.smtpConfig.get.useQuery();

  // Mutation para salvar configuração
  const saveConfigMutation = trpc.smtpConfig.save.useMutation({
    onSuccess: () => {
      toast.success("Configuração SMTP salva com sucesso!");
    },
    onError: (error) => {
      toast.error(`Erro ao salvar configuração: ${error.message}`);
    },
  });

  // Mutation para testar e-mail
  const sendTestMutation = trpc.email.sendTest.useMutation({
    onSuccess: () => {
      toast.success(`E-mail de teste enviado para ${testEmail}!`);
    },
    onError: (error) => {
      toast.error(`Erro ao enviar e-mail: ${error.message}`);

------- CriarMetaSMART.tsx -------
import { useState } from "react";
import { useLocation } from "wouter";
import { formatCurrency, parseCurrency, formatCurrencyInput } from "@/lib/currency";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { toast } from "sonner";
import {
  CheckCircle2,
  XCircle,
  AlertCircle,
  ArrowLeft,
  ArrowRight,
  Save,
  Target,
} from "lucide-react";

/**
 * Wizard de Criação de Meta SMART
 * Validação em tempo real dos 5 critérios SMART
 */
export default function CriarMetaSMART() {
  const [, setLocation] = useLocation();
  // Toast já importado do sonner
  const [step, setStep] = useState(1);

  // Form state
  const [formData, setFormData] = useState({
    title: "",
    description: "",
    type: "individual" as "individual" | "team" | "organizational",
    category: "development" as "financial" | "behavioral" | "corporate" | "development",
    measurementUnit: "",
    targetValue: "",
    weight: "10",
    startDate: "",
    endDate: "",

------- DashboardBonusRH.tsx -------
import { useState } from "react";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  DollarSign,
  TrendingUp,
  Users,
  CheckCircle2,
  Clock,
  XCircle,
  Search,
  FileText,
  Send,
} from "lucide-react";
import { toast } from "sonner";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";

/**
 * Dashboard de RH para Gestão de Bônus
 * Visualização consolidada, cálculo de elegibilidade e aprovação de bônus
 */

------- DashboardComparativoTestes.tsx -------
import { useState } from "react";
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Loader2, TrendingUp, Users, Building2, Briefcase } from "lucide-react";
import { Radar, RadarChart, PolarGrid, PolarAngleAxis, PolarRadiusAxis, ResponsiveContainer, Legend, Tooltip } from "recharts";

/**
 * Dashboard Comparativo de Testes Psicométricos
 * Visualiza resultados agregados por departamento, cargo ou equipe
 */

const TEST_OPTIONS = [
  { value: "disc", label: "DISC - Comportamental" },
  { value: "bigfive", label: "Big Five - Personalidade" },
  { value: "mbti", label: "MBTI - Tipo de Personalidade" },
  { value: "ie", label: "Inteligência Emocional" },
  { value: "vark", label: "Estilos de Aprendizagem" },
  { value: "leadership", label: "Estilos de Liderança" },
  { value: "careeranchors", label: "Âncoras de Carreira" },
];

const GROUP_OPTIONS = [
  { value: "department", label: "Departamento", icon: Building2 },
  { value: "position", label: "Cargo", icon: Briefcase },
  { value: "team", label: "Equipe (Gestor)", icon: Users },
];

export default function DashboardComparativoTestes() {
  const { user } = useAuth();
  const [groupBy, setGroupBy] = useState<"department" | "position" | "team">("department");
  const [testType, setTestType] = useState<string>("disc");

  // Buscar resultados agregados
  const { data: aggregatedData, isLoading } = trpc.psychometric.getAggregatedResults.useQuery({
    groupBy,
    testType: testType as any,
  });

  // Preparar dados para gráfico radar DISC
  const prepareDiscRadarData = (group: any) => {
    if (!group.averages?.disc) return [];
    return [
      { dimension: "Dominância", value: group.averages.disc.D },
      { dimension: "Influência", value: group.averages.disc.I },
      { dimension: "Estabilidade", value: group.averages.disc.S },
      { dimension: "Conformidade", value: group.averages.disc.C },

------- DashboardEmails.tsx -------
import { useState } from "react";
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { toast } from "sonner";
import { Mail, Search, RefreshCw, CheckCircle2, XCircle, Clock, TrendingUp, TrendingDown } from "lucide-react";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";

export default function DashboardEmails() {
  const { user, loading: authLoading } = useAuth();
  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilter, setStatusFilter] = useState<string>("all");
  const [typeFilter, setTypeFilter] = useState<string>("all");

  // Queries
  const { data: emailMetrics, isLoading, refetch } = trpc.emails.getMetrics.useQuery();
  const { data: emailHistory } = trpc.emails.getHistory.useQuery();

  // Mutations
  const resendEmailMutation = trpc.emails.resend.useMutation({
    onSuccess: () => {
      toast.success("Email reenviado com sucesso!");
      refetch();
    },
    onError: (error: any) => {
      toast.error(`Erro ao reenviar: ${error.message}`);
    },
  });

  const handleResend = (emailId: number) => {
    if (confirm("Deseja realmente reenviar este email?")) {
      resendEmailMutation.mutate({ emailId });
    }
  };

  if (authLoading || !user) {
    return (
      <DashboardLayout>
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-orange-600 mx-auto"></div>
            <p className="mt-4 text-gray-600">Carregando...</p>
          </div>

------- DashboardExecutivo.tsx -------
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { 
  BarChart3, 
  TrendingUp, 
  Users, 
  Activity, 
  AlertTriangle, 
  Download,
  ArrowLeft,
  Trophy,
  Target
} from "lucide-react";
import { Link } from "wouter";
import { exportDashboardExecutivo } from "@/lib/exportPDF";
import { toast } from "sonner";
import {
  BarChart,
  Bar,
  LineChart,
  Line,
  PieChart,
  Pie,
  Cell,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from "recharts";
import { useState } from "react";

/**
 * Dashboard Executivo - Visão consolidada de performance e talentos
 * Baseado nas telas de referência UISA
 */
export default function DashboardExecutivo() {
  const [selectedDepartment, setSelectedDepartment] = useState<string>("todos");

  // Queries
  const { data: kpis, isLoading: kpisLoading } = trpc.executive.getKPIs.useQuery({});
  const { data: performanceByDept, isLoading: perfDeptLoading } =
    trpc.executive.getPerformanceByDepartment.useQuery({});
  const { data: performanceTrend, isLoading: perfTrendLoading } =
    trpc.executive.getPerformanceTrend.useQuery();
  const { data: successionCoverage, isLoading: successionLoading } =

------- DashboardGestor.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { trpc } from "@/lib/trpc";
import {
  Users,
  Target,
  TrendingUp,
  AlertCircle,
  CheckCircle2,
  Clock,
  BarChart3,
  FileText,
  Award,
} from "lucide-react";
import { useAuth } from "@/_core/hooks/useAuth";

/**
 * Dashboard Específico para Gestores
 * 
 * Visão consolidada da equipe direta do gestor logado:
 * - KPIs da equipe (performance média, metas, PDIs)
 * - Lista de subordinados diretos
 * - Metas da equipe com progresso
 * - Avaliações pendentes
 * - PDIs da equipe
 * - Gráficos de performance
 */

export default function DashboardGestor() {
  const { user } = useAuth();
  const [selectedTab, setSelectedTab] = useState("visao-geral");

  // Queries
  const { data: teamData, isLoading: teamLoading } = trpc.employees.getTeamByManager.useQuery(
    { managerId: user?.id || 0 },
    { enabled: !!user?.id }
  );

  const { data: teamGoals, isLoading: goalsLoading } = trpc.goals.getTeamGoals.useQuery(
    { managerId: user?.id || 0 },
    { enabled: !!user?.id }
  );

  const { data: teamPDIs, isLoading: pdisLoading } = trpc.pdi.getTeamPDIs.useQuery(
    { managerId: user?.id || 0 },

------- Departamentos.tsx -------
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Building2 } from "lucide-react";

export default function Departamentos() {
  return (
    <DashboardLayout>
      <div className="space-y-6">
        <div className="flex items-center gap-2">
          <Building2 className="h-8 w-8" />
          <h1 className="text-3xl font-bold">Departamentos</h1>
        </div>
        <Card>
          <CardHeader>
            <CardTitle>Em desenvolvimento</CardTitle>
          </CardHeader>
          <CardContent>
            <p>Página de gestão de departamentos em desenvolvimento.</p>
          </CardContent>
        </Card>
      </div>
    </DashboardLayout>
  );
}

------- DetalhesMeta.tsx -------
import { useState } from "react";
import { useParams, useLocation, Link } from "wouter";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Textarea } from "@/components/ui/textarea";
import { Separator } from "@/components/ui/separator";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { toast } from "sonner";
import {
  Target,
  TrendingUp,
  Calendar,
  DollarSign,
  CheckCircle2,
  XCircle,
  Clock,
  AlertCircle,
  ArrowLeft,
  Edit,
  MessageSquare,
  FileText,
  Users,
  Award,
  Download,
  Mail,
} from "lucide-react";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";

/**
 * Página de Detalhes da Meta Individual
 * Exibe informações completas, marcos, aprovações e comentários
 */
export default function DetalhesMeta() {
  const { id } = useParams();
  const [, navigate] = useLocation();
  const [commentText, setCommentText] = useState("");
  const [showCommentDialog, setShowCommentDialog] = useState(false);

  // Enviar e-mail

------- EditarMeta.tsx -------
import { useState, useEffect } from "react";
import { useParams, useLocation } from "wouter";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { toast } from "sonner";
import { ArrowLeft, Save, AlertCircle } from "lucide-react";

/**
 * Página de Edição de Meta em Rascunho
 * Permite editar metas que ainda não foram enviadas para aprovação
 */
export default function EditarMeta() {
  const { id } = useParams();
  const [, navigate] = useLocation();
  const goalId = parseInt(id || "0");

  // Buscar meta
  const { data: goal, isLoading } = trpc.smartGoals.getById.useQuery({ goalId });

  // Form state
  const [formData, setFormData] = useState({
    title: "",
    description: "",
    type: "individual" as "individual" | "team" | "organizational",
    category: "development" as "financial" | "behavioral" | "corporate" | "development",
    measurementUnit: "",
    targetValue: "",
    weight: "10",
    startDate: "",
    endDate: "",
    bonusEligible: false,
    bonusPercentage: "",
    bonusAmount: "",
  });

  // Atualizar meta
  const updateMutation = trpc.smartGoals.update.useMutation({
    onSuccess: () => {

------- EmailMetrics.tsx -------
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Loader2, Mail, CheckCircle2, XCircle, TrendingUp, ShieldAlert, BarChart3 } from "lucide-react";
import { Line, Pie, Bar } from "react-chartjs-2";
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend,
  Filler,
} from "chart.js";

// Registrar componentes do Chart.js
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend,
  Filler
);

/**
 * Dashboard de Métricas de E-mail
 * Visualização de estatísticas de envio de e-mails
 */

export default function EmailMetrics() {
  const { user } = useAuth();

  // Buscar estatísticas agregadas
  const { data: stats, isLoading } = trpc.admin.getEmailStats.useQuery();

  // Verificar se é admin
  if (user?.role !== "admin") {
    return (
      <DashboardLayout>

------- EnviarTestes.tsx -------
import { useState } from "react";
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import { Loader2, Mail, Send, Users, Building2, CheckCircle2, XCircle, Brain } from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";

/**
 * Página de Envio de Testes Psicométricos
 * Permite RH enviar convites de testes para funcionários, equipes ou departamentos
 */

const TESTS = [
  { value: "disc", label: "DISC - Avaliação Comportamental", time: "10-15 min", questions: 40 },
  { value: "bigfive", label: "Big Five (OCEAN) - Personalidade", time: "12-18 min", questions: 50 },
  { value: "mbti", label: "MBTI - Tipo de Personalidade", time: "8-12 min", questions: 40 },
  { value: "ie", label: "Inteligência Emocional (Goleman)", time: "15-20 min", questions: 40 },
  { value: "vark", label: "VARK - Estilos de Aprendizagem", time: "8-10 min", questions: 40 },
  { value: "leadership", label: "Estilos de Liderança", time: "10-12 min", questions: 30 },
  { value: "careeranchors", label: "Âncoras de Carreira (Schein)", time: "12-15 min", questions: 40 },
];

export default function EnviarTestes() {
  const { user } = useAuth();
  const [selectedTest, setSelectedTest] = useState<string>("");
  const [selectedEmails, setSelectedEmails] = useState<string[]>([]);
  const [manualEmail, setManualEmail] = useState("");
  const [sendingIndividual, setSendingIndividual] = useState(false);
  const [sendingTeam, setSendingTeam] = useState(false);
  const [sendingDepartment, setSendingDepartment] = useState(false);
  const [results, setResults] = useState<any[]>([]);

  // Buscar funcionários
  const { data: employees, isLoading: loadingEmployees } = trpc.employees.list.useQuery();

  // Buscar departamentos
  const { data: departments, isLoading: loadingDepartments } = trpc.departments.list.useQuery();

  // Mutation para enviar convites
  const sendInviteMutation = trpc.psychometric.sendTestInvite.useMutation({
    onSuccess: (data) => {
      setResults(data.results);

------- ExecutiveDashboard.tsx -------
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useState } from "react";
import { Users, TrendingUp, Award, Target, DollarSign, Briefcase, AlertCircle } from "lucide-react";
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { CostCenterFilter } from "@/components/CostCenterFilter";
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend,
  Filler,
} from "chart.js";
import { Line, Bar, Doughnut } from "react-chartjs-2";

// Registrar componentes do Chart.js
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend,
  Filler
);

/**
 * Dashboard Executivo
 * Métricas estratégicas para tomada de decisão da diretoria
 */
export default function ExecutiveDashboard() {
  const { user, loading } = useAuth();
  const [selectedDepartment, setSelectedDepartment] = useState<number | undefined>(undefined);
  const [selectedCostCenter, setSelectedCostCenter] = useState<string>("all");

  // Queries - DEVEM estar antes dos returns condicionais (regra dos React Hooks)
  const { data: kpis, isLoading: loadingKPIs } = trpc.executive.getKPIs.useQuery({
    departmentId: selectedDepartment,
    costCenter: selectedCostCenter !== 'all' ? selectedCostCenter : undefined,

------- Feedbacks.tsx -------
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { trpc } from "@/lib/trpc";
import { MessageSquare, ThumbsUp, AlertCircle, TrendingUp, Plus } from "lucide-react";
import { toast } from "sonner";
import { useAuth } from "@/_core/hooks/useAuth";

export default function Feedbacks() {
  const { user } = useAuth();
  const [selectedEmployee, setSelectedEmployee] = useState<number | undefined>();
  const [filterType, setFilterType] = useState<"positivo" | "construtivo" | "desenvolvimento" | undefined>();
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  // Form state
  const [formData, setFormData] = useState({
    employeeId: "",
    type: "positivo" as "positivo" | "construtivo" | "desenvolvimento",
    category: "",
    content: "",
    context: "",
    actionItems: "",
    isPrivate: false,
  });

  const { data: employees } = trpc.employees.list.useQuery();
  const { data: feedbacks, refetch } = trpc.feedback.list.useQuery({
    employeeId: selectedEmployee,
    type: filterType,
  });
  const { data: stats } = trpc.feedback.getStats.useQuery({
    employeeId: selectedEmployee,
  });

  const createMutation = trpc.feedback.create.useMutation({
    onSuccess: () => {
      toast.success("Feedback registrado com sucesso!");
      setIsDialogOpen(false);
      refetch();
      // Reset form
      setFormData({
        employeeId: "",
        type: "positivo",
        category: "",

------- Funcionarios.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import { Loader2, Plus, Search, Pencil, Trash2, Download, Upload, Users } from "lucide-react";

/**
 * Página de Gestão de Funcionários
 * CRUD completo com importação/exportação
 */

export default function Funcionarios() {
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedDepartment, setSelectedDepartment] = useState<string>("all");
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [selectedEmployee, setSelectedEmployee] = useState<any>(null);

  // Buscar funcionários
  const { data: employees, isLoading, refetch } = trpc.employees.list.useQuery();

  // Buscar departamentos
  const { data: departments } = trpc.departments.list.useQuery();

  // Filtrar funcionários
  const filteredEmployees = employees?.filter((emp) => {
    const matchesSearch = emp.employee.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      emp.employee.email.toLowerCase().includes(searchTerm.toLowerCase()) ||
      emp.employee.employeeCode.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesDepartment = selectedDepartment === "all" || emp.employee.departmentId === parseInt(selectedDepartment);
    return matchesSearch && matchesDepartment;
  });

  const handleEdit = (employee: any) => {
    setSelectedEmployee(employee);
    setIsEditDialogOpen(true);
  };

  const handleExport = () => {
    // TODO: Implementar exportação para Excel
    toast.success("Exportação iniciada!");
  };

------- FuncionariosAtivos.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import { Loader2, Plus, Search, Pencil, Trash2, Download, Upload, Users } from "lucide-react";

/**
 * Página de Gestão de Funcionários Ativos UISA
 * Formulário completo com todos os campos necessários
 */

export default function FuncionariosAtivos() {
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedDepartment, setSelectedDepartment] = useState<string>("all");
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [selectedEmployee, setSelectedEmployee] = useState<any>(null);

  // Form state
  const [formData, setFormData] = useState({
    employeeCode: "",
    name: "",
    email: "",
    cpf: "",
    birthDate: "",
    hireDate: "",
    departmentId: "",
    positionId: "",
    managerId: "",
    salary: "",
    hierarchyLevel: "",
    phone: "",
    address: "",
  });

  // Queries
  const utils = trpc.useUtils();
  const { data: employees, isLoading } = trpc.employees.list.useQuery();
  const { data: departments } = trpc.departments.list.useQuery();
  const { data: positions } = trpc.positions.list.useQuery();

  // Mutations
  const updateEmployeeMutation = trpc.employees.update.useMutation({

------- HierarquiaImport.tsx -------
import { useState } from "react";
import { useLocation } from "wouter";
import { trpc } from "@/lib/trpc";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Upload, Download, CheckCircle2, XCircle, AlertCircle, ArrowLeft } from "lucide-react";
import { toast } from "sonner";
import DashboardLayout from "@/components/DashboardLayout";

interface ImportRow {
  employeeId: number;
  name: string;
  newManagerId?: number;
  newCostCenter?: string;
  status: 'pending' | 'success' | 'error';
  error?: string;
}

export default function HierarquiaImport() {
  const [, setLocation] = useLocation();
  const [file, setFile] = useState<File | null>(null);
  const [previewData, setPreviewData] = useState<ImportRow[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);

  const updateEmployeeMutation = trpc.employees.updateEmployee.useMutation();

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0];
    if (selectedFile) {
      setFile(selectedFile);
      processFile(selectedFile);
    }
  };

  const processFile = async (file: File) => {
    try {
      const text = await file.text();
      const lines = text.split('\n').filter(line => line.trim());
      
      if (lines.length < 2) {
        toast.error("Arquivo vazio ou inválido");
        return;
      }

      // Assumindo CSV com cabeçalho: employeeId,name,newManagerId,newCostCenter
      const headers = lines[0].split(',').map(h => h.trim());
      const data: ImportRow[] = [];


------- HierarquiaOrganizacional.tsx -------
import { useState } from "react";
import { useLocation } from "wouter";
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { toast } from "sonner";
import { Users, Building2, Search, Edit, ChevronRight, ChevronDown, User, Upload, Download } from "lucide-react";

interface TreeNode {
  employee: any;
  subordinates: TreeNode[];
  isExpanded: boolean;
}

export default function HierarquiaOrganizacional() {
  const [, setLocation] = useLocation();
  const { user, loading: authLoading } = useAuth();
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedDepartment, setSelectedDepartment] = useState<string>("all");
  const [editingEmployee, setEditingEmployee] = useState<any>(null);
  const [newManagerId, setNewManagerId] = useState<string>("");
  const [newCostCenter, setNewCostCenter] = useState<string>("");
  const [expandedNodes, setExpandedNodes] = useState<Set<number>>(new Set());

  // Queries
  const { data: hierarchy, isLoading: loadingHierarchy, refetch } = trpc.employees.getHierarchy.useQuery();
  const { data: departments } = trpc.employees.getDepartments.useQuery();
  const { data: managers } = trpc.employees.getManagers.useQuery();

  // Queries para relatório
  const { data: reportData, refetch: refetchReport } = trpc.employees.exportHierarchyReport.useQuery(undefined, {
    enabled: false,
  });

  const handleDownloadReport = async () => {
    try {
      const result = await refetchReport();
      if (!result.data) {
        toast.error("Erro ao gerar relatório");
        return;
      }

      // Gerar relatório em formato texto

------- History.tsx -------
import { useAuth } from "@/_core/hooks/useAuth";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import { Calendar, TrendingUp, Award, Target, BarChart3 } from "lucide-react";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";

export default function History() {
  const { user } = useAuth();
  
  const { data: employee } = trpc.employees.getByUserId.useQuery(
    { userId: user?.id || 0 },
    { enabled: !!user }
  );

  const { data: evaluations = [], isLoading: loadingEvaluations } = trpc.history.evaluations.useQuery(
    { employeeId: employee?.id || 0 },
    { enabled: !!employee }
  );

  const { data: pdis = [], isLoading: loadingPdis } = trpc.history.pdis.useQuery(
    { employeeId: employee?.id || 0 },
    { enabled: !!employee }
  );

  const { data: nineBoxHistory = [], isLoading: loadingNineBox } = trpc.history.nineBox.useQuery(
    { employeeId: employee?.id || 0 },
    { enabled: !!employee }
  );

  const { data: competencies = [], isLoading: loadingCompetencies } = trpc.history.competenciesEvolution.useQuery(
    { employeeId: employee?.id || 0 },
    { enabled: !!employee }
  );

  const getStatusBadge = (status: string) => {
    const variants: Record<string, "default" | "secondary" | "destructive" | "outline"> = {
      concluida: "default",
      em_andamento: "secondary",
      pendente: "outline",
      cancelada: "destructive",
    };
    
    const labels: Record<string, string> = {
      concluida: "Concluída",
      em_andamento: "Em Andamento",
      pendente: "Pendente",
      cancelada: "Cancelada",

------- Home.tsx -------
import { trpc } from "@/lib/trpc";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { BarChart3, Goal, Target, TrendingUp, Users, AlertCircle } from "lucide-react";
import { Link } from "wouter";

export default function Home() {
  const { data: employee } = trpc.employees.getCurrent.useQuery();
  const { data: stats } = trpc.dashboard.getStats.useQuery({});
  const { data: goals } = trpc.goals.list.useQuery({});
  const { data: pdis } = trpc.pdi.list.useQuery({});

  const activeGoals = goals?.filter(g => g.status === "em_andamento") || [];
  const activePDIs = pdis?.filter(p => p.status === "em_andamento" || p.status === "aprovado") || [];

  return (
    <DashboardLayout>
      <div className="space-y-8">
        {/* Header */}
        <div>
          <h1 className="text-3xl font-bold tracking-tight">
            Olá, {employee?.name || "Colaborador"}! 👋
          </h1>
          <p className="text-muted-foreground mt-2">
            Acompanhe seu desempenho e desenvolvimento profissional
          </p>
        </div>

        {/* Stats Cards */}
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Metas Ativas</CardTitle>
              <Target className="h-4 w-4 text-muted-foreground" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{stats?.goalsCount || 0}</div>
              <p className="text-xs text-muted-foreground">
                {activeGoals.length} em andamento
              </p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Avaliações</CardTitle>
              <Users className="h-4 w-4 text-muted-foreground" />

------- Metas.tsx -------
import DashboardLayout from "@/components/DashboardLayout";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Progress } from "@/components/ui/progress";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { trpc } from "@/lib/trpc";
import { downloadICS } from "@/lib/generateICS";
import { AlertCircle, Calendar, CalendarPlus, CheckCircle2, Clock, Plus, Target, TrendingUp } from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";

export default function Metas() {
  const [open, setOpen] = useState(false);
  const [editingGoal, setEditingGoal] = useState<any>(null);
  
  const { data: goals, refetch } = trpc.goals.list.useQuery({});
  const { data: employee } = trpc.employees.getCurrent.useQuery();
  const createGoal = trpc.goals.create.useMutation();
  const updateProgress = trpc.goals.updateProgress.useMutation();

  const [formData, setFormData] = useState({
    title: "",
    description: "",
    type: "individual" as "individual" | "equipe" | "organizacional",
    category: "quantitativa" as "quantitativa" | "qualitativa",
    targetValue: "",
    unit: "",
    weight: 1,
    startDate: new Date().toISOString().split('T')[0],
    endDate: "",
    linkedToPLR: false,
    linkedToBonus: false,
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!employee?.id) {
      toast.error("Colaborador não encontrado");
      return;
    }

    try {
      await createGoal.mutateAsync({
        ...formData,

------- MetasSMART.tsx -------
import { useState } from "react";
import { Link } from "wouter";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Target,
  TrendingUp,
  DollarSign,
  CheckCircle2,
  Clock,
  AlertCircle,
  Plus,
  Filter,
  Calendar,
  Download,
} from "lucide-react";
import { toast } from "sonner";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";

/**
 * Dashboard de Metas SMART
 * Exibe KPIs, gráficos e lista de metas do colaborador
 */
export default function MetasSMART() {
  const [cycleFilter, setCycleFilter] = useState<number | undefined>(undefined);
  const [statusFilter, setStatusFilter] = useState<string | undefined>(undefined);
  const [categoryFilter, setCategoryFilter] = useState<string | undefined>(undefined);

  // Exportar PDF consolidado
  const exportConsolidatedPDFMutation = trpc.smartGoals.exportConsolidatedPDF.useMutation({
    onSuccess: (data) => {
      const byteCharacters = atob(data.data);
      const byteNumbers = new Array(byteCharacters.length);
      for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
      }
      const byteArray = new Uint8Array(byteNumbers);
      const blob = new Blob([byteArray], { type: "application/pdf" });
      const url = window.URL.createObjectURL(blob);

------- MovimentacaoNineBox.tsx -------
import { useState } from "react";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { MoveRight, Users, AlertCircle } from "lucide-react";
import { toast } from "sonner";

type Performance = "baixo" | "médio" | "alto";
type Potential = "baixo" | "médio" | "alto";

interface EmployeePosition {
  employeeId: number;
  employeeName: string;
  currentPerformance?: Performance;
  currentPotential?: Potential;
}

/**
 * Página de Movimentação de Colaboradores no Nine Box
 * Permite ao RH movimentar colaboradores com justificativa obrigatória
 */
export default function MovimentacaoNineBox() {
  const [selectedEmployee, setSelectedEmployee] = useState<EmployeePosition | null>(null);
  const [toPerformance, setToPerformance] = useState<Performance>("médio");
  const [toPotential, setToPotential] = useState<Potential>("médio");
  const [justification, setJustification] = useState("");
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  const utils = trpc.useUtils();

  // Queries
  const { data: employees } = trpc.employees.list.useQuery();
  // TODO: Implementar endpoint getMatrix no nineBoxRouter

------- NineBox.tsx -------
import { useState } from "react";
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import { Loader2, Users, TrendingUp, Star, AlertCircle, Target, Zap, Clock, Award, Grid3x3 } from "lucide-react";

/**
 * Página de Matriz 9-Box
 * Visualização gráfica com calibração e ajustes manuais
 */

type Employee9Box = {
  id: number;
  name: string;
  position: string;
  department: string;
  performance: number;
  potential: number;
  category: string;
  lastCalibration?: string;
};

const QUADRANT_LABELS = {
  "3-3": { label: "Estrelas", icon: Star, color: "bg-green-500", desc: "Alto desempenho e alto potencial" },
  "3-2": { label: "Talentos", icon: TrendingUp, color: "bg-green-400", desc: "Alto desempenho, potencial médio" },
  "3-1": { label: "Especialistas", icon: Target, color: "bg-yellow-400", desc: "Alto desempenho, baixo potencial" },
  "2-3": { label: "Promessas", icon: Zap, color: "bg-blue-400", desc: "Desempenho médio, alto potencial" },
  "2-2": { label: "Sólidos", icon: Users, color: "bg-gray-400", desc: "Desempenho e potencial médios" },
  "2-1": { label: "Eficazes", icon: Clock, color: "bg-gray-300", desc: "Desempenho médio, baixo potencial" },
  "1-3": { label: "Enigmas", icon: AlertCircle, color: "bg-orange-400", desc: "Baixo desempenho, alto potencial" },
  "1-2": { label: "Dilemmas", icon: AlertCircle, color: "bg-orange-300", desc: "Baixo desempenho, potencial médio" },
  "1-1": { label: "Críticos", icon: AlertCircle, color: "bg-red-500", desc: "Baixo desempenho e baixo potencial" },
};

export default function NineBox() {
  const { user } = useAuth();
  const [selectedCycle, setSelectedCycle] = useState<number | null>(null);
  const [selectedEmployee, setSelectedEmployee] = useState<Employee9Box | null>(null);
  const [adjustmentReason, setAdjustmentReason] = useState("");
  const [newPerformance, setNewPerformance] = useState(2);
  const [newPotential, setNewPotential] = useState(2);
  const [isAdjustDialogOpen, setIsAdjustDialogOpen] = useState(false);

------- NineBoxComparativo.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Loader2, TrendingUp, Users, Award, Download, Filter } from "lucide-react";
import { trpc } from "@/lib/trpc";
import { Bar, Radar } from "react-chartjs-2";
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend,
  RadialLinearScale,
  PointElement,
  LineElement,
  Filler,
} from "chart.js";

ChartJS.register(
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend,
  RadialLinearScale,
  PointElement,
  LineElement,
  Filler
);

/**
 * Página de Nine Box Comparativo por Função/Cargo
 * Permite comparar distribuição Nine Box entre diferentes cargos
 */

export default function NineBoxComparativo() {
  const [selectedPositions, setSelectedPositions] = useState<number[]>([]);
  const [hierarchyLevel, setHierarchyLevel] = useState<string>("all");
  const [selectedLeaderId, setSelectedLeaderId] = useState<number | null>(null);

  // Queries
  const { data: positions, isLoading: loadingPositions } = trpc.nineBoxComparative.getAvailablePositions.useQuery();
  const { data: leaders } = trpc.nineBoxComparative.getLeaders.useQuery();

------- NotFound.tsx -------
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle, Home } from "lucide-react";
import { useLocation } from "wouter";

export default function NotFound() {
  const [, setLocation] = useLocation();

  const handleGoHome = () => {
    setLocation("/");
  };

  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gradient-to-br from-slate-50 to-slate-100">
      <Card className="w-full max-w-lg mx-4 shadow-lg border-0 bg-white/80 backdrop-blur-sm">
        <CardContent className="pt-8 pb-8 text-center">
          <div className="flex justify-center mb-6">
            <div className="relative">
              <div className="absolute inset-0 bg-red-100 rounded-full animate-pulse" />
              <AlertCircle className="relative h-16 w-16 text-red-500" />
            </div>
          </div>

          <h1 className="text-4xl font-bold text-slate-900 mb-2">404</h1>

          <h2 className="text-xl font-semibold text-slate-700 mb-4">
            Page Not Found
          </h2>

          <p className="text-slate-600 mb-8 leading-relaxed">
            Sorry, the page you are looking for doesn't exist.
            <br />
            It may have been moved or deleted.
          </p>

          <div
            id="not-found-button-group"
            className="flex flex-col sm:flex-row gap-3 justify-center"
          >
            <Button
              onClick={handleGoHome}
              className="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2.5 rounded-lg transition-all duration-200 shadow-md hover:shadow-lg"
            >
              <Home className="w-4 h-4 mr-2" />
              Go Home
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>

------- Notificacoes.tsx -------
import { useState } from "react";
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Bell,
  Search,
  Filter,
  CheckCheck,
  Trash2,
  Brain,
  Target,
  Trophy,
  AlertCircle,
  CheckCircle,
  Info,
} from "lucide-react";
import { useLocation } from "wouter";
import { toast } from "sonner";
import { cn } from "@/lib/utils";

/**
 * Página de Histórico de Notificações
 * Lista completa com filtros avançados
 */

export default function Notificacoes() {
  const { user } = useAuth();
  const [, setLocation] = useLocation();
  const [searchQuery, setSearchQuery] = useState("");
  const [typeFilter, setTypeFilter] = useState<string>("all");
  const [statusFilter, setStatusFilter] = useState<string>("all");
  const [periodFilter, setPeriodFilter] = useState<string>("all");

  // Buscar todas as notificações
  const { data: notifications, refetch } = trpc.notifications.list.useQuery({
    limit: 100,
    unreadOnly: statusFilter === "unread",
  });

------- PDI.tsx -------
import DashboardLayout from "@/components/DashboardLayout";
import PDIWizard from "@/components/PDIWizard";
import { useState } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { trpc } from "@/lib/trpc";
import { downloadICS } from "@/lib/generateICS";
import { toast } from "sonner";
import { AlertCircle, BookOpen, Calendar, CalendarPlus, CheckCircle2, Clock, Plus, TrendingUp, Users2, Lightbulb, Brain } from "lucide-react";
import { useLocation } from "wouter";

export default function PDI() {
  const [showWizard, setShowWizard] = useState(false);
  const [, setLocation] = useLocation();
  const { data: pdis } = trpc.pdi.list.useQuery({});
  const { data: employee } = trpc.employees.getCurrent.useQuery();

  const activePDI = pdis?.find(p => p.status === "aprovado" || p.status === "em_andamento");
  const { data: pdiItems } = trpc.pdi.getItems.useQuery(
    { planId: activePDI?.id || 0 },
    { enabled: !!activePDI }
  );

  const getStatusBadge = (status: string) => {
    const variants: Record<string, { variant: any; label: string; icon: any }> = {
      rascunho: { variant: "secondary", label: "Rascunho", icon: Clock },
      pendente_aprovacao: { variant: "outline", label: "Pendente", icon: AlertCircle },
      aprovado: { variant: "default", label: "Aprovado", icon: CheckCircle2 },
      em_andamento: { variant: "default", label: "Em Andamento", icon: TrendingUp },
      concluido: { variant: "default", label: "Concluído", icon: CheckCircle2 },
      cancelado: { variant: "destructive", label: "Cancelado", icon: AlertCircle },
    };

    const config = variants[status] || variants.rascunho;
    const Icon = config.icon;

    return (
      <Badge variant={config.variant} className="gap-1">
        <Icon className="h-3 w-3" />
        {config.label}
      </Badge>
    );
  };

  const getCategoryBadge = (category: string) => {
    const config: Record<string, { label: string; icon: any; color: string }> = {
      "70_pratica": { label: "70% Prática", icon: TrendingUp, color: "bg-blue-500" },

------- PDIInteligente.tsx -------
import { useState } from "react";
import { useRoute } from "wouter";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Progress } from "@/components/ui/progress";
import { Loader2, Target, Users, Calendar, TrendingUp, Download, ArrowLeft, Award } from "lucide-react";
import { trpc } from "@/lib/trpc";
import { Link } from "wouter";
import { exportPDIInteligente } from "@/lib/exportPDF";
import { toast } from "sonner";
import {
  Chart as ChartJS,
  RadialLinearScale,
  PointElement,
  LineElement,
  Filler,
  Tooltip,
  Legend,
} from "chart.js";
import { Radar } from "react-chartjs-2";

ChartJS.register(RadialLinearScale, PointElement, LineElement, Filler, Tooltip, Legend);

/**
 * PDI Inteligente - Modelo Nadia
 * 
 * Estrutura:
 * 1. Desafio Estratégico (contexto, objetivos, 24 meses, 4 envolvidos)
 * 2. Pacto de Desenvolvimento (Sucessor, Gestor, Sponsors, DGC)
 * 3. Diagnóstico de Competências (gráfico radar: atual vs. alvo)
 * 4. Matriz de Gaps (competências + responsabilidades)
 * 5. Plano de Ação 70-20-10 (tabela com status, métricas, responsáveis)
 * 6. Progressão Estratégica (marcos 12 e 24 meses)
 */

export default function PDIInteligente() {
  const [, params] = useRoute("/pdi-inteligente/:id");
  const pdiId = params?.id ? parseInt(params.id) : null;

  // Queries
  const { data: pdi, isLoading } = trpc.pdiIntelligent.getById.useQuery(
    { id: pdiId! },
    { enabled: !!pdiId }
  );

  if (isLoading) {
    return (

------- PDIInteligenteDetalhes.tsx -------
import { useState } from "react";
import { useRoute } from "wouter";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Loader2, Plus, Save, Download, ArrowLeft, TrendingUp, Calendar, Target } from "lucide-react";
import { trpc } from "@/lib/trpc";
import { Link } from "wouter";
import { toast } from "sonner";
import { Line } from "react-chartjs-2";
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from "chart.js";

ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

/**
 * PDI Inteligente - Detalhes com Ações e Acompanhamento
 * Modelo Nadia: Tabela de ações 70-20-10 + Feedbacks DGC + Gráfico IPS
 */

export default function PDIInteligenteDetalhes() {
  const [, params] = useRoute("/pdi-inteligente/:id/detalhes");
  const pdiId = params?.id ? parseInt(params.id) : null;

  const [showAddAction, setShowAddAction] = useState(false);
  const [showAddReview, setShowAddReview] = useState(false);

  // Form states
  const [actionForm, setActionForm] = useState({
    title: "",
    description: "",
    axis: "70_pratica" as "70_pratica" | "20_experiencia" | "10_educacao",
    developmentArea: "",
    successMetric: "",
    evidenceRequired: "",

------- PDIInteligenteNovo.tsx -------
import { useState } from "react";
import { useLocation } from "wouter";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { trpc } from "@/lib/trpc";
import { Brain, Check, ChevronsUpDown, ArrowLeft, Loader2 } from "lucide-react";
import { Link } from "wouter";
import { toast } from "sonner";
import { cn } from "@/lib/utils";
import RecommendationsSection from "@/components/RecommendationsSection";

/**
 * Página de Criação de PDI Inteligente
 * 
 * Wizard completo para criar novo PDI Inteligente com:
 * - Seleção de colaborador (Combobox com 2.889 funcionários)
 * - Seleção de posição-alvo
 * - Contexto estratégico e objetivos
 * - Duração (12, 18, 24, 36 meses)
 * - Análise automática de gaps após criação
 */

export default function PDIInteligenteNovo() {
  const [, setLocation] = useLocation();

  // Form state
  const [employeeOpen, setEmployeeOpen] = useState(false);

------- Perfil.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { toast } from "sonner";
import { User, Bell, Camera, History, Upload } from "lucide-react";
import { useAuth } from "@/_core/hooks/useAuth";
import FaceRegistration from "@/components/FaceRegistration";

export default function Perfil() {
  const { user } = useAuth();
  const [emailNotifications, setEmailNotifications] = useState(true);
  const [pushNotifications, setPushNotifications] = useState(true);
  const [weeklyDigest, setWeeklyDigest] = useState(false);

  const handleSaveProfile = () => {
    toast.success("Perfil atualizado com sucesso!");
  };

  const handleSaveNotifications = () => {
    toast.success("Preferências de notificação salvas!");
  };

  const handleUploadPhoto = () => {
    toast.info("Funcionalidade de upload em desenvolvimento");
  };

  return (
    <DashboardLayout>
      <div className="space-y-6">
        <div>
          <h1 className="text-3xl font-bold">Meu Perfil</h1>
          <p className="text-muted-foreground">
            Gerencie suas informações pessoais e preferências
          </p>
        </div>

        <Tabs defaultValue="dados" className="space-y-4">
          <TabsList className="grid w-full grid-cols-4">
            <TabsTrigger value="dados">
              <User className="h-4 w-4 mr-2" />
              Dados Pessoais
            </TabsTrigger>
            <TabsTrigger value="foto">
              <Camera className="h-4 w-4 mr-2" />

------- PerformanceIntegrada.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from "@/components/ui/select";
import { Progress } from "@/components/ui/progress";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Target, Download, ArrowLeft, Lightbulb } from "lucide-react";
import { CostCenterFilter } from "@/components/CostCenterFilter";
import { Link } from "wouter";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts";

/**
 * Performance Integrada 40-30-30
 * 
 * Estrutura:
 * - Header com score total e breakdown ponderado
 * - Financial Goals (peso 40%)
 * - Behavioral Goals (peso 30%)
 * - Corporate Goals (peso 30%)
 * - Gráfico Breakdown Ponderado
 * - Performance Multi-Dimensional
 * - Evolução Histórica
 * - Recomendações de Desenvolvimento
 */

export default function PerformanceIntegrada() {
  const [selectedEmployee, setSelectedEmployee] = useState("1");
  const [selectedCycle, setSelectedCycle] = useState("2025");
  const [selectedCostCenter, setSelectedCostCenter] = useState<string>("all");

  // Mock data - TODO: integrar com backend
  const performanceData = {
    employee: {
      id: 1,
      name: "Maria Silva",
      position: "Gerente de Vendas",
      department: "Comercial",
    },
    cycle: "Safra 2024/2025",
    totalScore: 0, // Será calculado
    breakdown: {
      financial: { score: 0, weight: 40, goals: [] as any[] },
      behavioral: { score: 0, weight: 30, goals: [] as any[] },
      corporate: { score: 0, weight: 30, goals: [] as any[] },
    },
    financialGoals: [
      { name: "Receita Anual", target: 1000000, achieved: 0, weight: 50 },
      { name: "Margem de Lucro", target: 25, achieved: 0, weight: 30 },

------- PsychometricTests.tsx -------
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Loader2, Brain, TrendingUp, Users, Target, Zap } from "lucide-react";
import { useLocation } from "wouter";
import { Radar, RadarChart, PolarGrid, PolarAngleAxis, PolarRadiusAxis, ResponsiveContainer } from "recharts";

/**
 * Página de Testes Psicométricos
 * Exibe testes disponíveis e resultados anteriores
 */

const DISC_LABELS: Record<string, { name: string; color: string; description: string }> = {
  D: { name: "Dominância", color: "bg-red-500", description: "Direto, orientado a resultados, decisivo" },
  I: { name: "Influência", color: "bg-yellow-500", description: "Sociável, entusiasta, persuasivo" },
  S: { name: "Estabilidade", color: "bg-green-500", description: "Paciente, leal, colaborativo" },
  C: { name: "Conformidade", color: "bg-blue-500", description: "Analítico, preciso, sistemático" },
};

const BIG_FIVE_LABELS: Record<string, { name: string; description: string }> = {
  O: { name: "Abertura", description: "Criatividade e curiosidade intelectual" },
  C: { name: "Conscienciosidade", description: "Organização e responsabilidade" },
  E: { name: "Extroversão", description: "Sociabilidade e energia" },
  A: { name: "Amabilidade", description: "Empatia e cooperação" },
  N: { name: "Neuroticismo", description: "Estabilidade emocional" },
};

export default function PsychometricTests() {
  const { user } = useAuth();
  const [, setLocation] = useLocation();

  // Buscar testes realizados
  const { data: tests, isLoading } = trpc.psychometric.getTests.useQuery();

  const discTests = tests?.filter(t => t.testType === "disc") || [];
  const bigFiveTests = tests?.filter(t => t.testType === "bigfive") || [];
  const mbtiTests = tests?.filter(t => t.testType === "mbti") || [];
  const ieTests = tests?.filter(t => t.testType === "ie") || [];
  const varkTests = tests?.filter(t => t.testType === "vark") || [];

  if (isLoading) {
    return (
      <DashboardLayout>
        <div className="flex items-center justify-center h-96">
          <Loader2 className="w-8 h-8 animate-spin text-primary" />
        </div>
      </DashboardLayout>

------- RankingGamificacao.tsx -------
import { useState } from "react";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Trophy, Medal, Award, TrendingUp, Star } from "lucide-react";
import { useAuth } from "@/_core/hooks/useAuth";

/**
 * Página de Ranking de Gamificação
 * Exibe rankings gerais, mensais e por departamento
 */
export default function RankingGamificacao() {
  const { user } = useAuth();
  const [selectedDepartment, setSelectedDepartment] = useState<number | undefined>();
  const [rankingType, setRankingType] = useState<"geral" | "mensal">("geral");

  // Queries
  const { data: ranking, isLoading } = trpc.gamification.getRanking.useQuery({
    limit: 50,
    departmentId: selectedDepartment,
  });

  const { data: monthlyRanking } = trpc.gamification.getMonthlyRanking.useQuery({
    limit: 10,
  });

  const { data: departments } = trpc.departments.list.useQuery();
  const { data: levels } = trpc.gamification.getLevels.useQuery();
  const { data: myStats } = trpc.gamification.getEmployeeStats.useQuery(
    { employeeId: user?.id || 0 },
    { enabled: !!user?.id }
  );

  const getMedalIcon = (rank: number) => {
    switch (rank) {
      case 1:
        return <Trophy className="w-6 h-6 text-yellow-500" />;
      case 2:
        return <Medal className="w-6 h-6 text-gray-400" />;
      case 3:
        return <Medal className="w-6 h-6 text-amber-600" />;
      default:

------- Relatorios.tsx -------
import DashboardLayout from "@/components/DashboardLayout";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { trpc } from "@/lib/trpc";
import { exportDashboardPDF } from "@/utils/pdfExport";
import { BarChart3, Download, FileText, TrendingUp, Users } from "lucide-react";
import { useState } from "react";

export default function Relatorios() {
  const [selectedPeriod, setSelectedPeriod] = useState("2025");
  const [selectedDepartment, setSelectedDepartment] = useState("all");

  const { data: goals } = trpc.goals.list.useQuery({});
  const { data: evaluations } = trpc.evaluations.list.useQuery({});
  const { data: pdis } = trpc.pdi.list.useQuery({});
  const { data: employeesData } = trpc.employees.list.useQuery();

  // Calculate statistics
  const totalGoals = goals?.length || 0;
  const completedGoals = goals?.filter(g => g.status === "concluida").length || 0;
  const avgGoalProgress = goals?.length 
    ? Math.round(goals.reduce((sum, g) => sum + g.progress, 0) / goals.length)
    : 0;

  const totalEvaluations = evaluations?.length || 0;
  const completedEvaluations = evaluations?.filter(e => e.status === "concluida").length || 0;

  const totalPDIs = pdis?.length || 0;
  const activePDIs = pdis?.filter(p => p.status === "aprovado" || p.status === "em_andamento").length || 0;

  const totalEmployees = employeesData?.length || 0;

  // Mock data for charts (in production, this would come from API)
  const monthlyGoalsData = [
    { month: "Jan", completed: 12, total: 15 },
    { month: "Fev", completed: 18, total: 20 },
    { month: "Mar", completed: 22, total: 25 },
    { month: "Abr", completed: 28, total: 30 },
    { month: "Mai", completed: 25, total: 28 },
    { month: "Jun", completed: 30, total: 32 },
  ];

  const departmentPerformance = [
    { name: "Vendas", score: 8.5, employees: 25 },
    { name: "Marketing", score: 7.8, employees: 15 },
    { name: "TI", score: 9.2, employees: 30 },
    { name: "RH", score: 8.1, employees: 12 },
    { name: "Financeiro", score: 8.7, employees: 18 },

------- RelatoriosExecutivos.tsx -------
import { useState } from "react";
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { 
  FileText, 
  TrendingUp, 
  Users, 
  AlertCircle, 
  Download,
  BarChart3,
  PieChart,
  Target,
  Lightbulb
} from "lucide-react";
import { PieChart as RePieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip, BarChart, Bar, XAxis, YAxis, CartesianGrid } from "recharts";
import { exportRelatorioExecutivoPDF } from "@/utils/pdfExport";
import { toast } from "sonner";

/**
 * Página de Relatórios Executivos de RH
 * Dashboard estratégico com insights organizacionais sobre perfis psicométricos
 */

const COLORS = {
  disc: {
    D: "#ef4444", // red
    I: "#eab308", // yellow
    S: "#22c55e", // green
    C: "#3b82f6", // blue
  },
  priority: {
    high: "#f97316", // orange
    medium: "#eab308", // yellow
    low: "#22c55e", // green
  }
};

export default function RelatoriosExecutivos() {
  const { user } = useAuth();
  const [selectedDepartment, setSelectedDepartment] = useState<number | null>(null);

  // Buscar dados agregados
  const { data: discByDept } = trpc.psychometric.getAggregatedResults.useQuery({
    groupBy: "department",
    testType: "disc",

------- ReportAnalytics.tsx -------
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { trpc } from "@/lib/trpc";
import { BarChart3, FileText, Download, TrendingUp } from "lucide-react";
import { Bar, Line } from "react-chartjs-2";
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from "chart.js";

// Registrar componentes do Chart.js
ChartJS.register(
  CategoryScale,
  LinearScale,
  BarElement,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

export default function ReportAnalytics() {
  const { data: stats, isLoading: statsLoading } = trpc.reportAnalytics.getUsageStats.useQuery();
  const { data: mostUsedMetrics, isLoading: metricsLoading } = trpc.reportAnalytics.getMostUsedMetrics.useQuery();
  const { data: exportHistory, isLoading: historyLoading } = trpc.reportAnalytics.getExportHistory.useQuery({ limit: 20 });
  const { data: trends, isLoading: trendsLoading } = trpc.reportAnalytics.getTrends.useQuery();

  // Dados para gráfico de métricas mais usadas
  const metricsChartData = {
    labels: mostUsedMetrics?.map((m) => m.metric) || [],
    datasets: [
      {
        label: "Número de Usos",
        data: mostUsedMetrics?.map((m) => m.count) || [],
        backgroundColor: "rgba(59, 130, 246, 0.5)",
        borderColor: "rgb(59, 130, 246)",
        borderWidth: 1,
      },
    ],
  };

  // Dados para gráfico de tendências
  const trendsChartData = {

------- ReportBuilder.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { toast } from "sonner";
import { BarChart3, Download, Save, Play } from "lucide-react";
import { generatePDF, generateExcel } from "@/lib/reportGenerators";

export default function ReportBuilder() {
  const [reportName, setReportName] = useState("");
  const [reportDescription, setReportDescription] = useState("");
  const [selectedMetrics, setSelectedMetrics] = useState<string[]>([]);
  const [chartType, setChartType] = useState("bar");
  const [filters, setFilters] = useState<any>({});
  const [filterDepartment, setFilterDepartment] = useState<string>("");
  const [filterPosition, setFilterPosition] = useState<string>("");
  const [filterStartDate, setFilterStartDate] = useState<string>("");
  const [filterEndDate, setFilterEndDate] = useState<string>("");
  const [previewData, setPreviewData] = useState<any>(null);

  const { data: availableMetrics, isLoading: metricsLoading, error: metricsError } = trpc.reportBuilder.getAvailableMetrics.useQuery();
  const { data: savedReports } = trpc.reportBuilder.list.useQuery();
  const { data: departments } = trpc.reportBuilder.getDepartments.useQuery();
  const { data: positions } = trpc.reportBuilder.getPositions.useQuery();
  
  const executeReport = trpc.reportBuilder.execute.useQuery(
    { metrics: selectedMetrics, filters },
    { enabled: false }
  );

  const trackAction = trpc.reportAnalytics.track.useMutation();

  const createReport = trpc.reportBuilder.create.useMutation({
    onSuccess: () => {
      toast.success("Relatório salvo com sucesso!");
      setReportName("");
      setReportDescription("");
    },
    onError: () => {
      toast.error("Erro ao salvar relatório");
    },
  });

  const handleMetricToggle = (metricId: string) => {
    setSelectedMetrics((prev) =>

------- ScheduledReports.tsx -------
import { useState } from "react";
import { trpc } from "@/lib/trpc";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import { Calendar, Clock, FileText, Mail, Play, Trash2, Plus, Download, AlertCircle } from "lucide-react";
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";

/**
 * Página de Relatórios Agendados
 * Permite configurar envio automático de relatórios por e-mail
 */
export default function ScheduledReports() {
  const { user, loading } = useAuth();
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [selectedReport, setSelectedReport] = useState<any>(null);

  // Queries - DEVEM estar antes dos returns condicionais
  const { data: reports, isLoading, refetch } = trpc.scheduledReports.list.useQuery(undefined, { enabled: !loading && user?.role === 'admin' });

  // Mutations
  const createMutation = trpc.scheduledReports.create.useMutation({
    onSuccess: () => {
      toast.success("Relatório agendado criado com sucesso!");
      setIsDialogOpen(false);
      refetch();
    },
    onError: (error) => {
      toast.error(`Erro ao criar relatório: ${error.message}`);
    },
  });

  const deleteMutation = trpc.scheduledReports.delete.useMutation({
    onSuccess: () => {
      toast.success("Relatório agendado excluído!");
      refetch();
    },
    onError: (error) => {
      toast.error(`Erro ao excluir: ${error.message}`);
    },
  });

------- SuccessionImport.tsx -------
import { useState } from "react";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";
import { Upload, FileJson, CheckCircle2, XCircle, AlertCircle } from "lucide-react";

export default function SuccessionImport() {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [jsonData, setJsonData] = useState<any>(null);
  const [importResult, setImportResult] = useState<any>(null);

  const importMutation = trpc.succession.importSuccessionData.useMutation();
  const importUIPlans = trpc.succession.importUIPlans.useMutation();

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    if (!file.name.endsWith(".json")) {
      toast.error("Por favor, selecione um arquivo JSON");
      return;
    }

    setSelectedFile(file);
    setImportResult(null);

    // Ler conteúdo do arquivo
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target?.result as string);
        setJsonData(data);
        toast.success("Arquivo carregado com sucesso!");
      } catch (error) {
        toast.error("Erro ao ler arquivo JSON");
        setSelectedFile(null);
      }
    };
    reader.readAsText(file);
  };

  const handleImport = async () => {
    if (!jsonData) {
      toast.error("Nenhum arquivo selecionado");
      return;
    }

    try {
      // Detectar formato do JSON

------- Sucessao.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList } from "@/components/ui/command";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { cn } from "@/lib/utils";
import { Loader2, Users, TrendingUp, AlertCircle, Plus, UserPlus, Award, Calendar, Target, Search, Check, ChevronsUpDown, Pencil, Trash2 } from "lucide-react";
import { trpc } from "@/lib/trpc";
import { toast } from "sonner";

/**
 * Página de Mapa de Sucessão
 * Metodologia: 9-Box Succession Planning
 * 
 * Funcionalidades:
 * - Criar novo mapa de sucessão
 * - Incluir sucessores em mapa existente
 * - Abas: Planos de Acompanhamento, Riscos, Timeline, Desenvolvimento
 */

export default function Sucessao() {
  const [selectedPlanId, setSelectedPlanId] = useState<number | null>(null);
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [isAddSuccessorDialogOpen, setIsAddSuccessorDialogOpen] = useState(false);
  const [openEmployeeCombobox, setOpenEmployeeCombobox] = useState(false);
  const [selectedEmployeeId, setSelectedEmployeeId] = useState<number | null>(null);

  // Queries
  const { data: plans, isLoading, refetch } = trpc.succession.list.useQuery();
  const { data: selectedPlan } = trpc.succession.getById.useQuery(
    { id: selectedPlanId! },
    { enabled: !!selectedPlanId }
  );
  const { data: positions } = trpc.positions.list.useQuery();
  const { data: employees } = trpc.employees.list.useQuery();
  const { data: suggestions } = trpc.succession.suggestSuccessors.useQuery(
    { positionId: selectedPlan?.positionId || 0 },
    { enabled: !!selectedPlan?.positionId }
  );

  // Mutations
  const createPlan = trpc.succession.create.useMutation({

------- SucessaoMelhorado.tsx -------
import { useState } from "react";
import DashboardLayout from "@/components/DashboardLayout";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Loader2, Users, TrendingUp, AlertCircle, Plus, Download, Search, ArrowLeft } from "lucide-react";
import { trpc } from "@/lib/trpc";
import { Link } from "wouter";
import { exportMapaSucessao } from "@/lib/exportPDF";
import { toast } from "sonner";

/**
 * Mapa de Sucessão - Versão Melhorada
 * Baseado nas telas de referência UISA
 * 
 * Features:
 * - KPIs no topo (Posições Críticas, Sucessores Prontos, Alto Risco, Cobertura Média)
 * - Filtros avançados (Departamento, Nível de Risco, Impacto, Cobertura)
 * - Visualização em tabela com indicadores visuais
 * - Botão "Adicionar Primeira Posição" quando vazio
 * - Botão "Exportar" relatório
 */

export default function SucessaoMelhorado() {
  const [departmentFilter, setDepartmentFilter] = useState<string>("todos");
  const [riskFilter, setRiskFilter] = useState<string>("todos");
  const [impactFilter, setImpactFilter] = useState<string>("todos");
  const [coverageFilter, setCoverageFilter] = useState<string>("todos");
  const [searchQuery, setSearchQuery] = useState("");

  // Queries
  const { data: plans, isLoading } = trpc.succession.list.useQuery();
  const { data: kpis } = trpc.executive.getKPIs.useQuery({});

  // Calcular KPIs específicos de sucessão
  const posicoescriticas = plans?.filter((p) => p.isCritical).length || 0;
  const sucessoresProntos = 0; // TODO: calcular baseado em readinessLevel
  const altoRisco = plans?.filter((p) => p.riskLevel === "alto" || p.riskLevel === "critico").length || 0;
  const coberturaMedia = plans?.length ? ((sucessoresProntos / plans.length) * 100).toFixed(0) : "0";

  // Filtrar planos
  const filteredPlans = plans?.filter((plan) => {
    if (departmentFilter !== "todos") {
      // TODO: adicionar filtro de departamento quando disponível
    }
    if (riskFilter !== "todos" && plan.riskLevel !== riskFilter) return false;
    if (searchQuery && !plan.positionTitle?.toLowerCase().includes(searchQuery.toLowerCase())) return false;
    return true;

------- TestBigFive.tsx -------
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { toast } from "sonner";
import { Loader2, Brain, CheckCircle2, Mail, ArrowLeft } from "lucide-react";
import { trpc } from "@/lib/trpc";
import { APP_LOGO, APP_TITLE } from "@/const";

/**
 * Página de Teste Big Five (Versão Pública - sem necessidade de login)
 * Questionário interativo com 50 perguntas
 */

export default function TestBigFive() {
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [responses, setResponses] = useState<Record<number, number>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showEmailForm, setShowEmailForm] = useState(false);
  const [email, setEmail] = useState("");
  const [testCompleted, setTestCompleted] = useState(false);
  const [result, setResult] = useState<any>(null);

  // Buscar perguntas DISC (endpoint público)
  const { data: questions, isLoading } = trpc.psychometric.getQuestionsPublic.useQuery({ testType: "bigfive" });

  // Mutation para submeter teste (endpoint público)
  const submitMutation = trpc.psychometric.submitTestPublic.useMutation({
    onSuccess: (data) => {
      setResult(data);
      setTestCompleted(true);
      setIsSubmitting(false);
      toast.success(`Parabéns, ${data.employeeName}! Teste Big Five concluído com sucesso!`);
    },
    onError: (error) => {
      toast.error(`Erro ao submeter teste: ${error.message}`);
      setIsSubmitting(false);
    },
  });

  const handleResponseChange = (questionId: number, score: number) => {
    setResponses({ ...responses, [questionId]: score });
  };

  const handleNext = () => {
    if (!questions) return;
    

------- TestCareerAnchors.tsx -------
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { toast } from "sonner";
import { Loader2, Anchor, CheckCircle2, ArrowLeft, ArrowRight, TrendingUp } from "lucide-react";
import { trpc } from "@/lib/trpc";
import { APP_LOGO } from "@/const";

/**
 * Página de Teste de Âncoras de Carreira (Edgar Schein)
 * 40 perguntas avaliando 8 âncoras de motivação profissional
 */

export default function TestCareerAnchors() {
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [responses, setResponses] = useState<Record<number, number>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showEmailForm, setShowEmailForm] = useState(false);
  const [email, setEmail] = useState("");
  const [testCompleted, setTestCompleted] = useState(false);
  const [result, setResult] = useState<any>(null);

  // Buscar perguntas de Âncoras de Carreira
  const { data: questions, isLoading } = trpc.psychometric.getQuestionsPublic.useQuery({ testType: "careeranchors" });

  // Mutation para submeter teste
  const submitMutation = trpc.psychometric.submitTestPublic.useMutation({
    onSuccess: (data) => {
      setResult(data);
      setTestCompleted(true);
      setIsSubmitting(false);
      toast.success(`Parabéns! Teste de Âncoras de Carreira concluído!`);
    },
    onError: (error) => {
      toast.error(`Erro ao submeter teste: ${error.message}`);
      setIsSubmitting(false);
    },
  });

  const handleResponseChange = (questionId: number, score: number) => {
    setResponses({ ...responses, [questionId]: score });
  };

  const handleNext = () => {
    if (!questions) return;
    

------- TestDISC.tsx -------
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { toast } from "sonner";
import { Loader2, Brain, CheckCircle2, Mail, ArrowLeft } from "lucide-react";
import { trpc } from "@/lib/trpc";
import { APP_LOGO, APP_TITLE } from "@/const";

/**
 * Página de Teste DISC (Versão Pública - sem necessidade de login)
 * Questionário interativo com 40 perguntas
 */

export default function TestDISC() {
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [responses, setResponses] = useState<Record<number, number>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showEmailForm, setShowEmailForm] = useState(false);
  const [email, setEmail] = useState("");
  const [testCompleted, setTestCompleted] = useState(false);
  const [result, setResult] = useState<any>(null);

  // Buscar perguntas DISC (endpoint público)
  const { data: questions, isLoading } = trpc.psychometric.getQuestionsPublic.useQuery({ testType: "disc" });

  // Mutation para submeter teste (endpoint público)
  const submitMutation = trpc.psychometric.submitTestPublic.useMutation({
    onSuccess: (data) => {
      setResult(data);
      setTestCompleted(true);
      setIsSubmitting(false);
      toast.success(`Parabéns, ${data.employeeName}! Teste DISC concluído com sucesso!`);
    },
    onError: (error) => {
      toast.error(`Erro ao submeter teste: ${error.message}`);
      setIsSubmitting(false);
    },
  });

  const handleResponseChange = (questionId: number, score: number) => {
    setResponses({ ...responses, [questionId]: score });
  };

  const handleNext = () => {
    if (!questions) return;
    

------- TestIE.tsx -------
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { toast } from "sonner";
import { Loader2, Brain, CheckCircle2, Mail, ArrowLeft } from "lucide-react";
import { trpc } from "@/lib/trpc";
import { APP_LOGO, APP_TITLE } from "@/const";

/**
 * Página de Teste de Inteligência Emocional (Versão Pública - sem necessidade de login)
 * Questionário interativo com 25 perguntas
 */

export default function TestIE() {
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [responses, setResponses] = useState<Record<number, number>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showEmailForm, setShowEmailForm] = useState(false);
  const [email, setEmail] = useState("");
  const [testCompleted, setTestCompleted] = useState(false);
  const [result, setResult] = useState<any>(null);

  // Buscar perguntas DISC (endpoint público)
  const { data: questions, isLoading } = trpc.psychometric.getQuestionsPublic.useQuery({ testType: "ie" });

  // Mutation para submeter teste (endpoint público)
  const submitMutation = trpc.psychometric.submitTestPublic.useMutation({
    onSuccess: (data) => {
      setResult(data);
      setTestCompleted(true);
      setIsSubmitting(false);
      toast.success(`Parabéns, ${data.employeeName}! Teste de Inteligência Emocional concluído com sucesso!`);
    },
    onError: (error) => {
      toast.error(`Erro ao submeter teste: ${error.message}`);
      setIsSubmitting(false);
    },
  });

  const handleResponseChange = (questionId: number, score: number) => {
    setResponses({ ...responses, [questionId]: score });
  };

  const handleNext = () => {
    if (!questions) return;
    

------- TestLeadership.tsx -------
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { toast } from "sonner";
import { Loader2, Users, CheckCircle2, ArrowLeft, ArrowRight } from "lucide-react";
import { trpc } from "@/lib/trpc";
import { APP_LOGO } from "@/const";

/**
 * Página de Teste de Estilos de Liderança
 * Baseado em teorias de Lewin, Bass e Goleman
 * 30 perguntas avaliando 6 estilos: Autocrático, Democrático, Transformacional, Transacional, Coaching, Laissez-faire
 */

export default function TestLeadership() {
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [responses, setResponses] = useState<Record<number, number>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showEmailForm, setShowEmailForm] = useState(false);
  const [email, setEmail] = useState("");
  const [testCompleted, setTestCompleted] = useState(false);
  const [result, setResult] = useState<any>(null);

  // Buscar perguntas de Liderança
  const { data: questions, isLoading } = trpc.psychometric.getQuestionsPublic.useQuery({ testType: "leadership" });

  // Mutation para submeter teste
  const submitMutation = trpc.psychometric.submitTestPublic.useMutation({
    onSuccess: (data) => {
      setResult(data);
      setTestCompleted(true);
      setIsSubmitting(false);
      toast.success(`Parabéns! Teste de Estilos de Liderança concluído!`);
    },
    onError: (error) => {
      toast.error(`Erro ao submeter teste: ${error.message}`);
      setIsSubmitting(false);
    },
  });

  const handleResponseChange = (questionId: number, score: number) => {
    setResponses({ ...responses, [questionId]: score });
  };

  const handleNext = () => {
    if (!questions) return;

------- TestMBTI.tsx -------
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { toast } from "sonner";
import { Loader2, Brain, CheckCircle2, Mail, ArrowLeft } from "lucide-react";
import { trpc } from "@/lib/trpc";
import { APP_LOGO, APP_TITLE } from "@/const";

/**
 * Página de Teste MBTI (Versão Pública - sem necessidade de login)
 * Questionário interativo com 60 perguntas
 */

export default function TestMBTI() {
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [responses, setResponses] = useState<Record<number, number>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showEmailForm, setShowEmailForm] = useState(false);
  const [email, setEmail] = useState("");
  const [testCompleted, setTestCompleted] = useState(false);
  const [result, setResult] = useState<any>(null);

  // Buscar perguntas DISC (endpoint público)
  const { data: questions, isLoading } = trpc.psychometric.getQuestionsPublic.useQuery({ testType: "mbti" });

  // Mutation para submeter teste (endpoint público)
  const submitMutation = trpc.psychometric.submitTestPublic.useMutation({
    onSuccess: (data) => {
      setResult(data);
      setTestCompleted(true);
      setIsSubmitting(false);
      toast.success(`Parabéns, ${data.employeeName}! Teste MBTI concluído com sucesso!`);
    },
    onError: (error) => {
      toast.error(`Erro ao submeter teste: ${error.message}`);
      setIsSubmitting(false);
    },
  });

  const handleResponseChange = (questionId: number, score: number) => {
    setResponses({ ...responses, [questionId]: score });
  };

  const handleNext = () => {
    if (!questions) return;
    

------- TestVARK.tsx -------
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { toast } from "sonner";
import { Loader2, Brain, CheckCircle2, Mail, ArrowLeft } from "lucide-react";
import { trpc } from "@/lib/trpc";
import { APP_LOGO, APP_TITLE } from "@/const";

/**
 * Página de Teste VARK (Versão Pública - sem necessidade de login)
 * Questionário interativo com 20 perguntas
 */

export default function TestVARK() {
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [responses, setResponses] = useState<Record<number, number>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showEmailForm, setShowEmailForm] = useState(false);
  const [email, setEmail] = useState("");
  const [testCompleted, setTestCompleted] = useState(false);
  const [result, setResult] = useState<any>(null);

  // Buscar perguntas DISC (endpoint público)
  const { data: questions, isLoading } = trpc.psychometric.getQuestionsPublic.useQuery({ testType: "vark" });

  // Mutation para submeter teste (endpoint público)
  const submitMutation = trpc.psychometric.submitTestPublic.useMutation({
    onSuccess: (data) => {
      setResult(data);
      setTestCompleted(true);
      setIsSubmitting(false);
      toast.success(`Parabéns, ${data.employeeName}! Teste VARK concluído com sucesso!`);
    },
    onError: (error) => {
      toast.error(`Erro ao submeter teste: ${error.message}`);
      setIsSubmitting(false);
    },
  });

  const handleResponseChange = (questionId: number, score: number) => {
    setResponses({ ...responses, [questionId]: score });
  };

  const handleNext = () => {
    if (!questions) return;
    

------- TestesResultadosRH.tsx -------
import { useAuth } from "@/_core/hooks/useAuth";
import DashboardLayout from "@/components/DashboardLayout";
import { trpc } from "@/lib/trpc";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Loader2, Brain, Download, Filter, Users, BarChart3, TrendingUp } from "lucide-react";
import { useState } from "react";
import { ResponsiveContainer, BarChart, Bar, XAxis, YAxis, Tooltip } from "recharts";

/**
 * Página de Visualização de Resultados de Testes Psicométricos (RH)
 * Permite visualizar, comparar e exportar resultados de todos os colaboradores
 */

const DISC_COLORS = {
  D: "#ef4444", // red
  I: "#eab308", // yellow
  S: "#22c55e", // green
  C: "#3b82f6", // blue
};

const BIG_FIVE_LABELS: Record<string, string> = {
  O: "Abertura",
  C: "Conscienciosidade",
  E: "Extroversão",
  A: "Amabilidade",
  N: "Neuroticismo",
};

export default function TestesResultadosRH() {
  const { user } = useAuth();
  const [selectedTest, setSelectedTest] = useState<string>("all");
  const [selectedDepartment, setSelectedDepartment] = useState<string>("all");
  const [searchQuery, setSearchQuery] = useState("");

  // Buscar todos os testes (apenas RH/Admin)
  const { data: allTests, isLoading } = trpc.psychometric.getAllTests.useQuery();
  const { data: departments } = trpc.employees.getDepartments.useQuery();

  if (isLoading) {
    return (
      <DashboardLayout>
        <div className="flex items-center justify-center h-96">
          <Loader2 className="w-8 h-8 animate-spin text-primary" />
        </div>
      </DashboardLayout>
    );

==================================================================
FIM DO BACKUP
==================================================================
